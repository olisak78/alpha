
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handlers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">developer-portal-backend/internal/api/handlers/aicore.go (81.9%)</option>
				
				<option value="file1">developer-portal-backend/internal/api/handlers/alert_history_handler.go (0.0%)</option>
				
				<option value="file2">developer-portal-backend/internal/api/handlers/alerts.go (100.0%)</option>
				
				<option value="file3">developer-portal-backend/internal/api/handlers/category.go (100.0%)</option>
				
				<option value="file4">developer-portal-backend/internal/api/handlers/component.go (94.6%)</option>
				
				<option value="file5">developer-portal-backend/internal/api/handlers/documentation.go (100.0%)</option>
				
				<option value="file6">developer-portal-backend/internal/api/handlers/github.go (93.8%)</option>
				
				<option value="file7">developer-portal-backend/internal/api/handlers/health.go (92.6%)</option>
				
				<option value="file8">developer-portal-backend/internal/api/handlers/health_url.go (97.5%)</option>
				
				<option value="file9">developer-portal-backend/internal/api/handlers/jenkins.go (90.4%)</option>
				
				<option value="file10">developer-portal-backend/internal/api/handlers/jira.go (100.0%)</option>
				
				<option value="file11">developer-portal-backend/internal/api/handlers/landscape.go (93.1%)</option>
				
				<option value="file12">developer-portal-backend/internal/api/handlers/ldap.go (100.0%)</option>
				
				<option value="file13">developer-portal-backend/internal/api/handlers/link.go (78.8%)</option>
				
				<option value="file14">developer-portal-backend/internal/api/handlers/plugin.go (83.3%)</option>
				
				<option value="file15">developer-portal-backend/internal/api/handlers/project.go (91.3%)</option>
				
				<option value="file16">developer-portal-backend/internal/api/handlers/sonar.go (100.0%)</option>
				
				<option value="file17">developer-portal-backend/internal/api/handlers/team.go (91.4%)</option>
				
				<option value="file18">developer-portal-backend/internal/api/handlers/user.go (58.4%)</option>
				
				<option value="file19">developer-portal-backend/internal/api/middleware/cors.go (0.0%)</option>
				
				<option value="file20">developer-portal-backend/internal/api/middleware/logging.go (0.0%)</option>
				
				<option value="file21">developer-portal-backend/internal/auth/config.go (21.8%)</option>
				
				<option value="file22">developer-portal-backend/internal/auth/crypto.go (59.7%)</option>
				
				<option value="file23">developer-portal-backend/internal/auth/github.go (26.1%)</option>
				
				<option value="file24">developer-portal-backend/internal/auth/handlers.go (15.1%)</option>
				
				<option value="file25">developer-portal-backend/internal/auth/middleware.go (39.7%)</option>
				
				<option value="file26">developer-portal-backend/internal/auth/service.go (40.6%)</option>
				
				<option value="file27">developer-portal-backend/internal/cache/cache.go (91.1%)</option>
				
				<option value="file28">developer-portal-backend/internal/cache/ttl_config.go (100.0%)</option>
				
				<option value="file29">developer-portal-backend/internal/client/alert_history_client.go (0.0%)</option>
				
				<option value="file30">developer-portal-backend/internal/config/config.go (0.0%)</option>
				
				<option value="file31">developer-portal-backend/internal/database/data_utils.go (89.2%)</option>
				
				<option value="file32">developer-portal-backend/internal/database/database.go (75.3%)</option>
				
				<option value="file33">developer-portal-backend/internal/database/init_data.go (47.2%)</option>
				
				<option value="file34">developer-portal-backend/internal/errors/errors.go (89.7%)</option>
				
				<option value="file35">developer-portal-backend/internal/logger/logger.go (83.3%)</option>
				
				<option value="file36">developer-portal-backend/internal/repository/category.go (83.3%)</option>
				
				<option value="file37">developer-portal-backend/internal/repository/component.go (15.2%)</option>
				
				<option value="file38">developer-portal-backend/internal/repository/documentation.go (0.0%)</option>
				
				<option value="file39">developer-portal-backend/internal/repository/group.go (66.7%)</option>
				
				<option value="file40">developer-portal-backend/internal/repository/landscape.go (19.4%)</option>
				
				<option value="file41">developer-portal-backend/internal/repository/link.go (61.1%)</option>
				
				<option value="file42">developer-portal-backend/internal/repository/organization.go (35.1%)</option>
				
				<option value="file43">developer-portal-backend/internal/repository/plugin.go (90.5%)</option>
				
				<option value="file44">developer-portal-backend/internal/repository/project.go (26.9%)</option>
				
				<option value="file45">developer-portal-backend/internal/repository/team.go (20.6%)</option>
				
				<option value="file46">developer-portal-backend/internal/repository/token.go (95.7%)</option>
				
				<option value="file47">developer-portal-backend/internal/repository/user.go (1.7%)</option>
				
				<option value="file48">developer-portal-backend/internal/service/aicore.go (78.9%)</option>
				
				<option value="file49">developer-portal-backend/internal/service/aicore_stream.go (90.0%)</option>
				
				<option value="file50">developer-portal-backend/internal/service/alert_history_service.go (0.0%)</option>
				
				<option value="file51">developer-portal-backend/internal/service/alerts.go (0.0%)</option>
				
				<option value="file52">developer-portal-backend/internal/service/category.go (100.0%)</option>
				
				<option value="file53">developer-portal-backend/internal/service/component.go (0.0%)</option>
				
				<option value="file54">developer-portal-backend/internal/service/documentation.go (96.3%)</option>
				
				<option value="file55">developer-portal-backend/internal/service/github.go (83.4%)</option>
				
				<option value="file56">developer-portal-backend/internal/service/github_auth_interface.go (66.7%)</option>
				
				<option value="file57">developer-portal-backend/internal/service/jenkins.go (81.6%)</option>
				
				<option value="file58">developer-portal-backend/internal/service/jira.go (90.5%)</option>
				
				<option value="file59">developer-portal-backend/internal/service/landscape.go (88.3%)</option>
				
				<option value="file60">developer-portal-backend/internal/service/ldap.go (96.6%)</option>
				
				<option value="file61">developer-portal-backend/internal/service/link.go (91.6%)</option>
				
				<option value="file62">developer-portal-backend/internal/service/plugin.go (90.6%)</option>
				
				<option value="file63">developer-portal-backend/internal/service/project.go (0.0%)</option>
				
				<option value="file64">developer-portal-backend/internal/service/sonar.go (98.3%)</option>
				
				<option value="file65">developer-portal-backend/internal/service/team.go (97.2%)</option>
				
				<option value="file66">developer-portal-backend/internal/service/user.go (92.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package handlers

import (
        "mime/multipart"
        "net/http"

        "developer-portal-backend/internal/errors"
        "developer-portal-backend/internal/logger"
        "developer-portal-backend/internal/service"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
)

// AICoreHandler handles HTTP requests for AI Core operations
type AICoreHandler struct {
        aicoreService service.AICoreServiceInterface
        validator     *validator.Validate
}

// NewAICoreHandler creates a new AI Core handler
func NewAICoreHandler(aicoreService service.AICoreServiceInterface, validator *validator.Validate) *AICoreHandler <span class="cov10" title="46">{
        return &amp;AICoreHandler{
                aicoreService: aicoreService,
                validator:     validator,
        }
}</span>

// handleAICoreError handles common AI Core service errors and returns appropriate HTTP responses
func (h *AICoreHandler) handleAICoreError(c *gin.Context, err error) <span class="cov7" title="15">{
        switch </span>{
        case errors.IsAuthentication(err):<span class="cov3" title="3">
                c.JSON(http.StatusUnauthorized, gin.H{"error": errors.ErrAuthenticationRequired.Error()})</span>
        case errors.IsAuthorization(err):<span class="cov4" title="4">
                c.JSON(http.StatusForbidden, gin.H{"error": err.Error()})</span>
        case errors.IsConfiguration(err):<span class="cov2" title="2">
                c.JSON(http.StatusForbidden, gin.H{"error": errors.ErrAICoreCredentialsNotConfigured.Message})</span>
        case errors.IsNotFound(err):<span class="cov1" title="1">
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})</span>
        default:<span class="cov4" title="5">
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})</span>
        }
}

// GetDeployments handles GET /ai-core/deployments
// @Summary Get AI Core deployments
// @Description Get all deployments from AI Core for the authenticated user's team
// @Tags ai-core
// @Accept json
// @Produce json
// @Success 200 {object} service.AICoreDeploymentsResponse "Successfully retrieved deployments"
// @Failure 400 {object} map[string]interface{} "Bad request"
// @Failure 401 {object} map[string]interface{} "Unauthorized"
// @Failure 403 {object} map[string]interface{} "User not assigned to team or team credentials not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /ai-core/deployments [get]
func (h *AICoreHandler) GetDeployments(c *gin.Context) <span class="cov5" title="8">{
        deployments, err := h.aicoreService.GetDeployments(c)
        if err != nil </span><span class="cov4" title="5">{
                logger.FromGinContext(c).WithField("handler", "GetDeployments").
                        Errorf("AI Core: GetDeployments failed: %v", err)
                h.handleAICoreError(c, err)
                return
        }</span>

        <span class="cov3" title="3">c.JSON(http.StatusOK, deployments)</span>
}

// GetModels handles GET /ai-core/models
// @Summary Get AI Core models
// @Description Get all available models from AI Core for a specific scenario
// @Tags ai-core
// @Accept json
// @Produce json
// @Param scenarioId query string true "Scenario ID to get models for"
// @Success 200 {object} service.AICoreModelsResponse "Successfully retrieved models"
// @Failure 400 {object} map[string]interface{} "Bad request - missing scenarioId parameter"
// @Failure 401 {object} map[string]interface{} "Unauthorized"
// @Failure 403 {object} map[string]interface{} "User not assigned to team or team credentials not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /ai-core/models [get]
func (h *AICoreHandler) GetModels(c *gin.Context) <span class="cov2" title="2">{
        scenarioID := c.Query("scenarioId")
        if scenarioID == "" </span><span class="cov1" title="1">{
                logger.FromGinContext(c).WithField("handler", "GetModels").
                        Warn("AI Core: Missing required scenarioId parameter")
                c.JSON(http.StatusBadRequest, gin.H{"error": errors.ErrMissingScenarioID.Error()})
                return
        }</span>

        <span class="cov1" title="1">models, err := h.aicoreService.GetModels(c, scenarioID)
        if err != nil </span><span class="cov0" title="0">{
                logger.FromGinContext(c).WithFields(map[string]interface{}{
                        "handler":     "GetModels",
                        "scenario_id": scenarioID,
                }).Errorf("AI Core: GetModels failed: %v", err)
                h.handleAICoreError(c, err)
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, models)</span>
}

// GetConfigurations handles GET /ai-core/configurations
// @Summary Get AI Core configurations
// @Description Get all configurations from AI Core for the authenticated user's team
// @Tags ai-core
// @Accept json
// @Produce json
// @Success 200 {object} service.AICoreConfigurationsResponse "Successfully retrieved configurations"
// @Failure 400 {object} map[string]interface{} "Bad request"
// @Failure 401 {object} map[string]interface{} "Unauthorized"
// @Failure 403 {object} map[string]interface{} "User not assigned to team or team credentials not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /ai-core/configurations [get]
func (h *AICoreHandler) GetConfigurations(c *gin.Context) <span class="cov5" title="6">{
        configurations, err := h.aicoreService.GetConfigurations(c)
        if err != nil </span><span class="cov4" title="4">{
                h.handleAICoreError(c, err)
                return
        }</span>

        <span class="cov2" title="2">c.JSON(http.StatusOK, configurations)</span>
}

// CreateConfiguration handles POST /ai-core/configurations
// @Summary Create AI Core configuration
// @Description Create a new configuration in AI Core for the authenticated user's team
// @Tags ai-core
// @Accept json
// @Produce json
// @Param configuration body service.AICoreConfigurationRequest true "Configuration data"
// @Success 201 {object} service.AICoreConfigurationResponse "Successfully created configuration"
// @Failure 400 {object} map[string]interface{} "Invalid request body"
// @Failure 401 {object} map[string]interface{} "Unauthorized"
// @Failure 403 {object} map[string]interface{} "User not assigned to team or team credentials not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /ai-core/configurations [post]
func (h *AICoreHandler) CreateConfiguration(c *gin.Context) <span class="cov3" title="3">{
        var req service.AICoreConfigurationRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Validate the request
        <span class="cov2" title="2">if err := h.validator.Struct(&amp;req); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">configuration, err := h.aicoreService.CreateConfiguration(c, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleAICoreError(c, err)
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusCreated, configuration)</span>
}

// CreateDeployment handles POST /ai-core/deployments
// @Summary Create AI Core deployment
// @Description Create a new deployment in AI Core using either an existing configuration ID or by creating a new configuration first
// @Tags ai-core
// @Accept json
// @Produce json
// @Param deployment body service.AICoreDeploymentRequest true "Deployment data - either configurationId or configurationRequest must be provided"
// @Success 202 {object} service.AICoreDeploymentResponse "Successfully scheduled deployment"
// @Failure 400 {object} map[string]interface{} "Invalid request body"
// @Failure 401 {object} map[string]interface{} "Unauthorized"
// @Failure 403 {object} map[string]interface{} "User not assigned to team or team credentials not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /ai-core/deployments [post]
func (h *AICoreHandler) CreateDeployment(c *gin.Context) <span class="cov4" title="5">{
        var req service.AICoreDeploymentRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                logger.FromGinContext(c).WithFields(map[string]interface{}{
                        "handler": "CreateDeployment",
                        "error":   err.Error(),
                }).Warn("AI Core: Invalid request body")
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Validate that either configurationId or configurationRequest is provided, but not both
        <span class="cov4" title="5">if req.ConfigurationID == nil &amp;&amp; req.ConfigurationRequest == nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": errors.ErrMissingConfigurationInput.Error()})
                return
        }</span>
        <span class="cov4" title="4">if req.ConfigurationID != nil &amp;&amp; req.ConfigurationRequest != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": errors.ErrBothConfigurationInputs.Error()})
                return
        }</span>

        // If configurationRequest is provided, validate its required fields
        <span class="cov3" title="3">if req.ConfigurationRequest != nil </span><span class="cov2" title="2">{
                if err := h.validator.Struct(req.ConfigurationRequest); err != nil </span><span class="cov1" title="1">{
                        logger.FromGinContext(c).WithFields(map[string]interface{}{
                                "handler": "CreateDeployment",
                                "error":   err.Error(),
                        }).Warn("AI Core: Configuration request validation failed")
                        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>
        }

        <span class="cov2" title="2">deployment, err := h.aicoreService.CreateDeployment(c, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                logger.FromGinContext(c).WithField("handler", "CreateDeployment").
                        Errorf("AI Core: CreateDeployment failed: %v", err)
                h.handleAICoreError(c, err)
                return
        }</span>

        <span class="cov2" title="2">c.JSON(http.StatusAccepted, deployment)</span>
}

// UpdateDeployment handles PATCH /ai-core/deployments/{deploymentId}
// @Summary Update AI Core deployment
// @Description Update target status or configuration of a deployment in AI Core
// @Tags ai-core
// @Accept json
// @Produce json
// @Param deploymentId path string true "Deployment ID"
// @Param modification body service.AICoreDeploymentModificationRequest true "Deployment modification data"
// @Success 202 {object} service.AICoreDeploymentModificationResponse "Successfully scheduled deployment modification"
// @Failure 400 {object} map[string]interface{} "Invalid request body"
// @Failure 401 {object} map[string]interface{} "Unauthorized"
// @Failure 403 {object} map[string]interface{} "User not assigned to team or team credentials not found"
// @Failure 404 {object} map[string]interface{} "Deployment not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /ai-core/deployments/{deploymentId} [patch]
func (h *AICoreHandler) UpdateDeployment(c *gin.Context) <span class="cov2" title="2">{
        deploymentID := c.Param("deploymentId")
        if deploymentID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": errors.ErrMissingDeploymentID.Error()})
                return
        }</span>

        <span class="cov2" title="2">var req service.AICoreDeploymentModificationRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // At least one field should be provided
        <span class="cov2" title="2">if req.TargetStatus == "" &amp;&amp; req.ConfigurationID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": errors.ErrMissingTargetStatusOrConfigID.Error()})
                return
        }</span>

        <span class="cov1" title="1">response, err := h.aicoreService.UpdateDeployment(c, deploymentID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleAICoreError(c, err)
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusAccepted, response)</span>
}

// GetMe handles GET /ai-core/me
// @Summary Get AI Core user context
// @Description Returns current username and AI instances derived from metadata and team role
// @Tags ai-core
// @Accept json
// @Produce json
// @Success 200 {object} service.AICoreMeResponse "Successfully retrieved AI Core user context"
// @Failure 401 {object} map[string]interface{} "Unauthorized"
// @Failure 403 {object} map[string]interface{} "Forbidden"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /ai-core/me [get]
func (h *AICoreHandler) GetMe(c *gin.Context) <span class="cov4" title="4">{
        resp, err := h.aicoreService.GetMe(c)
        if err != nil </span><span class="cov3" title="3">{
                h.handleAICoreError(c, err)
                return
        }</span>
        <span class="cov1" title="1">c.JSON(http.StatusOK, resp)</span>
}

// GetDeploymentDetails handles GET /ai-core/deployments/{deploymentId}
// @Summary Get AI Core deployment details
// @Description Get detailed information about a specific deployment from AI Core
// @Tags ai-core
// @Accept json
// @Produce json
// @Param deploymentId path string true "Deployment ID"
// @Success 200 {object} service.AICoreDeploymentDetailsResponse "Successfully retrieved deployment details"
// @Failure 400 {object} map[string]interface{} "Bad request"
// @Failure 401 {object} map[string]interface{} "Unauthorized"
// @Failure 403 {object} map[string]interface{} "User not assigned to team or team credentials not found"
// @Failure 404 {object} map[string]interface{} "Deployment not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /ai-core/deployments/{deploymentId} [get]
func (h *AICoreHandler) GetDeploymentDetails(c *gin.Context) <span class="cov2" title="2">{
        deploymentID := c.Param("deploymentId")
        if deploymentID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": errors.ErrMissingDeploymentID})
                return
        }</span>

        <span class="cov2" title="2">response, err := h.aicoreService.GetDeploymentDetails(c, deploymentID)
        if err != nil </span><span class="cov1" title="1">{
                h.handleAICoreError(c, err)
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, response)</span>
}

// DeleteDeployment handles DELETE /ai-core/deployments/{deploymentId}
// @Summary Delete AI Core deployment
// @Description Mark deployment as deleted in AI Core
// @Tags ai-core
// @Accept json
// @Produce json
// @Param deploymentId path string true "Deployment ID"
// @Success 202 {object} service.AICoreDeploymentDeletionResponse "Successfully scheduled deployment deletion"
// @Failure 400 {object} map[string]interface{} "Bad request"
// @Failure 401 {object} map[string]interface{} "Unauthorized"
// @Failure 403 {object} map[string]interface{} "User not assigned to team or team credentials not found"
// @Failure 404 {object} map[string]interface{} "Deployment not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /ai-core/deployments/{deploymentId} [delete]
func (h *AICoreHandler) DeleteDeployment(c *gin.Context) <span class="cov1" title="1">{
        deploymentID := c.Param("deploymentId")
        if deploymentID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": errors.ErrMissingDeploymentID})
                return
        }</span>

        <span class="cov1" title="1">response, err := h.aicoreService.DeleteDeployment(c, deploymentID)
        if err != nil </span><span class="cov0" title="0">{
                h.handleAICoreError(c, err)
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusAccepted, response)</span>
}

// ChatInference handles POST /ai-core/chat/inference
// @Summary Chat inference with AI Core deployed model
// @Description Send chat messages to a deployed model and get AI responses (supports streaming)
// @Tags ai-core
// @Accept json
// @Produce json
// @Produce text/event-stream
// @Param request body service.AICoreInferenceRequest true "Chat inference request"
// @Success 200 {object} service.AICoreInferenceResponse "Successfully received inference response"
// @Failure 400 {object} map[string]interface{} "Invalid request body"
// @Failure 401 {object} map[string]interface{} "Unauthorized"
// @Failure 403 {object} map[string]interface{} "User not assigned to team or team credentials not found"
// @Failure 404 {object} map[string]interface{} "Deployment not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /ai-core/chat/inference [post]
func (h *AICoreHandler) ChatInference(c *gin.Context) <span class="cov5" title="7">{
        var req service.AICoreInferenceRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Validate the request
        <span class="cov5" title="6">if err := h.validator.Struct(&amp;req); err != nil </span><span class="cov2" title="2">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // If streaming is requested, use Server-Sent Events (SSE)
        <span class="cov4" title="4">if req.Stream </span><span class="cov2" title="2">{
                h.streamChatInference(c, &amp;req)
                return
        }</span>

        // Non-streaming response
        <span class="cov2" title="2">response, err := h.aicoreService.ChatInference(c, &amp;req)
        if err != nil </span><span class="cov1" title="1">{
                h.handleAICoreError(c, err)
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, response)</span>
}

// streamChatInference handles streaming responses using Server-Sent Events (SSE)
func (h *AICoreHandler) streamChatInference(c *gin.Context, req *service.AICoreInferenceRequest) <span class="cov2" title="2">{
        // Set headers for SSE
        c.Header("Content-Type", "text/event-stream")
        c.Header("Cache-Control", "no-cache")
        c.Header("Connection", "keep-alive")
        c.Header("X-Accel-Buffering", "no") // Disable nginx buffering

        // Use the service to stream the response
        err := h.aicoreService.ChatInferenceStream(c, req, c.Writer)
        if err != nil </span><span class="cov1" title="1">{
                // For streaming errors, we need to send an error event
                logger.FromGinContext(c).WithField("handler", "streamChatInference").
                        Errorf("AI Core: Streaming inference failed: %v", err)
                // Send error as SSE event
                c.SSEvent("error", gin.H{"error": err.Error()})
        }</span>
}

// UploadAttachment handles POST /ai-core/upload
// @Summary Upload file attachments for AI inference
// @Description Upload multiple files for use in multimodal AI requests (combined max 5MB)
// @Tags ai-core
// @Accept multipart/form-data
// @Produce json
// @Param files formData file true "Files to upload (multiple allowed)"
// @Success 200 {object} map[string]interface{} "Successfully uploaded files"
// @Failure 400 {object} map[string]interface{} "Invalid files or size"
// @Failure 401 {object} map[string]interface{} "Unauthorized"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /ai-core/upload [post]
func (h *AICoreHandler) UploadAttachment(c *gin.Context) <span class="cov4" title="5">{
        // Maximum combined size for all files: 5MB
        const maxTotalSize = 5 &lt;&lt; 20 // 5 MB

        // Parse multipart form with the size limit
        if err := c.Request.ParseMultipartForm(maxTotalSize); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": errors.ErrFileSizeTooLarge.Error()})
                return
        }</span>

        // Get the multipart form
        <span class="cov4" title="5">form := c.Request.MultipartForm
        if form == nil || form.File == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": errors.ErrNoFilesProvided.Error()})
                return
        }</span>

        // Get all files from the form (supports both "file" and "files" field names)
        <span class="cov4" title="5">var fileHeaders []*multipart.FileHeader
        if files, ok := form.File["files"]; ok </span><span class="cov1" title="1">{
                fileHeaders = append(fileHeaders, files...)
        }</span>
        <span class="cov4" title="5">if file, ok := form.File["file"]; ok </span><span class="cov3" title="3">{
                fileHeaders = append(fileHeaders, file...)
        }</span>

        <span class="cov4" title="5">if len(fileHeaders) == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": errors.ErrNoFilesProvided.Error()})
                return
        }</span>

        // Calculate combined size
        <span class="cov4" title="4">var totalSize int64
        for _, header := range fileHeaders </span><span class="cov4" title="5">{
                totalSize += header.Size
        }</span>

        <span class="cov4" title="4">if totalSize &gt; maxTotalSize </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":     errors.ErrCombinedFileSizeExceeds.Error(),
                        "totalSize": totalSize,
                        "maxSize":   maxTotalSize,
                })
                return
        }</span>

        // Process all files
        <span class="cov3" title="3">uploadedFiles := make([]map[string]interface{}, 0, len(fileHeaders))

        for _, header := range fileHeaders </span><span class="cov4" title="4">{
                file, err := header.Open()
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to open file: " + header.Filename})
                        return
                }</span>
                <span class="cov4" title="4">defer file.Close() // Ensure file is always closed

                // Process the upload using the service
                response, err := h.aicoreService.UploadAttachment(c, file, header)
                if err != nil </span><span class="cov1" title="1">{
                        h.handleAICoreError(c, err)
                        return
                }</span>

                <span class="cov3" title="3">uploadedFiles = append(uploadedFiles, response)</span>
        }

        <span class="cov2" title="2">c.JSON(http.StatusOK, gin.H{
                "files":     uploadedFiles,
                "count":     len(uploadedFiles),
                "totalSize": totalSize,
        })</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handlers

import (
        "errors"
        "net/http"

        apperrors "developer-portal-backend/internal/errors"
        "developer-portal-backend/internal/service"
        "github.com/gin-gonic/gin"
)

// AlertHistoryHandler handles HTTP requests for alert history
type AlertHistoryHandler struct {
        service *service.AlertHistoryService
}

// NewAlertHistoryHandler creates a new alert history handler
func NewAlertHistoryHandler(service *service.AlertHistoryService) *AlertHistoryHandler <span class="cov0" title="0">{
        return &amp;AlertHistoryHandler{
                service: service,
        }
}</span>

// GetAvailableProjects godoc
// @Summary Get all alert history projects
// @Description Retrieve a list of all available projects configured in the alert history system
// @Tags alert-history
// @Accept json
// @Produce json
// @Success 200 {object} client.ProjectsResponse "Successfully retrieved projects"
// @Failure 500 {object} map[string]string "Internal server error"
// @Router /alert-history/projects [get]
// @Security BearerAuth
func (h *AlertHistoryHandler) GetAvailableProjects(c *gin.Context) <span class="cov0" title="0">{
        projects, err := h.service.GetAvailableProjects()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve projects from alert history service"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, projects)</span>
}

// GetAlertsByProject godoc
// @Summary Get alerts by project
// @Description Retrieve alerts for a specific project with optional filtering and pagination
// @Tags alert-history
// @Accept json
// @Produce json
// @Param project path string true "Project name (must be one of cis2, usrv, cloud_automation)"
// @Param page query int false "Page number (min 1)" default(1) minimum(1)
// @Param pageSize query int false "Items per page (min 1, max 100)" default(50) minimum(1) maximum(100)
// @Param severity query string false "Filter by severity (e.g., critical, warning, info)"
// @Param region query string false "Filter by region label"
// @Param landscape query string false "Filter by landscape"
// @Param status query string false "Filter by status (firing or resolved)" Enums(firing, resolved)
// @Param component query string false "Filter by component label"
// @Param alertname query string false "Filter by alert name"
// @Param start_time query string false "Filter alerts after this time (RFC3339 format)"
// @Param end_time query string false "Filter alerts before this time (RFC3339 format)"
// @Success 200 {object} client.AlertHistoryPaginatedResponse "Successfully retrieved alerts"
// @Failure 400 {object} map[string]string "Invalid request parameters"
// @Failure 500 {object} map[string]string "Internal server error"
// @Router /alert-history/alerts/{project} [get]
// @Security BearerAuth
func (h *AlertHistoryHandler) GetAlertsByProject(c *gin.Context) <span class="cov0" title="0">{
        project := c.Param("project")

        // Collect all query parameters to pass to the external service
        filters := make(map[string]string)

        // Add all possible filter parameters
        if page := c.Query("page"); page != "" </span><span class="cov0" title="0">{
                filters["page"] = page
        }</span>
        <span class="cov0" title="0">if pageSize := c.Query("pageSize"); pageSize != "" </span><span class="cov0" title="0">{
                filters["pageSize"] = pageSize
        }</span>
        <span class="cov0" title="0">if severity := c.Query("severity"); severity != "" </span><span class="cov0" title="0">{
                filters["severity"] = severity
        }</span>
        <span class="cov0" title="0">if region := c.Query("region"); region != "" </span><span class="cov0" title="0">{
                filters["region"] = region
        }</span>
        <span class="cov0" title="0">if landscape := c.Query("landscape"); landscape != "" </span><span class="cov0" title="0">{
                filters["landscape"] = landscape
        }</span>
        <span class="cov0" title="0">if status := c.Query("status"); status != "" </span><span class="cov0" title="0">{
                filters["status"] = status
        }</span>
        <span class="cov0" title="0">if component := c.Query("component"); component != "" </span><span class="cov0" title="0">{
                filters["component"] = component
        }</span>
        <span class="cov0" title="0">if alertname := c.Query("alertname"); alertname != "" </span><span class="cov0" title="0">{
                filters["alertname"] = alertname
        }</span>
        <span class="cov0" title="0">if startTime := c.Query("start_time"); startTime != "" </span><span class="cov0" title="0">{
                filters["start_time"] = startTime
        }</span>
        <span class="cov0" title="0">if endTime := c.Query("end_time"); endTime != "" </span><span class="cov0" title="0">{
                filters["end_time"] = endTime
        }</span>

        // Call the external service
        <span class="cov0" title="0">response, err := h.service.GetAlertsByProject(project, filters)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, apperrors.ErrMissingProject) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve alerts from alert history service"})
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

// GetAlertByFingerprint godoc
// @Summary Get alert by fingerprint
// @Description Retrieve a specific alert by its unique fingerprint within a project
// @Tags alert-history
// @Accept json
// @Produce json
// @Param project path string true "Project name (alphanumeric, dashes, underscores)"
// @Param fingerprint path string true "Alert fingerprint (hexadecimal string, max 128 chars)"
// @Success 200 {object} client.AlertHistoryResponse "Successfully retrieved alert"
// @Failure 400 {object} map[string]string "Invalid request parameters"
// @Failure 404 {object} map[string]string "Alert not found"
// @Failure 500 {object} map[string]string "Internal server error"
// @Router /alert-history/alerts/{project}/{fingerprint} [get]
// @Security BearerAuth
func (h *AlertHistoryHandler) GetAlertByFingerprint(c *gin.Context) <span class="cov0" title="0">{
        project := c.Param("project")
        fingerprint := c.Param("fingerprint")

        // Call the external service
        alert, err := h.service.GetAlertByFingerprint(project, fingerprint)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, apperrors.ErrAlertNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">if errors.Is(err, apperrors.ErrMissingProject) || errors.Is(err, apperrors.ErrMissingFingerprint) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve alert from alert history service"})
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, alert)</span>
}

// UpdateAlertLabel godoc
// @Summary Update alert label
// @Description Update or add a label for a specific alert
// @Tags alert-history
// @Accept json
// @Produce json
// @Param project path string true "Project name (alphanumeric, dashes, underscores)"
// @Param fingerprint path string true "Alert fingerprint (hexadecimal string, max 128 chars)"
// @Param body body map[string]string true "Label update request with 'key' and 'value' fields"
// @Success 200 {object} client.UpdateLabelResponse "Label updated successfully"
// @Failure 400 {object} map[string]string "Invalid request parameters or body"
// @Failure 404 {object} map[string]string "Alert not found"
// @Failure 500 {object} map[string]string "Internal server error"
// @Router /alert-history/alerts/{project}/{fingerprint}/label [put]
// @Security BearerAuth
func (h *AlertHistoryHandler) UpdateAlertLabel(c *gin.Context) <span class="cov0" title="0">{
        project := c.Param("project")
        fingerprint := c.Param("fingerprint")

        // Parse request body
        var req struct {
                Key   string `json:"key" binding:"required"`
                Value string `json:"value" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body: " + err.Error()})
                return
        }</span>

        // Call the external service
        <span class="cov0" title="0">response, err := h.service.UpdateAlertLabel(project, fingerprint, req.Key, req.Value)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, apperrors.ErrAlertNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">if errors.Is(err, apperrors.ErrMissingProject) || errors.Is(err, apperrors.ErrMissingFingerprint) || errors.Is(err, apperrors.ErrMissingLabelKey) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update label in alert history service"})
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

// GetAlertFilters godoc
// @Summary Get available filter values for alerts
// @Description Retrieve available filter values for alerts in a specific project. Returns a dynamic map where keys are filter names (e.g., alertname, severity, status, landscape, region) and values are arrays of available options. Use query parameters to narrow down results.
// @Tags alert-history
// @Accept json
// @Produce json
// @Param project path string true "Project name (must be one of cis2, usrv, cloud_automation)"
// @Param severity query string false "Filter by severity level (e.g., critical, warning, info)"
// @Param landscape query string false "Filter by landscape (e.g., production, staging, development)"
// @Param status query string false "Filter by alert status (firing or resolved)" Enums(firing, resolved)
// @Param alertname query string false "Filter by alert name"
// @Param region query string false "Filter by region (e.g., us-east-1, eu-west-1)"
// @Param component query string false "Filter by component label"
// @Param start_time query string false "Filter alerts starting from this time (RFC3339 format)"
// @Param end_time query string false "Filter alerts up to this time (RFC3339 format)"
// @Success 200 {object} map[string][]string "Successfully retrieved filter values as a dynamic map"
// @Failure 400 {object} map[string]string "Invalid query parameters"
// @Failure 404 {object} map[string]string "Project not found"
// @Failure 500 {object} map[string]string "Internal server error"
// @Router /alert-history/alerts/{project}/filters [get]
// @Security BearerAuth
func (h *AlertHistoryHandler) GetAlertFilters(c *gin.Context) <span class="cov0" title="0">{
        project := c.Param("project")

        // Collect all query parameters to pass to the external service
        filters := make(map[string]string)

        // Add all possible filter parameters
        if severity := c.Query("severity"); severity != "" </span><span class="cov0" title="0">{
                filters["severity"] = severity
        }</span>
        <span class="cov0" title="0">if landscape := c.Query("landscape"); landscape != "" </span><span class="cov0" title="0">{
                filters["landscape"] = landscape
        }</span>
        <span class="cov0" title="0">if status := c.Query("status"); status != "" </span><span class="cov0" title="0">{
                filters["status"] = status
        }</span>
        <span class="cov0" title="0">if alertname := c.Query("alertname"); alertname != "" </span><span class="cov0" title="0">{
                filters["alertname"] = alertname
        }</span>
        <span class="cov0" title="0">if region := c.Query("region"); region != "" </span><span class="cov0" title="0">{
                filters["region"] = region
        }</span>
        <span class="cov0" title="0">if component := c.Query("component"); component != "" </span><span class="cov0" title="0">{
                filters["component"] = component
        }</span>
        <span class="cov0" title="0">if startTime := c.Query("start_time"); startTime != "" </span><span class="cov0" title="0">{
                filters["start_time"] = startTime
        }</span>
        <span class="cov0" title="0">if endTime := c.Query("end_time"); endTime != "" </span><span class="cov0" title="0">{
                filters["end_time"] = endTime
        }</span>

        // Call the external service
        <span class="cov0" title="0">response, err := h.service.GetAlertFilters(project, filters)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, apperrors.ErrMissingProject) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve filters from alert history service"})
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "developer-portal-backend/internal/auth"
        apperrors "developer-portal-backend/internal/errors"
        "developer-portal-backend/internal/service"
        "net/http"

        "github.com/gin-gonic/gin"
)

type AlertsHandler struct {
        alertsService service.AlertsServiceInterface
}

func NewAlertsHandler(alertsService service.AlertsServiceInterface) *AlertsHandler <span class="cov10" title="15">{
        return &amp;AlertsHandler{
                alertsService: alertsService,
        }
}</span>

// GetAlerts godoc
// @Summary Get Prometheus alerts from GitHub repository
// @Description Fetches all Prometheus alert configurations from the configured GitHub repository
// @Tags alerts
// @Accept json
// @Produce json
// @Param projectId path string true "Project ID"
// @Success 200 {object} map[string]interface{} "Alerts data"
// @Failure 400 {object} map[string]interface{} "Bad request"
// @Failure 404 {object} map[string]interface{} "Project not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Router /api/v1/projects/{projectId}/alerts [get]
func (h *AlertsHandler) GetAlerts(c *gin.Context) <span class="cov7" title="7">{
        // Get authenticated user claims
        claimsInterface, exists := c.Get("auth_claims")
        if !exists </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": apperrors.ErrAuthenticationRequired.Message})
                return
        }</span>

        <span class="cov6" title="6">claims, ok := claimsInterface.(*auth.AuthClaims)
        if !ok </span><span class="cov1" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": apperrors.ErrAuthenticationInvalidClaims.Message})
                return
        }</span>

        <span class="cov6" title="5">projectID := c.Param("projectId")
        if projectID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": apperrors.NewMissingQueryParam("projectId").Error()})
                return
        }</span>

        // get GitHub provider from param 'provider'. TODO set 'githubtools' if not found. prepare to support multiple providers in future - which client currently doesn't support. should be mandatory.
        <span class="cov5" title="4">provider := c.DefaultQuery("provider", "githubtools")

        alerts, err := h.alertsService.GetProjectAlerts(c.Request.Context(), projectID, claims.UUID, provider)
        if err != nil </span><span class="cov4" title="3">{
                if err.Error() == apperrors.ErrProjectNotFound.Error() </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": apperrors.ErrProjectNotFound.Error()})
                        return
                }</span>
                <span class="cov3" title="2">if err.Error() == apperrors.ErrAlertsRepositoryNotConfigured.Error() </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": apperrors.ErrAlertsRepositoryNotConfigured.Error()})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return</span>
        }

        <span class="cov1" title="1">c.JSON(http.StatusOK, alerts)</span>
}

// CreateAlertPR godoc
// @Summary Create a pull request with alert changes
// @Description Creates a pull request to update Prometheus alert configurations in GitHub
// @Tags alerts
// @Accept json
// @Produce json
// @Param projectId path string true "Project ID"
// @Param body body map[string]interface{} true "Alert changes"
// @Success 200 {object} map[string]interface{} "PR created successfully"
// @Failure 400 {object} map[string]interface{} "Bad request"
// @Failure 404 {object} map[string]interface{} "Project not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Router /api/v1/projects/{projectId}/alerts/pr [post]
func (h *AlertsHandler) CreateAlertPR(c *gin.Context) <span class="cov7" title="8">{
        // Get authenticated user claims
        claimsInterface, exists := c.Get("auth_claims")
        if !exists </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": apperrors.ErrAuthenticationRequired})
                return
        }</span>

        <span class="cov7" title="7">claims, ok := claimsInterface.(*auth.AuthClaims)
        if !ok </span><span class="cov1" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": apperrors.ErrAuthenticationInvalidClaims})
                return
        }</span>

        <span class="cov6" title="6">projectID := c.Param("projectId")
        if projectID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": apperrors.NewMissingQueryParam("projectId").Error()})
                return
        }</span>

        // get GitHub provider from param 'provider'. TODO set 'githubtools' if not found. prepare to support multiple providers in future - which client currently doesn't support. should be mandatory.
        <span class="cov6" title="5">provider := c.DefaultQuery("provider", "githubtools")

        var payload struct {
                FileName    string `json:"fileName"`
                Content     string `json:"content"`
                Message     string `json:"message"`
                Description string `json:"description"`
        }

        if err := c.ShouldBindJSON(&amp;payload); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov5" title="4">prURL, err := h.alertsService.CreateAlertPR(c.Request.Context(), projectID, claims.UUID, provider, payload.FileName, payload.Content, payload.Message, payload.Description)
        if err != nil </span><span class="cov3" title="2">{
                if err.Error() == apperrors.ErrProjectNotFound.Error() </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": apperrors.ErrProjectNotFound.Error()})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return</span>
        }

        <span class="cov3" title="2">c.JSON(http.StatusOK, gin.H{
                "message": "Pull request created successfully",
                "prUrl":   prURL,
        })</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "developer-portal-backend/internal/service"

        "github.com/gin-gonic/gin"
)

// CategoryHandler handles HTTP requests for category operations
type CategoryHandler struct {
        categoryService service.CategoryServiceInterface
}

// NewCategoryHandler creates a new category handler
func NewCategoryHandler(categoryService service.CategoryServiceInterface) *CategoryHandler <span class="cov10" title="4">{
        return &amp;CategoryHandler{
                categoryService: categoryService,
        }
}</span>

// ListCategories handles GET /categories
// @Summary List all categories
// @Description Get all categories with pagination support
// @Tags categories
// @Accept json
// @Produce json
// @Param page query int false "Page number" default(1)
// @Param page_size query int false "Number of items per page" default(1000)
// @Success 200 {object} service.CategoryListResponse "Successfully retrieved categories"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /categories [get]
func (h *CategoryHandler) ListCategories(c *gin.Context) <span class="cov10" title="4">{
        // Parse pagination parameters (default to large page size to effectively return all)
        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        pageSize, _ := strconv.Atoi(c.DefaultQuery("page_size", "1000"))

        if page &lt; 1 </span><span class="cov1" title="1">{
                page = 1
        }</span>
        <span class="cov10" title="4">if pageSize &lt; 1 || pageSize &gt; 1000 </span><span class="cov1" title="1">{
                pageSize = 1000
        }</span>

        <span class="cov10" title="4">resp, err := h.categoryService.GetAll(page, pageSize)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get categories", "details": err.Error()})
                return
        }</span>

        <span class="cov8" title="3">c.JSON(http.StatusOK, resp)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        apperrors "developer-portal-backend/internal/errors"
        "developer-portal-backend/internal/logger"
        "developer-portal-backend/internal/service"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "regexp"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// ComponentHandler handles HTTP requests for component operations
type ComponentHandler struct {
        componentService service.ComponentServiceInterface
        landscapeService service.LandscapeServiceInterface
        teamService      service.TeamServiceInterface
        projectService   service.ProjectServiceInterface
}

// NewComponentHandler creates a component handler with all services
func NewComponentHandler(componentService service.ComponentServiceInterface, landscapeService service.LandscapeServiceInterface, teamService service.TeamServiceInterface, projectService service.ProjectServiceInterface) *ComponentHandler <span class="cov10" title="21">{
        return &amp;ComponentHandler{
                componentService: componentService,
                landscapeService: landscapeService,
                teamService:      teamService,
                projectService:   projectService,
        }
}</span>

// ComponentHealth handles GET /components/health
// @Param component-id query string false "Component ID (UUID)"
// @Param landscape-id query string false "Landscape ID (UUID)"
// @Security BearerAuth
// @Router /components/health [get]
func (h *ComponentHandler) ComponentHealth(c *gin.Context) <span class="cov8" title="14">{
        componentIDStr := c.Query("component-id")
        landscapeIDStr := c.Query("landscape-id")
        if componentIDStr != "" &amp;&amp; landscapeIDStr != "" </span><span class="cov8" title="13">{
                compID, err := uuid.Parse(componentIDStr)
                if err != nil </span><span class="cov1" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{"healthy": false, "error": apperrors.ErrInvalidComponentID.Error(), "details": fmt.Sprintf("failed to parse component-id: %s", componentIDStr)})
                        return
                }</span>
                <span class="cov8" title="12">landID, err := uuid.Parse(landscapeIDStr)
                if err != nil </span><span class="cov1" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{"healthy": false, "error": apperrors.ErrInvalidLandscapeID.Error(), "details": fmt.Sprintf("failed to parse landscape-id: %s", landscapeIDStr)})
                        return
                }</span>
                // Compose health URL via helper (fully encapsulated: component/landscape/template fetch + composition)
                <span class="cov8" title="11">healthURL, healthSuccessRegEx, err := BuildComponentHealthURL(h.componentService, h.landscapeService, h.projectService, compID, landID)
                if err != nil </span><span class="cov5" title="5">{
                        c.JSON(http.StatusInternalServerError, gin.H{"healthy": false, "error": err.Error(), "details": fmt.Sprintf("failed to build component health URL. healthURL=%s successRegEx=%s", healthURL, healthSuccessRegEx)})
                        return
                }</span>

                <span class="cov6" title="6">logger.FromGinContext(c).Debugf("components health proxy URL=%s", healthURL)

                // Fetch URL with timeout
                client := &amp;http.Client{Timeout: 10 * time.Second}
                resp, err := client.Get(healthURL)
                if err != nil </span><span class="cov3" title="2">{
                        c.JSON(http.StatusInternalServerError, gin.H{"healthy": false, "error": "failed to fetch component health", "details": err.Error(), "healthURL": healthURL})
                        return
                }</span>
                <span class="cov5" title="4">defer func(Body io.ReadCloser) </span><span class="cov5" title="4">{
                        err := Body.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusInternalServerError, gin.H{"healthy": false, "error": "failed to close component health response body", "details": err.Error(), "healthURL": healthURL})
                                return
                        }</span>
                }(resp.Body)
                <span class="cov5" title="4">bodyBytes, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"healthy": false, "error": "failed to read component health response", "details": err.Error(), "healthURL": healthURL, "statusCode": resp.StatusCode})
                        return
                }</span>
                <span class="cov5" title="4">responseBody := string(bodyBytes)
                // check if responseBody matches healthSuccessRegEx
                healthy, err := regexp.MatchString(healthSuccessRegEx, responseBody)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"healthy": false, "error": err.Error(), "details": "failed to apply health success regex", "healthURL": healthURL, "statusCode": resp.StatusCode})
                        return
                }</span>
                <span class="cov5" title="4">c.JSON(http.StatusOK, gin.H{"healthy": healthy, "details": responseBody, "healthURL": healthURL, "statusCode": resp.StatusCode})
                return</span>
        }
        // Missing parameters: both component-id and landscape-id are required
        <span class="cov1" title="1">c.JSON(http.StatusBadRequest, gin.H{"healthy": false, "error": apperrors.ErrMissingHealthParams.Error()})</span>

}

// ListComponents handles GET /components
// @Summary List components
// @Description List components filtered by either team-id or project-name. Returns an array of minimal component views. One of team-id or project-name is required.
// @Tags components
// @Accept json
// @Produce json
// @Param team-id query string false "Team ID (UUID) to filter by owner_id"
// @Param project-name query string false "Project name"
// @Success 200 {array} object "Successfully retrieved components"
// @Failure 400 {object} map[string]interface{} "Invalid parameters"
// @Failure 404 {object} map[string]interface{} "Not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /components [get]
func (h *ComponentHandler) ListComponents(c *gin.Context) <span class="cov7" title="8">{
        projectName := c.Query("project-name")
        // If team-id is provided, return components owned by that team (uses pagination)
        teamIDStr := c.Query("team-id")
        if teamIDStr != "" </span><span class="cov5" title="4">{
                teamID, err := uuid.Parse(teamIDStr)
                if err != nil </span><span class="cov1" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": apperrors.ErrInvalidTeamID.Error()})
                        return
                }</span>
                <span class="cov4" title="3">components, _, err := h.teamService.GetTeamComponentsByID(teamID, 1, 1000000)
                if err != nil </span><span class="cov3" title="2">{
                        if errors.Is(err, apperrors.ErrTeamNotFound) </span><span class="cov1" title="1">{
                                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                                return
                        }</span>
                        <span class="cov1" title="1">c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return</span>
                }
                // Build minimal view items with project info (same fields as project-name view plus project_id and project_title)
                <span class="cov1" title="1">items := make([]gin.H, len(components))
                for i, comp := range components </span><span class="cov1" title="1">{
                        // Extract qos, sonar, github from metadata if present
                        var qos, sonar, github string
                        var centralService, isLibrary, health *bool

                        if len(comp.Metadata) &gt; 0 </span><span class="cov1" title="1">{
                                var meta map[string]interface{}
                                if err := json.Unmarshal(comp.Metadata, &amp;meta); err == nil </span><span class="cov1" title="1">{
                                        // qos from metadata.ci.qos
                                        if ciRaw, ok := meta["ci"]; ok </span><span class="cov1" title="1">{
                                                if ciMap, ok := ciRaw.(map[string]interface{}); ok </span><span class="cov1" title="1">{
                                                        if qosRaw, ok := ciMap["qos"]; ok </span><span class="cov1" title="1">{
                                                                if qosStr, ok := qosRaw.(string); ok </span><span class="cov1" title="1">{
                                                                        qos = qosStr
                                                                }</span>
                                                        }
                                                }
                                        }
                                        // sonar from metadata.sonar.project_id
                                        <span class="cov1" title="1">if sonarRaw, ok := meta["sonar"]; ok </span><span class="cov1" title="1">{
                                                if sonarMap, ok := sonarRaw.(map[string]interface{}); ok </span><span class="cov1" title="1">{
                                                        if pidRaw, ok := sonarMap["project_id"]; ok </span><span class="cov1" title="1">{
                                                                if pidStr, ok := pidRaw.(string); ok </span><span class="cov1" title="1">{
                                                                        sonar = "https://sonar.tools.sap/dashboard?id=" + pidStr
                                                                }</span>
                                                        }
                                                }
                                        }
                                        // GitHub from metadata.github.url
                                        <span class="cov1" title="1">if ghRaw, ok := meta["github"]; ok </span><span class="cov1" title="1">{
                                                if ghMap, ok := ghRaw.(map[string]interface{}); ok </span><span class="cov1" title="1">{
                                                        if urlRaw, ok := ghMap["url"]; ok </span><span class="cov1" title="1">{
                                                                if urlStr, ok := urlRaw.(string); ok </span><span class="cov1" title="1">{
                                                                        github = urlStr
                                                                }</span>
                                                        }
                                                }
                                        }
                                        // central-service from metadata["central-service"]
                                        <span class="cov1" title="1">if csRaw, ok := meta["central-service"]; ok </span><span class="cov1" title="1">{
                                                if csBool, ok := csRaw.(bool); ok </span><span class="cov1" title="1">{
                                                        b := csBool
                                                        centralService = &amp;b
                                                }</span>
                                        }
                                        // is-library from metadata["isLibrary"] (mapped to is-library)
                                        <span class="cov1" title="1">if ilRaw, ok := meta["isLibrary"]; ok </span><span class="cov1" title="1">{
                                                if ilBool, ok := ilRaw.(bool); ok </span><span class="cov1" title="1">{
                                                        b := ilBool
                                                        isLibrary = &amp;b
                                                }</span>
                                        }
                                        // health from metadata["health"] (boolean)
                                        <span class="cov1" title="1">if hRaw, ok := meta["health"]; ok </span><span class="cov1" title="1">{
                                                if hBool, ok := hRaw.(bool); ok </span><span class="cov1" title="1">{
                                                        b := hBool
                                                        health = &amp;b
                                                }</span>
                                        }
                                }
                        }

                        // Fetch project title (non-fatal if not found)
                        <span class="cov1" title="1">projectTitle := ""
                        if title, err := h.componentService.GetProjectTitleByID(comp.ProjectID); err == nil </span><span class="cov1" title="1">{
                                projectTitle = title
                        }</span>

                        <span class="cov1" title="1">m := gin.H{
                                "id":            comp.ID,
                                "owner_id":      comp.OwnerID,
                                "name":          comp.Name,
                                "title":         comp.Title,
                                "description":   comp.Description,
                                "qos":           qos,
                                "sonar":         sonar,
                                "github":        github,
                                "project_id":    comp.ProjectID,
                                "project_title": projectTitle,
                        }
                        if centralService != nil </span><span class="cov1" title="1">{
                                m["central-service"] = *centralService
                        }</span>
                        <span class="cov1" title="1">if isLibrary != nil </span><span class="cov1" title="1">{
                                m["is-library"] = *isLibrary
                        }</span>
                        <span class="cov1" title="1">if health != nil </span><span class="cov1" title="1">{
                                m["health"] = *health
                        }</span>
                        <span class="cov1" title="1">items[i] = m</span>
                }
                <span class="cov1" title="1">c.JSON(http.StatusOK, items)
                return</span>
        }

        // If project-name is provided, return ALL components for the project (unpaginated minimal view) and ignore organization_id requirement
        <span class="cov5" title="4">if projectName != "" </span><span class="cov4" title="3">{
                views, err := h.componentService.GetByProjectNameAllView(projectName)
                if err != nil </span><span class="cov3" title="2">{
                        if errors.Is(err, apperrors.ErrProjectNotFound) </span><span class="cov1" title="1">{
                                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                                return
                        }</span>
                        <span class="cov1" title="1">c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return</span>
                }
                <span class="cov1" title="1">c.JSON(http.StatusOK, views)
                return</span>
        }

        <span class="cov1" title="1">c.JSON(http.StatusBadRequest, gin.H{"error": apperrors.ErrMissingTeamOrProjectName.Error()})
        return</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "net/http"

        "developer-portal-backend/internal/auth"
        "developer-portal-backend/internal/errors"
        "developer-portal-backend/internal/service"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// DocumentationHandler handles HTTP requests for documentations
type DocumentationHandler struct {
        docService service.DocumentationServiceInterface
}

// NewDocumentationHandler creates a new documentation handler
func NewDocumentationHandler(docService service.DocumentationServiceInterface) *DocumentationHandler <span class="cov10" title="18">{
        return &amp;DocumentationHandler{
                docService: docService,
        }
}</span>

// CreateDocumentation handles POST /documentations
// @Summary Create a new documentation
// @Description Creates a new documentation endpoint for a team. The URL should be a valid GitHub URL.
// @Description created_by is derived from the bearer token 'username' claim.
// @Tags documentations
// @Accept json
// @Produce json
// @Param documentation body service.CreateDocumentationRequest true "Documentation data"
// @Success 201 {object} service.DocumentationResponse "Successfully created documentation"
// @Failure 400 {object} map[string]interface{} "Invalid request or validation failed"
// @Failure 401 {object} map[string]interface{} "Authentication required"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /documentations [post]
func (h *DocumentationHandler) CreateDocumentation(c *gin.Context) <span class="cov5" title="4">{
        var req service.CreateDocumentationRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Populate created_by from bearer token username
        <span class="cov4" title="3">if username, ok := auth.GetUsername(c); ok &amp;&amp; username != "" </span><span class="cov3" title="2">{
                req.CreatedBy = username
        }</span> else<span class="cov1" title="1"> {
                c.JSON(http.StatusUnauthorized, gin.H{"error": errors.ErrMissingUsernameInToken.Error()})
                return
        }</span>

        <span class="cov3" title="2">doc, err := h.docService.CreateDocumentation(&amp;req)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusCreated, doc)</span>
}

// GetDocumentationByID handles GET /documentations/:id
// @Summary Get a documentation by ID
// @Description Retrieves a documentation by its UUID
// @Tags documentations
// @Accept json
// @Produce json
// @Param id path string true "Documentation ID (UUID)"
// @Success 200 {object} service.DocumentationResponse "Successfully retrieved documentation"
// @Failure 400 {object} map[string]interface{} "Invalid documentation ID"
// @Failure 404 {object} map[string]interface{} "Documentation not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /documentations/{id} [get]
func (h *DocumentationHandler) GetDocumentationByID(c *gin.Context) <span class="cov4" title="3">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": errors.ErrInvalidDocumentationID.Error()})
                return
        }</span>

        <span class="cov3" title="2">doc, err := h.docService.GetDocumentationByID(id)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": errors.ErrDocumentationNotFound.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, doc)</span>
}

// GetDocumentationsByTeamID handles GET /teams/:id/documentations
// @Summary List documentations for a team
// @Description Returns all documentations for a specific team
// @Tags documentations
// @Accept json
// @Produce json
// @Param id path string true "Team ID (UUID)"
// @Success 200 {array} service.DocumentationResponse "Successfully retrieved documentations"
// @Failure 400 {object} map[string]interface{} "Invalid team ID"
// @Failure 404 {object} map[string]interface{} "Team not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /teams/{id}/documentations [get]
func (h *DocumentationHandler) GetDocumentationsByTeamID(c *gin.Context) <span class="cov4" title="3">{
        teamIDStr := c.Param("id")
        teamID, err := uuid.Parse(teamIDStr)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": errors.ErrInvalidTeamID.Error()})
                return
        }</span>

        <span class="cov3" title="2">docs, err := h.docService.GetDocumentationsByTeamID(teamID)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, docs)</span>
}

// UpdateDocumentation handles PATCH /documentations/:id
// @Summary Update a documentation
// @Description Updates an existing documentation. All fields are optional.
// @Description updated_by is derived from the bearer token 'username' claim.
// @Tags documentations
// @Accept json
// @Produce json
// @Param id path string true "Documentation ID (UUID)"
// @Param documentation body service.UpdateDocumentationRequest true "Documentation update data"
// @Success 200 {object} service.DocumentationResponse "Successfully updated documentation"
// @Failure 400 {object} map[string]interface{} "Invalid request or validation failed"
// @Failure 401 {object} map[string]interface{} "Authentication required"
// @Failure 404 {object} map[string]interface{} "Documentation not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /documentations/{id} [patch]
func (h *DocumentationHandler) UpdateDocumentation(c *gin.Context) <span class="cov6" title="5">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": errors.ErrInvalidDocumentationID.Error()})
                return
        }</span>

        <span class="cov5" title="4">var req service.UpdateDocumentationRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Populate updated_by from bearer token username
        <span class="cov4" title="3">if username, ok := auth.GetUsername(c); ok &amp;&amp; username != "" </span><span class="cov3" title="2">{
                req.UpdatedBy = username
        }</span> else<span class="cov1" title="1"> {
                c.JSON(http.StatusUnauthorized, gin.H{"error": errors.ErrMissingUsernameInToken.Error()})
                return
        }</span>

        <span class="cov3" title="2">doc, err := h.docService.UpdateDocumentation(id, &amp;req)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, doc)</span>
}

// DeleteDocumentation handles DELETE /documentations/:id
// @Summary Delete a documentation by ID
// @Description Deletes a documentation from the documentations table by the given UUID
// @Tags documentations
// @Accept json
// @Produce json
// @Param id path string true "Documentation ID (UUID)"
// @Success 204 "Successfully deleted documentation"
// @Failure 400 {object} map[string]interface{} "Invalid documentation ID"
// @Failure 404 {object} map[string]interface{} "Documentation not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /documentations/{id} [delete]
func (h *DocumentationHandler) DeleteDocumentation(c *gin.Context) <span class="cov4" title="3">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": errors.ErrInvalidDocumentationID.Error()})
                return
        }</span>

        <span class="cov3" title="2">if err := h.docService.DeleteDocumentation(id); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": errors.ErrFailedToDeleteDocumentation.Error(), "details": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusNoContent, nil)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "errors"
        "net/http"
        "strconv"

        "developer-portal-backend/internal/auth"
        apperrors "developer-portal-backend/internal/errors"
        "developer-portal-backend/internal/service"

        "github.com/gin-gonic/gin"
)

// GitHubHandler handles GitHub-related HTTP requests
type GitHubHandler struct {
        service service.GitHubServiceInterface
}

// NewGitHubHandler creates a new GitHub handler
func NewGitHubHandler(s service.GitHubServiceInterface) *GitHubHandler <span class="cov9" title="72">{
        return &amp;GitHubHandler{service: s}
}</span>

// getAuthClaims extracts and validates auth claims from the Gin context
// Returns the claims if successful, or sends an error response and returns nil
func getAuthClaims(c *gin.Context) *auth.AuthClaims <span class="cov10" title="87">{
        claimsInterface, exists := c.Get("auth_claims")
        if !exists </span><span class="cov4" title="7">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": apperrors.ErrAuthenticationRequired})
                return nil
        }</span>

        <span class="cov9" title="80">claims, ok := claimsInterface.(*auth.AuthClaims)
        if !ok </span><span class="cov4" title="5">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": apperrors.ErrAuthenticationInvalidClaims})
                return nil
        }</span>

        <span class="cov9" title="75">return claims</span>
}

// GetMyPullRequests returns all pull requests created by the authenticated user
// @Summary Get my pull requests
// @Description Returns all pull requests created by the authenticated user across all repositories they have access to
// @Tags github
// @Produce json
// @Param state query string false "Filter by state: open, closed, all" default(open)
// @Param sort query string false "Sort by: created, updated, popularity, long-running" default(created)
// @Param direction query string false "Sort direction: asc, desc" default(desc)
// @Param per_page query int false "Results per page (1-100)" default(30)
// @Param page query int false "Page number" default(1)
// @Success 200 {object} service.PullRequestsResponse
// @Failure 401 {object} ErrorResponse "Unauthorized"
// @Failure 502 {object} ErrorResponse "GitHub API error"
// @Security BearerAuth
// @Router /github/pull-requests [get]
func (h *GitHubHandler) GetMyPullRequests(c *gin.Context) <span class="cov7" title="31">{
        claims := getAuthClaims(c)
        if claims == nil </span><span class="cov2" title="2">{
                return
        }</span>

        // Get query parameters
        <span class="cov7" title="29">state := c.DefaultQuery("state", "open")
        sort := c.DefaultQuery("sort", "created")
        direction := c.DefaultQuery("direction", "desc")

        perPageStr := c.DefaultQuery("per_page", "30")
        perPage, err := strconv.Atoi(perPageStr)
        if err != nil || perPage &lt;= 0 || perPage &gt; 100 </span><span class="cov4" title="5">{
                perPage = 30
        }</span>

        <span class="cov7" title="29">pageStr := c.DefaultQuery("page", "1")
        page, err := strconv.Atoi(pageStr)
        if err != nil || page &lt;= 0 </span><span class="cov3" title="4">{
                page = 1
        }</span>

        // Validate state parameter
        <span class="cov7" title="29">if state != "open" &amp;&amp; state != "closed" &amp;&amp; state != "all" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid state parameter. Must be: open, closed, or all"})
                return
        }</span>

        // Validate sort parameter
        <span class="cov7" title="28">validSorts := map[string]bool{
                "created":      true,
                "updated":      true,
                "popularity":   true,
                "long-running": true,
        }
        if !validSorts[sort] </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid sort parameter. Must be: created, updated, popularity, or long-running"})
                return
        }</span>

        // Validate direction parameter
        <span class="cov7" title="27">if direction != "asc" &amp;&amp; direction != "desc" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid direction parameter. Must be: asc or desc"})
                return
        }</span>

        // get GitHub provider from param 'provider'. TODO set 'githubtools' if not found. prepare to support multiple providers in future - which client currently doesn't support. should be mandatory.
        <span class="cov7" title="26">provider := c.DefaultQuery("provider", "githubtools")

        // Call service to get pull requests
        response, err := h.service.GetUserOpenPullRequests(c.Request.Context(), claims.UUID, provider, state, sort, direction, perPage, page)
        if err != nil </span><span class="cov2" title="2">{
                // Check for specific error types
                if errors.Is(err, apperrors.ErrGitHubAPIRateLimitExceeded) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusTooManyRequests, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusBadGateway, gin.H{"error": "Failed to fetch pull requests: " + err.Error()})
                return</span>
        }

        <span class="cov7" title="24">c.JSON(http.StatusOK, response)</span>
}

// GetUserTotalContributions returns the total contributions count for the authenticated user
// @Summary Get user total contributions
// @Description Returns the total number of contributions made by the authenticated user. If no period specified, uses GitHub's default (last year based on user's timezone). Uses GitHub GraphQL API to fetch contribution data.
// @Tags github
// @Produce json
// @Param period query string false "Time period in days (e.g., '30d', '90d', '365d'). If omitted, uses GitHub's default period. Maximum: 365 days"
// @Success 200 {object} service.TotalContributionsResponse
// @Failure 400 {object} ErrorResponse "Invalid period parameter"
// @Failure 401 {object} ErrorResponse "Unauthorized"
// @Failure 429 {object} ErrorResponse "Rate limit exceeded"
// @Failure 502 {object} ErrorResponse "GitHub API error"
// @Security BearerAuth
// @Router /github/contributions [get]
func (h *GitHubHandler) GetUserTotalContributions(c *gin.Context) <span class="cov6" title="17">{
        claims := getAuthClaims(c)
        if claims == nil </span><span class="cov2" title="2">{
                return
        }</span>

        // Get query parameter for period (empty = use GitHub's default)
        <span class="cov6" title="15">period := c.Query("period")

        // get GitHub provider from param 'provider'. TODO set 'githubtools' if not found. prepare to support multiple providers in future - which client currently doesn't support. should be mandatory.
        provider := c.DefaultQuery("provider", "githubtools")

        // Call service to get total contributions
        response, err := h.service.GetUserTotalContributions(c.Request.Context(), claims.UUID, provider, period)
        if err != nil </span><span class="cov4" title="7">{
                // Check for specific error types
                if errors.Is(err, apperrors.ErrGitHubAPIRateLimitExceeded) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusTooManyRequests, gin.H{"error": err.Error()})
                        return
                }</span>
                // Check if it's a validation error (invalid period format)
                <span class="cov4" title="6">if errors.Is(err, apperrors.ErrInvalidPeriodFormat) </span><span class="cov4" title="5">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusBadGateway, gin.H{"error": "Failed to fetch contributions: " + err.Error()})
                return</span>
        }

        <span class="cov5" title="8">c.JSON(http.StatusOK, response)</span>
}

// GetContributionsHeatmap returns the contribution heatmap for the authenticated user
// @Summary Get user contribution heatmap
// @Description Returns the contribution heatmap (contribution calendar) for the authenticated user. The heatmap shows daily contributions organized by weeks, similar to GitHub's contribution graph. If no period is specified, uses GitHub's default (last year). The provider parameter must match both the authenticated user's provider and be a valid provider configured in auth.yaml.
// @Tags github
// @Produce json
// @Param provider path string true "GitHub provider (must be configured in auth.yaml, e.g., 'githubtools', 'githubwdf')"
// @Param period query string false "Time period in days (e.g., '30d', '90d', '365d'). If omitted, uses GitHub's default period. Maximum: 365 days"
// @Success 200 {object} service.ContributionsHeatmapResponse
// @Failure 400 {object} ErrorResponse "Invalid period parameter or provider not configured"
// @Failure 401 {object} ErrorResponse "Unauthorized"
// @Failure 429 {object} ErrorResponse "Rate limit exceeded"
// @Failure 502 {object} ErrorResponse "GitHub API error"
// @Security BearerAuth
// @Router /github/{provider}/heatmap [get]
func (h *GitHubHandler) GetContributionsHeatmap(c *gin.Context) <span class="cov5" title="8">{
        claims := getAuthClaims(c)
        if claims == nil </span><span class="cov1" title="1">{
                return
        }</span>

        // get GitHub provider from param 'provider'. TODO set 'githubtools' if not found. prepare to support multiple providers in future - which client currently doesn't support. should be mandatory.
        <span class="cov4" title="7">provider := c.DefaultQuery("provider", "githubtools")

        // Get query parameter for period (empty = use GitHub's default)
        period := c.Query("period")

        // Call service to get contribution heatmap
        response, err := h.service.GetContributionsHeatmap(c.Request.Context(), claims.UUID, provider, period)
        if err != nil </span><span class="cov3" title="4">{
                // Check for specific error types
                if errors.Is(err, apperrors.ErrGitHubAPIRateLimitExceeded) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusTooManyRequests, gin.H{"error": err.Error()})
                        return
                }</span>
                // Check if it's a provider configuration error
                <span class="cov3" title="3">if errors.Is(err, apperrors.ErrProviderNotConfigured) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>
                // Check if it's a validation error (invalid period format)
                <span class="cov2" title="2">if errors.Is(err, apperrors.ErrInvalidPeriodFormat) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusBadGateway, gin.H{"error": "Failed to fetch contribution heatmap: " + err.Error()})
                return</span>
        }

        <span class="cov3" title="3">c.JSON(http.StatusOK, response)</span>
}

// GetAveragePRMergeTime returns the average time to merge PRs for the authenticated user
// @Summary Get average PR merge time
// @Description Returns the average time to merge pull requests for the authenticated user over a specified period (default 30 days). The response includes both aggregate metrics (overall average and PR count) and a time series breakdown by date for visualization. The time is calculated as the duration between PR creation and merge (mergedAt - createdAt) in hours.
// @Tags github
// @Produce json
// @Param period query string false "Time period in days (e.g., '30d', '90d', '180d'). Default: '30d'"
// @Success 200 {object} service.AveragePRMergeTimeResponse
// @Failure 400 {object} ErrorResponse "Invalid period parameter"
// @Failure 401 {object} ErrorResponse "Unauthorized"
// @Failure 429 {object} ErrorResponse "Rate limit exceeded"
// @Failure 502 {object} ErrorResponse "GitHub API error"
// @Security BearerAuth
// @Router /github/average-pr-time [get]
func (h *GitHubHandler) GetAveragePRMergeTime(c *gin.Context) <span class="cov4" title="5">{
        claims := getAuthClaims(c)
        if claims == nil </span><span class="cov1" title="1">{
                return
        }</span>

        // Get query parameter for period (default to 30d)
        <span class="cov3" title="4">period := c.DefaultQuery("period", "30d")

        // get GitHub provider from param 'provider'. TODO set 'githubtools' if not found. prepare to support multiple providers in future - which client currently doesn't support. should be mandatory.
        provider := c.DefaultQuery("provider", "githubtools")

        // Call service to get average PR merge time
        response, err := h.service.GetAveragePRMergeTime(c.Request.Context(), claims.UUID, provider, period)
        if err != nil </span><span class="cov3" title="3">{
                // Check for specific error types
                if errors.Is(err, apperrors.ErrGitHubAPIRateLimitExceeded) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusTooManyRequests, gin.H{"error": err.Error()})
                        return
                }</span>
                // Check if it's a validation error (invalid period format)
                <span class="cov2" title="2">if errors.Is(err, apperrors.ErrInvalidPeriodFormat) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusBadGateway, gin.H{"error": "Failed to fetch average PR merge time: " + err.Error()})
                return</span>
        }

        <span class="cov1" title="1">c.JSON(http.StatusOK, response)</span>
}

// GetRepositoryContent proxies GitHub repository content requests
// @Summary Get repository file or directory content
// @Description Proxies requests to GitHub API to fetch repository file or directory contents. Used by the documentation viewer.
// @Tags github
// @Produce json
// @Param owner path string true "Repository owner (organization or user)"
// @Param repo path string true "Repository name"
// @Param path path string false "Path to file or directory (can be empty for root)"
// @Param ref query string false "Git reference (branch, tag, or commit SHA)" default(main)
// @Success 200 {object} interface{} "GitHub API response (array for directories, object for files)"
// @Failure 401 {object} ErrorResponse "Unauthorized"
// @Failure 404 {object} ErrorResponse "Repository or path not found"
// @Failure 502 {object} ErrorResponse "GitHub API error"
// @Security BearerAuth
// @Router /github/repos/{owner}/{repo}/contents/{path} [get]
func (h *GitHubHandler) GetRepositoryContent(c *gin.Context) <span class="cov5" title="8">{
        claims := getAuthClaims(c)
        if claims == nil </span><span class="cov2" title="2">{
                return
        }</span>

        // Get path parameters
        <span class="cov4" title="6">owner := c.Param("owner")
        repo := c.Param("repo")
        path := c.Param("path")
        ref := c.DefaultQuery("ref", "main")
        // get GitHub provider from param 'provider'. TODO set 'githubtools' if not found. prepare to support multiple providers in future - which client currently doesn't support. should be mandatory.
        provider := c.DefaultQuery("provider", "githubtools")

        // Call service to get repository content
        content, err := h.service.GetRepositoryContent(c.Request.Context(), claims.UUID, provider, owner, repo, path, ref)
        if err != nil </span><span class="cov3" title="3">{
                // Check for specific error types
                if errors.Is(err, apperrors.ErrGitHubAPIRateLimitExceeded) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusTooManyRequests, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov2" title="2">if apperrors.IsNotFound(err) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusBadGateway, gin.H{"error": "Failed to fetch repository content: " + err.Error()})
                return</span>
        }

        <span class="cov3" title="3">c.JSON(http.StatusOK, content)</span>
}

// GetGitHubAsset proxies GitHub asset requests (images, etc.)
// @Summary Get GitHub asset (image, file, etc.)
// @Description Proxies requests to GitHub assets with authentication. Used by the documentation viewer for images.
// @Tags github
// @Produce octet-stream
// @Param url query string true "Full URL to the GitHub asset"
// @Success 200 {file} binary "Asset binary data"
// @Failure 401 {object} ErrorResponse "Unauthorized"
// @Failure 404 {object} ErrorResponse "Asset not found"
// @Failure 502 {object} ErrorResponse "GitHub API error"
// @Security BearerAuth
// @Router /github/asset [get]
func (h *GitHubHandler) GetGitHubAsset(c *gin.Context) <span class="cov5" title="9">{
        claims := getAuthClaims(c)
        if claims == nil </span><span class="cov2" title="2">{
                return
        }</span>

        // Get asset URL from query parameter
        <span class="cov4" title="7">assetURL := c.Query("url")
        if assetURL == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Asset URL is required"})
                return
        }</span>
        // get GitHub provider from param 'provider'. TODO set 'githubtools' if not found. prepare to support multiple providers in future - which client currently doesn't support. should be mandatory.
        <span class="cov4" title="6">provider := c.DefaultQuery("provider", "githubtools")

        // Call service to fetch the asset
        assetData, contentType, err := h.service.GetGitHubAsset(c.Request.Context(), claims.UUID, provider, assetURL)
        if err != nil </span><span class="cov3" title="3">{
                // Check for specific error types
                if errors.Is(err, apperrors.ErrGitHubAPIRateLimitExceeded) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusTooManyRequests, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov2" title="2">if apperrors.IsNotFound(err) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusBadGateway, gin.H{"error": "Failed to fetch GitHub asset: " + err.Error()})
                return</span>
        }

        // Set content type and return binary data
        <span class="cov3" title="3">c.Header("Content-Type", contentType)
        c.Header("Cache-Control", "public, max-age=3600") // Cache for 1 hour
        c.Data(http.StatusOK, contentType, assetData)</span>
}

// UpdateRepositoryFileRequest represents the request body for updating a file
type UpdateRepositoryFileRequest struct {
        Message string `json:"message" binding:"required"`
        Content string `json:"content" binding:"required"`
        SHA     string `json:"sha" binding:"required"`
        Branch  string `json:"branch"`
}

// UpdateRepositoryFile updates a file in a GitHub repository
// @Summary Update repository file
// @Description Updates a file in a GitHub repository on behalf of the authenticated user
// @Tags github
// @Accept json
// @Produce json
// @Param owner path string true "Repository owner (organization or user)"
// @Param repo path string true "Repository name"
// @Param path path string true "Path to file"
// @Param body body UpdateRepositoryFileRequest true "Update file request"
// @Success 200 {object} interface{} "GitHub API response with commit details"
// @Failure 400 {object} ErrorResponse "Invalid request"
// @Failure 401 {object} ErrorResponse "Unauthorized"
// @Failure 404 {object} ErrorResponse "Repository or path not found"
// @Failure 502 {object} ErrorResponse "GitHub API error"
// @Security BearerAuth
// @Router /github/repos/{owner}/{repo}/contents/{path} [put]
func (h *GitHubHandler) UpdateRepositoryFile(c *gin.Context) <span class="cov5" title="11">{
        // Get authenticated user claims from context (set by auth middleware)
        claimsInterface, exists := c.Get("auth_claims")
        if !exists </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                return
        }</span>

        <span class="cov5" title="10">claims, ok := claimsInterface.(*auth.AuthClaims)
        if !ok </span><span class="cov1" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid authentication claims"})
                return
        }</span>

        // Get path parameters
        <span class="cov5" title="9">owner := c.Param("owner")
        repo := c.Param("repo")
        path := c.Param("path")

        // Bind request body
        var req UpdateRepositoryFileRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov3" title="4">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request: " + err.Error()})
                return
        }</span>
        // get GitHub provider from param 'provider'. TODO set 'githubtools' if not found. prepare to support multiple providers in future - which client currently doesn't support. should be mandatory.
        <span class="cov4" title="5">provider := c.DefaultQuery("provider", "githubtools")

        // Call service to update repository file
        response, err := h.service.UpdateRepositoryFile(c.Request.Context(), claims.UUID, provider, owner, repo, path, req.Message, req.Content, req.SHA, req.Branch)
        if err != nil </span><span class="cov3" title="3">{
                // Check for specific error types
                if errors.Is(err, apperrors.ErrGitHubAPIRateLimitExceeded) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusTooManyRequests, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov2" title="2">if apperrors.IsNotFound(err) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusBadGateway, gin.H{"error": "Failed to update repository file: " + err.Error()})
                return</span>
        }

        <span class="cov2" title="2">c.JSON(http.StatusOK, response)</span>
}

// ClosePullRequestRequest represents the request body for closing a PR
type ClosePullRequestRequest struct {
        Owner        string `json:"owner" binding:"required"`
        Repo         string `json:"repo" binding:"required"`
        DeleteBranch bool   `json:"delete_branch"`
}

// ClosePullRequest closes a pull request
// @Summary Close pull request
// @Description Closes an open PR for the authenticated user. Optionally deletes the PR branch when delete_branch is 'true'.
// @Tags github
// @Accept json
// @Produce json
// @Param pr_number path int true "Pull request number"
// @Param body body ClosePullRequestRequest true "Request body: owner, repo, delete_branch ('true' to delete the PR branch)"
// @Success 200 {object} service.PullRequest
// @Failure 400 {object} ErrorResponse "Invalid request"
// @Failure 401 {object} ErrorResponse "Unauthorized"
// @Failure 404 {object} ErrorResponse "Pull request not found"
// @Failure 429 {object} ErrorResponse "Rate limit exceeded"
// @Failure 502 {object} ErrorResponse "GitHub API error"
// @Security BearerAuth
// @Router /github/pull-requests/close/{pr_number} [patch]
func (h *GitHubHandler) ClosePullRequest(c *gin.Context) <span class="cov2" title="2">{
        claims := getAuthClaims(c)
        if claims == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Parse PR number from path
        <span class="cov2" title="2">prNumberStr := c.Param("pr_number")
        prNumber, err := strconv.Atoi(prNumberStr)
        if err != nil || prNumber &lt;= 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid pr_number parameter"})
                return
        }</span>

        // Bind request body
        <span class="cov2" title="2">var req ClosePullRequestRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request: " + err.Error()})
                return
        }</span>

        // Validate owner/repo
        <span class="cov2" title="2">if req.Owner == "" || req.Repo == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "owner and repo are required"})
                return
        }</span>

        // Parse delete_branch flag
        <span class="cov2" title="2">deleteBranch := req.DeleteBranch

        // get GitHub provider from param 'provider'. TODO set 'githubtools' if not found. prepare to support multiple providers in future - which client currently doesn't support. should be mandatory.
        provider := c.DefaultQuery("provider", "githubtools")

        // Close PR (and optionally delete branch)
        updatedPR, err := h.service.ClosePullRequest(c.Request.Context(), claims.UUID, provider, req.Owner, req.Repo, prNumber, deleteBranch)
        if err != nil </span><span class="cov1" title="1">{
                // Check for specific error types
                if errors.Is(err, apperrors.ErrInvalidStatus) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov1" title="1">if errors.Is(err, apperrors.ErrGitHubAPIRateLimitExceeded) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusTooManyRequests, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov1" title="1">if apperrors.IsNotFound(err) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusBadGateway, gin.H{"error": "Failed to close pull request: " + err.Error()})
                return</span>
        }

        <span class="cov1" title="1">c.JSON(http.StatusOK, updatedPR)</span>
}

// GetPRReviewComments returns the total number of PR review comments by the authenticated user
// @Summary Get PR review comments count
// @Description Returns the total number of pull request reviews performed by the authenticated user over a specified period (default 30 days)
// @Tags github
// @Produce json
// @Param period query string false "Time period in days (e.g., '30d', '90d', '180d'). Default: '30d'"
// @Success 200 {object} service.PRReviewCommentsResponse
// @Failure 400 {object} ErrorResponse "Invalid period parameter"
// @Failure 401 {object} ErrorResponse "Unauthorized"
// @Failure 429 {object} ErrorResponse "Rate limit exceeded"
// @Failure 502 {object} ErrorResponse "GitHub API error"
// @Security BearerAuth
// @Router /github/pr-review-comments [get]
func (h *GitHubHandler) GetPRReviewComments(c *gin.Context) <span class="cov4" title="7">{
        claims := getAuthClaims(c)
        if claims == nil </span><span class="cov2" title="2">{
                return
        }</span>

        // Get query parameter for period (default to 30d)
        <span class="cov4" title="5">period := c.DefaultQuery("period", "30d")
        // get GitHub provider from param 'provider'. TODO set 'githubtools' if not found. prepare to support multiple providers in future - which client currently doesn't support. should be mandatory.
        provider := c.DefaultQuery("provider", "githubtools")

        // Call service to get PR review comments count
        response, err := h.service.GetUserPRReviewComments(c.Request.Context(), claims.UUID, provider, period)
        if err != nil </span><span class="cov3" title="3">{
                // Check for specific error types
                if errors.Is(err, apperrors.ErrGitHubAPIRateLimitExceeded) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusTooManyRequests, gin.H{"error": err.Error()})
                        return
                }</span>
                // Check if it's a validation error (invalid period format)
                <span class="cov2" title="2">if errors.Is(err, apperrors.ErrInvalidPeriodFormat) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusBadGateway, gin.H{"error": "Failed to fetch PR review comments: " + err.Error()})
                return</span>
        }

        <span class="cov2" title="2">c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "developer-portal-backend/internal/errors"
        "encoding/json"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

// HealthHandler handles health check endpoints
type HealthHandler struct {
        db *gorm.DB
}

// NewHealthHandler creates a new health handler
func NewHealthHandler(db *gorm.DB) *HealthHandler <span class="cov10" title="20">{
        return &amp;HealthHandler{
                db: db,
        }
}</span>

// HealthResponse represents the health check response
type HealthResponse struct {
        Status    string            `json:"status"`
        Timestamp time.Time         `json:"timestamp"`
        Version   string            `json:"version"`
        Services  map[string]string `json:"services"`
}

// ErrorResponse represents a standard API error response
type ErrorResponse struct {
        Error string `json:"error" example:"error message"`
}

// Health returns the health status of the application
// @Summary Health check
// @Description Get the overall health status of the application including database connectivity
// @Tags health
// @Accept json
// @Produce json
// @Success 200 {object} HealthResponse "Application is healthy"
// @Failure 503 {object} HealthResponse "Application is unhealthy"
// @Router /health [get]
func (h *HealthHandler) Health(c *gin.Context) <span class="cov4" title="3">{
        response := HealthResponse{
                Status:    "healthy",
                Timestamp: time.Now(),
                Version:   "1.0.0",
                Services:  make(map[string]string),
        }

        // Check database connection
        sqlDB, err := h.db.DB()
        if err != nil </span><span class="cov0" title="0">{
                response.Status = "unhealthy"
                response.Services["database"] = "error: " + err.Error()
        }</span> else<span class="cov4" title="3"> {
                if err := sqlDB.Ping(); err != nil </span><span class="cov3" title="2">{
                        response.Status = "unhealthy"
                        response.Services["database"] = "error: " + err.Error()
                }</span> else<span class="cov1" title="1"> {
                        response.Services["database"] = "healthy"
                }</span>
        }

        <span class="cov4" title="3">statusCode := http.StatusOK
        if response.Status == "unhealthy" </span><span class="cov3" title="2">{
                statusCode = http.StatusServiceUnavailable
        }</span>

        <span class="cov4" title="3">c.JSON(statusCode, response)</span>
}

// Ready returns the readiness status of the application
// @Summary Readiness check
// @Description Check if the application is ready to serve requests
// @Tags health
// @Accept json
// @Produce json
// @Success 200 {object} map[string]interface{} "Application is ready"
// @Failure 503 {object} map[string]interface{} "Application is not ready"
// @Router /health/ready [get]
func (h *HealthHandler) Ready(c *gin.Context) <span class="cov4" title="3">{
        // Check if the application is ready to serve requests
        // This could include checking if migrations are complete, external services are available, etc.

        ready := true
        services := make(map[string]string)

        // Check database connection
        sqlDB, err := h.db.DB()
        if err != nil </span><span class="cov0" title="0">{
                ready = false
                services["database"] = "not ready: " + err.Error()
        }</span> else<span class="cov4" title="3"> {
                if err := sqlDB.Ping(); err != nil </span><span class="cov3" title="2">{
                        ready = false
                        services["database"] = "not ready: " + err.Error()
                }</span> else<span class="cov1" title="1"> {
                        services["database"] = "ready"
                }</span>
        }

        <span class="cov4" title="3">response := map[string]interface{}{
                "ready":     ready,
                "timestamp": time.Now(),
                "services":  services,
        }

        statusCode := http.StatusOK
        if !ready </span><span class="cov3" title="2">{
                statusCode = http.StatusServiceUnavailable
        }</span>

        <span class="cov4" title="3">c.JSON(statusCode, response)</span>
}

// Live returns the liveness status of the application
// @Summary Liveness check
// @Description Check if the application is alive and responding
// @Tags health
// @Accept json
// @Produce json
// @Success 200 {object} map[string]interface{} "Application is alive"
// @Router /health/live [get]
func (h *HealthHandler) Live(c *gin.Context) <span class="cov5" title="4">{
        // Simple liveness check - if we can respond, we're alive
        c.JSON(http.StatusOK, map[string]interface{}{
                "alive":     true,
                "timestamp": time.Now(),
        })
}</span>

// ProxyComponentHealth proxies requests to component public endpoints (health, version, etc.)
// This solves CORS issues when frontend tries to call component endpoints directly
// @Summary Proxy component public endpoints
// @Description Fetch data from component public endpoints (health, version, system info) server-side to avoid CORS
// @Tags cis-public
// @Accept json
// @Produce json
// @Param url query string true "Component public endpoint URL to fetch"
// @Success 200 {object} map[string]interface{} "Response from component endpoint"
// @Failure 400 {object} ErrorResponse "URL parameter is required"
// @Failure 502 {object} ErrorResponse "Failed to fetch from component"
// @Security BearerAuth
// @Router /cis-public/proxy [get]
func (h *HealthHandler) ProxyComponentHealth(c *gin.Context) <span class="cov8" title="11">{
        targetURL := c.Query("url")
        if targetURL == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, ErrorResponse{errors.NewMissingQueryParam("url").Error()})
                return
        }</span>

        // Create HTTP client with timeout
        <span class="cov7" title="10">client := &amp;http.Client{
                Timeout: 10 * time.Second,
        }

        // Make request to component health endpoint
        startTime := time.Now()
        resp, err := client.Get(targetURL)
        responseTime := time.Since(startTime).Milliseconds()

        if err != nil </span><span class="cov3" title="2">{
                c.JSON(http.StatusBadGateway, map[string]interface{}{
                        "error":        "Failed to fetch from component endpoint: " + err.Error(),
                        "responseTime": responseTime,
                })
                return
        }</span>
        <span class="cov7" title="8">defer resp.Body.Close()

        // Read response body
        var result map[string]interface{}
        if err := c.ShouldBindJSON(&amp;result); err != nil </span><span class="cov7" title="8">{
                // Read body manually if JSON parsing from request fails
                decoder := resp.Body
                var healthResult map[string]interface{}
                if err := json.NewDecoder(decoder).Decode(&amp;healthResult); err != nil </span><span class="cov1" title="1">{
                        // If JSON parsing fails, return error response with 502 to frontend
                        c.JSON(http.StatusBadGateway, map[string]interface{}{
                                "error":            errors.ErrInvalidJSONResponse,
                                "statusCode":       resp.StatusCode,
                                "responseTime":     responseTime,
                                "componentSuccess": false,
                        })
                        return
                }</span>
                <span class="cov6" title="7">result = healthResult</span>
        }

        // Add metadata to result
        <span class="cov6" title="7">result["responseTime"] = responseTime
        result["statusCode"] = resp.StatusCode
        result["componentSuccess"] = resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 300

        // Always return 200 to frontend so apiClient doesn't throw
        // Frontend should check componentSuccess field
        c.JSON(http.StatusOK, result)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        apperrors "developer-portal-backend/internal/errors"
        "developer-portal-backend/internal/service"
        "encoding/json"
        "errors"
        "strings"

        "github.com/google/uuid"
)

// ErrComponentHealthDisabled indicates the component's health flag is explicitly disabled in metadata.
var ErrComponentHealthDisabled = errors.New("component 'health' flag is not set to 'true'")
var ErrComponentHealthBadConfig = errors.New("project's health URL pattern or success regex is not set")

// BuildComponentHealthURL computes the final health URL for a component given the optional project-level
// URL template and the component/landscape context. It supports the following placeholders:
//   - {landscape_domain}  -&gt; landscape.Domain
//   - {health_suffix}     -&gt; metadata["health_suffix"] (string; empty if missing)
//   - {subdomain}         -&gt; metadata["subdomain"] (string; omitted when empty)
//   - {component_name}    -&gt; component.Name
//
// If a template is provided by projectService, it will be used. Otherwise, a legacy fallback URL is constructed:
//   - With subdomain: https://{subdomain}.{component_name}.cfapps.{landscape_domain}/health
//   - Without subdomain: https://{component_name}.cfapps.{landscape_domain}/health
//
// If the component's metadata has "health": false, ErrComponentHealthDisabled is returned.
func BuildComponentHealthURL(
        componentService service.ComponentServiceInterface,
        landscapeService service.LandscapeServiceInterface,
        projectService service.ProjectServiceInterface,
        componentID uuid.UUID,
        landscapeID uuid.UUID,
) (string, string, error) <span class="cov10" title="21">{
        // Resolve component and landscape
        // First fetch component (matches previous handler behavior)
        component, err := componentService.GetByID(componentID)
        if err != nil </span><span class="cov4" title="3">{
                return "", "", err
        }</span>
        <span class="cov9" title="18">if landscapeService == nil </span><span class="cov3" title="2">{
                return "", "", apperrors.ErrLandscapeNotConfigured
        }</span>
        <span class="cov9" title="16">landscape, err := landscapeService.GetLandscapeByID(landscapeID)
        if err != nil </span><span class="cov4" title="3">{
                return "", "", err
        }</span>

        <span class="cov8" title="13">subdomain := ""    // default for {subdomain} is empty (omit segment when absent)
        healthSuffix := "" // used for {health_suffix}
        if len(component.Metadata) &gt; 0 </span><span class="cov8" title="12">{
                var meta map[string]interface{}
                if err := json.Unmarshal(component.Metadata, &amp;meta); err == nil </span><span class="cov8" title="12">{
                        // get 'health' flag from metadata to check if health is enabled:
                        if healthRaw, ok := meta["health"]; ok </span><span class="cov8" title="11">{
                                if healthBool, ok := healthRaw.(bool); ok &amp;&amp; !healthBool </span><span class="cov1" title="1">{
                                        return "", "", ErrComponentHealthDisabled
                                }</span>
                        }
                }

                // subdomain from metadata (if exists)
                <span class="cov8" title="11">if sdRaw, ok := meta["subdomain"]; ok </span><span class="cov5" title="5">{
                        if sdStr, ok := sdRaw.(string); ok &amp;&amp; sdStr != "" </span><span class="cov5" title="5">{
                                subdomain = sdStr
                        }</span>
                }
                // health suffix from metadata (if exists)
                <span class="cov8" title="11">if hsRaw, ok := meta["health_suffix"]; ok </span><span class="cov5" title="4">{
                        if hsStr, ok := hsRaw.(string); ok </span><span class="cov5" title="4">{
                                healthSuffix = hsStr
                        }</span>
                }

        }
        // Get project health URL template (and success regex, ignored for now)
        <span class="cov8" title="12">healthURLTemplate, healthSuccessRegEx := "", ""
        if projectService != nil &amp;&amp; component.ProjectID != uuid.Nil </span><span class="cov7" title="10">{
                var err error
                healthURLTemplate, healthSuccessRegEx, err = projectService.GetHealthMetadata(component.ProjectID)
                if err != nil </span><span class="cov0" title="0">{
                        return "", "", err
                }</span>
        }

        <span class="cov8" title="12">if strings.TrimSpace(healthURLTemplate) == "" || strings.TrimSpace(healthSuccessRegEx) == "" </span><span class="cov3" title="2">{
                return "", "", ErrComponentHealthBadConfig
        }</span>

        // Replace placeholders in provided template with optional {subdomain} handling
        <span class="cov7" title="10">t := healthURLTemplate
        t = strings.ReplaceAll(t, "{landscape_domain}", landscape.Domain)
        t = strings.ReplaceAll(t, "{health_suffix}", healthSuffix)

        if strings.TrimSpace(subdomain) == "" </span><span class="cov6" title="6">{
                // Remove optional subdomain segment including adjacent dots if subdomain is not provided
                t = strings.ReplaceAll(t, "{subdomain}.", "")
                t = strings.ReplaceAll(t, ".{subdomain}", "")
                t = strings.ReplaceAll(t, "{subdomain}", "")
        }</span> else<span class="cov5" title="4"> {
                t = strings.ReplaceAll(t, "{subdomain}", subdomain)
        }</span>

        <span class="cov7" title="10">t = strings.ReplaceAll(t, "{component_name}", component.Name)
        return t, healthSuccessRegEx, nil</span>

}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "context"
        "fmt"
        "net/http"
        "strings"

        "developer-portal-backend/internal/auth"
        "developer-portal-backend/internal/service"

        "github.com/gin-gonic/gin"
)

// JenkinsHandler handles Jenkins-related HTTP requests
type JenkinsHandler struct {
        service service.JenkinsServiceInterface
}

// NewJenkinsHandler creates a new Jenkins handler
func NewJenkinsHandler(s service.JenkinsServiceInterface) *JenkinsHandler <span class="cov10" title="35">{
        return &amp;JenkinsHandler{service: s}
}</span>

// JenkinsParametersResponse represents the response structure for job parameters
type JenkinsParametersResponse struct {
        ParameterDefinitions []JenkinsParameterDefinition `json:"parameterDefinitions"`
}

// JenkinsParameterDefinition represents a single parameter definition
type JenkinsParameterDefinition struct {
        Class                 string                        `json:"_class" example:"hudson.model.StringParameterDefinition"`
        DefaultParameterValue *JenkinsDefaultParameterValue `json:"defaultParameterValue,omitempty"`
        Description           string                        `json:"description" example:"Branch to deploy"`
        Name                  string                        `json:"name" example:"BRANCH"`
        Type                  string                        `json:"type" example:"StringParameterDefinition"`
        Choices               []string                      `json:"choices,omitempty" example:"dev,staging,production"`
}

// JenkinsDefaultParameterValue represents a default parameter value
type JenkinsDefaultParameterValue struct {
        Class string `json:"_class" example:"hudson.model.StringParameterValue"`
        Value string `json:"value" example:"main"`
}

// JenkinsTriggerResponse represents the response when triggering a job
type JenkinsTriggerResponse struct {
        Status      string `json:"status" example:"queued"`
        Message     string `json:"message" example:"Job successfully queued in Jenkins"`
        QueueURL    string `json:"queueUrl" example:"https://gkecfsmulticis2.jaas-gcp.cloud.sap.corp/queue/item/12345/"`
        QueueItemID string `json:"queueItemId" example:"12345"`
        BaseJobURL  string `json:"baseJobUrl" example:"https://gkecfsmulticis2.jaas-gcp.cloud.sap.corp/job/multi-cis-v3-create"`
        JobName     string `json:"jobName" example:"multi-cis-v3-create"`
        JaasName    string `json:"jaasName" example:"gkecfsmulticis2"`
}

// JenkinsQueueStatusResponse represents the response for queue item status
type JenkinsQueueStatusResponse struct {
        Status       string `json:"status" example:"queued"`
        BuildNumber  *int   `json:"buildNumber" example:"123"`
        BuildURL     string `json:"buildUrl" example:"https://gkecfsmulticis2.jaas-gcp.cloud.sap.corp/job/multi-cis-v3-create/123/"`
        QueuedReason string `json:"queuedReason" example:"Waiting for available executor"`
        WaitTime     int    `json:"waitTime" example:"45"`
}

// JenkinsBuildStatusResponse represents the response for build status
type JenkinsBuildStatusResponse struct {
        Status   string `json:"status" example:"success"`
        Result   string `json:"result" example:"SUCCESS"`
        Building bool   `json:"building" example:"false"`
        Duration int    `json:"duration" example:"120"`
        BuildURL string `json:"buildUrl" example:"https://gkecfsmulticis2.jaas-gcp.cloud.sap.corp/job/multi-cis-v3-create/123/"`
}

// GetJobParameters retrieves the parameters definition for a Jenkins job
// @Summary Get Jenkins job parameters
// @Description Retrieves available parameters for a Jenkins job from the specified JAAS instance. Returns only parameters from hudson.model.ParametersDefinitionProperty.
// @Tags jenkins
// @Produce json
// @Param jaasName path string true "JAAS instance name (e.g., 'cfsmc')"
// @Param jobName path string true "Jenkins job name"
// @Success 200 {object} handlers.JenkinsParametersResponse "Filtered parameter definitions containing parameterDefinitions array with name, type, defaultParameterValue, choices, and description"
// @Failure 400 {object} map[string]string "Missing path parameter"
// @Failure 502 {object} map[string]string "Jenkins request failed"
// @Security BearerAuth
// @Router /self-service/jenkins/{jaasName}/{jobName}/parameters [get]
func (h *JenkinsHandler) GetJobParameters(c *gin.Context) <span class="cov7" title="14">{
        jaasName := c.Param("jaasName")
        if jaasName == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "missing path parameter: jaasName"})
                return
        }</span>

        <span class="cov7" title="13">jobName := c.Param("jobName")
        if jobName == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "missing path parameter: jobName"})
                return
        }</span>

        // Create context with user information from auth claims
        <span class="cov7" title="12">ctx := createContextWithUser(c)

        result, err := h.service.GetJobParameters(ctx, jaasName, jobName)
        if err != nil </span><span class="cov2" title="2">{
                c.JSON(http.StatusBadGateway, gin.H{"error": "jenkins request failed: " + err.Error()})
                return
        }</span>

        <span class="cov6" title="10">c.JSON(http.StatusOK, result)</span>
}

// createContextWithUser extracts user information from gin context and adds it to a new context
func createContextWithUser(c *gin.Context) context.Context <span class="cov9" title="28">{
        ctx := c.Request.Context()

        // Try to get auth claims from context
        if claims, exists := c.Get("auth_claims"); exists </span><span class="cov0" title="0">{
                if authClaims, ok := claims.(*auth.AuthClaims); ok </span><span class="cov0" title="0">{
                        // Add user information to context
                        ctx = context.WithValue(ctx, "email", authClaims.Email)
                        ctx = context.WithValue(ctx, "username", authClaims.Username)
                        ctx = context.WithValue(ctx, "user", authClaims.Email) // Prefer email as primary identifier
                        return ctx
                }</span>
        }

        <span class="cov9" title="28">return ctx</span>
}

// TriggerJob triggers a Jenkins job with optional parameters
// @Summary Trigger Jenkins job
// @Description Triggers a Jenkins job on the specified JAAS instance with optional parameters. Returns queue information for tracking. The job is queued initially, and you can poll the queueUrl to get the actual build URL once the job starts running. Parameters can be strings, booleans, or numbers - all will be converted to strings for Jenkins. If no parameters are provided or body is empty, Jenkins will use the default values defined in the job configuration. You can override specific parameters while letting others use their defaults. The baseJobUrl points to the job definition page, not a specific build.
// @Tags jenkins
// @Accept json
// @Produce json
// @Param jaasName path string true "JAAS instance name (e.g., 'gkecfsmulticis2')"
// @Param jobName path string true "Jenkins job name (e.g., 'multi-cis-v3-create')"
// @Param parameters body map[string]interface{} false "Optional job parameters as key-value pairs. Values can be strings, booleans, or numbers. Omitted parameters will use their default values from the job configuration."
// @Success 200 {object} handlers.JenkinsTriggerResponse "Job successfully queued with tracking information (queueUrl can be polled to get build URL)"
// @Failure 400 {object} map[string]string "Missing path parameter or invalid request body"
// @Failure 502 {object} map[string]string "Jenkins trigger failed - check credentials or Jenkins availability"
// @Security BearerAuth
// @Router /self-service/jenkins/{jaasName}/{jobName}/trigger [post]
func (h *JenkinsHandler) TriggerJob(c *gin.Context) <span class="cov7" title="11">{
        jaasName := c.Param("jaasName")
        if jaasName == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "missing path parameter: jaasName"})
                return
        }</span>

        <span class="cov6" title="10">jobName := c.Param("jobName")
        if jobName == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "missing path parameter: jobName"})
                return
        }</span>

        // Parse optional parameters from request body
        // Accept any value type (string, bool, number) and convert to strings for Jenkins
        <span class="cov6" title="9">var rawParameters map[string]interface{}
        if err := c.ShouldBindJSON(&amp;rawParameters); err != nil </span><span class="cov3" title="3">{
                // If body is empty or invalid, proceed with no parameters
                rawParameters = make(map[string]interface{})
        }</span>

        // Convert all values to strings (Jenkins expects form-encoded string values)
        <span class="cov6" title="9">parameters := make(map[string]string)
        for key, value := range rawParameters </span><span class="cov8" title="18">{
                // Convert any type to string representation
                switch v := value.(type) </span>{
                case string:<span class="cov7" title="14">
                        parameters[key] = v</span>
                case bool:<span class="cov2" title="2">
                        if v </span><span class="cov1" title="1">{
                                parameters[key] = "true"
                        }</span> else<span class="cov1" title="1"> {
                                parameters[key] = "false"
                        }</span>
                case float64, float32:<span class="cov2" title="2">
                        parameters[key] = fmt.Sprintf("%v", v)</span>
                case int, int32, int64:<span class="cov0" title="0">
                        parameters[key] = fmt.Sprintf("%d", v)</span>
                case nil:<span class="cov0" title="0">
                        parameters[key] = ""</span>
                default:<span class="cov0" title="0">
                        // For any other type, use fmt.Sprintf
                        parameters[key] = fmt.Sprintf("%v", v)</span>
                }
        }

        // Create context with user information from auth claims
        <span class="cov6" title="9">ctx := createContextWithUser(c)

        result, err := h.service.TriggerJob(ctx, jaasName, jobName, parameters)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadGateway, gin.H{"error": "jenkins trigger failed: " + err.Error()})
                return
        }</span>

        // Convert service result to handler response
        <span class="cov6" title="8">response := JenkinsTriggerResponse{
                Status:      result.Status,
                Message:     result.Message,
                QueueURL:    result.QueueURL,
                QueueItemID: result.QueueItemID,
                BaseJobURL:  result.BaseJobURL,
                JobName:     result.JobName,
                JaasName:    result.JaasName,
        }

        c.JSON(http.StatusOK, response)</span>
}

// GetQueueItemStatus retrieves the status of a queued Jenkins job
// @Summary Get Jenkins queue item status
// @Description Retrieves the current status of a queued Jenkins job. Poll this endpoint to track when the job starts building and obtain the build number and URL.
// @Tags jenkins
// @Produce json
// @Param jaasName path string true "JAAS instance name (e.g., 'gkecfsmulticis2')"
// @Param queueItemId path string true "Queue item ID (obtained from trigger response)"
// @Success 200 {object} handlers.JenkinsQueueStatusResponse "Queue item status with build information once started"
// @Failure 404 {object} map[string]string "Queue item not found"
// @Failure 502 {object} map[string]string "Jenkins API request failed"
// @Router /self-service/jenkins/{jaasName}/queue/{queueItemId}/status [get]
func (h *JenkinsHandler) GetQueueItemStatus(c *gin.Context) <span class="cov3" title="3">{
        jaasName := c.Param("jaasName")
        queueItemID := c.Param("queueItemId")

        // Create context with user information from auth claims
        ctx := createContextWithUser(c)

        result, err := h.service.GetQueueItemStatus(ctx, jaasName, queueItemID)
        if err != nil </span><span class="cov2" title="2">{
                // Check if it's a not found error
                if strings.Contains(err.Error(), "queue item not found") </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusBadGateway, gin.H{"error": "jenkins queue item status failed: " + err.Error()})
                return</span>
        }

        // Convert service result to handler response
        <span class="cov1" title="1">response := JenkinsQueueStatusResponse{
                Status:       result.Status,
                BuildNumber:  result.BuildNumber,
                BuildURL:     result.BuildURL,
                QueuedReason: result.QueuedReason,
                WaitTime:     result.WaitTime,
        }

        c.JSON(http.StatusOK, response)</span>
}

// GetBuildStatus retrieves the status of a Jenkins build
// @Summary Get Jenkins build status
// @Description Retrieves the current status of a Jenkins build. Poll this endpoint to track the build progress and check if it has completed successfully.
// @Tags jenkins
// @Produce json
// @Param jaasName path string true "JAAS instance name (e.g., 'gkecfsmulticis2')"
// @Param jobName path string true "Jenkins job name"
// @Param buildNumber path int true "Build number (obtained from queue status)"
// @Success 200 {object} handlers.JenkinsBuildStatusResponse "Build status with result and duration"
// @Failure 400 {object} map[string]string "Invalid build number"
// @Failure 404 {object} map[string]string "Build not found"
// @Failure 502 {object} map[string]string "Jenkins API request failed"
// @Router /self-service/jenkins/{jaasName}/{jobName}/{buildNumber}/status [get]
func (h *JenkinsHandler) GetBuildStatus(c *gin.Context) <span class="cov5" title="5">{
        jaasName := c.Param("jaasName")
        jobName := c.Param("jobName")
        buildNumberStr := c.Param("buildNumber")

        // Parse build number
        var actualBuildNumber int
        _, err := fmt.Sscanf(buildNumberStr, "%d", &amp;actualBuildNumber)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid build number"})
                return
        }</span>

        // Create context with user information from auth claims
        <span class="cov4" title="4">ctx := createContextWithUser(c)

        result, err := h.service.GetBuildStatus(ctx, jaasName, jobName, actualBuildNumber)
        if err != nil </span><span class="cov2" title="2">{
                // Check if it's a not found error
                if strings.Contains(err.Error(), "build not found") </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusBadGateway, gin.H{"error": "jenkins build status failed: " + err.Error()})
                return</span>
        }

        // Convert service result to handler response
        // Convert duration from milliseconds to seconds
        <span class="cov2" title="2">durationSeconds := int(result.Duration / 1000)

        response := JenkinsBuildStatusResponse{
                Status:   result.Status,
                Result:   result.Result,
                Building: result.Building,
                Duration: durationSeconds,
                BuildURL: result.BuildURL,
        }

        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "developer-portal-backend/internal/errors"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "developer-portal-backend/internal/auth"
        "developer-portal-backend/internal/service"

        "github.com/gin-gonic/gin"
)

// JiraHandler handles Jira-related HTTP requests
type JiraHandler struct {
        service service.JiraServiceInterface
}

// NewJiraHandler creates a new Jira handler
func NewJiraHandler(s service.JiraServiceInterface) *JiraHandler <span class="cov4" title="3">{
        return &amp;JiraHandler{service: s}
}</span>

// GetIssues returns Jira issues for teams/projects with real Jira values that convert to JQL.
// @Summary Get Jira issues for teams/projects
// @Description Returns Jira issues filtered by project, status, team, assignee, type, summary, and key using real Jira values with pagination
// @Tags jira
// @Produce json
// @Param project query string false "Jira project key (e.g., SAPBTPCFS)"
// @Param status query string false "Jira status values (e.g., 'Open,In Progress,Re Opened')"
// @Param team query string false "Team name for filtering"
// @Param assignee query string false "Assignee username for filtering"
// @Param type query string false "Issue type (e.g., 'Bug,Task,Story')"
// @Param summary query string false "Free text search in summary"
// @Param key query string false "Specific issue key (e.g., 'BUG-1234')"
// @Param page query int false "Page number (default: 1)"
// @Param limit query int false "Number of items per page (default: 50, max: 100)"
// @Success 200 {object} service.JiraIssuesResponse "Issues"
// @Failure 400 {object} map[string]string "Invalid pagination parameters"
// @Failure 502 {object} map[string]string "Jira request failed"
// @Security BearerAuth
// @Router /jira/issues [get]
func (h *JiraHandler) GetIssues(c *gin.Context) <span class="cov9" title="10">{
        // Get query parameters
        project := c.Query("project")
        status := c.Query("status")
        team := c.Query("team")
        assignee := c.Query("assignee")
        issueType := c.Query("type")
        summary := c.Query("summary")
        key := c.Query("key")

        // Parse pagination parameters
        page, limit, err := h.parsePaginationParams(c)
        if err != nil </span><span class="cov6" title="5">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Create filters with real Jira values
        <span class="cov6" title="5">filters := service.JiraIssueFilters{
                Project:  project,
                Status:   status,
                Team:     team,
                Assignee: assignee,
                Type:     issueType,
                Summary:  summary,
                Key:      key,
                Page:     page,
                Limit:    limit,
        }

        issues, err := h.service.GetIssues(filters)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadGateway, gin.H{"error": "jira search failed: " + err.Error()})
                return
        }</span>

        <span class="cov5" title="4">c.JSON(http.StatusOK, issues)</span>
}

// GetMyIssues returns Jira issues for the current authenticated user.
// @Summary Get my Jira issues
// @Description Returns Jira issues for the current authenticated user with optional filtering and pagination
// @Tags jira
// @Produce json
// @Param status query string false "Jira status values (e.g., 'Open,In Progress')"
// @Param project query string false "Jira project key (e.g., SAPBTPCFS)"
// @Param page query int false "Page number (default: 1)"
// @Param limit query int false "Number of items per page (default: 50, max: 100)"
// @Success 200 {object} service.JiraIssuesResponse "Issues"
// @Failure 400 {object} map[string]string "Invalid pagination parameters"
// @Failure 401 {object} map[string]string "Authentication required"
// @Failure 502 {object} map[string]string "Jira request failed"
// @Security BearerAuth
// @Router /jira/issues/me [get]
func (h *JiraHandler) GetMyIssues(c *gin.Context) <span class="cov7" title="6">{
        // Get authenticated user claims from context (set by auth middleware)
        claimsInterface, exists := c.Get("auth_claims")
        if !exists </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                return
        }</span>

        <span class="cov6" title="5">claims, ok := claimsInterface.(*auth.AuthClaims)
        if !ok </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authentication claims"})
                return
        }</span>

        // Use the username from the authenticated user
        <span class="cov5" title="4">username := claims.Username
        if username == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Username not available in authentication claims"})
                return
        }</span>

        // Get query parameters
        <span class="cov4" title="3">status := c.Query("status")
        project := c.Query("project")

        // Parse pagination parameters
        page, limit, err := h.parsePaginationParams(c)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Create filters with user from auth context
        <span class="cov3" title="2">filters := service.JiraIssueFilters{
                Status:  status,
                Project: project,
                User:    username,
                Page:    page,
                Limit:   limit,
        }

        issues, err := h.service.GetIssues(filters)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadGateway, gin.H{"error": "jira search failed: " + err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, issues)</span>
}

// GetMyIssuesCount returns the count of Jira issues for the current authenticated user by status.
// @Summary Get count of my Jira issues by status
// @Description Returns the count of Jira issues for the current authenticated user filtered by status
// @Tags jira
// @Produce json
// @Param status query string true "Jira status value (e.g., 'Resolved')"
// @Param project query string false "Jira project key (e.g., SAPBTPCFS)"
// @Param date query string false "Date in yyyy-MM-dd format for date filtering (default: one year ago for resolved issues)"
// @Success 200 {object} map[string]int "Count"
// @Failure 400 {object} map[string]string "Missing or invalid query parameter"
// @Failure 401 {object} map[string]string "Authentication required"
// @Failure 502 {object} map[string]string "Jira request failed"
// @Security BearerAuth
// @Router /jira/issues/me/count [get]
func (h *JiraHandler) GetMyIssuesCount(c *gin.Context) <span class="cov9" title="10">{
        // Get authenticated user claims from context (set by auth middleware)
        claimsInterface, exists := c.Get("auth_claims")
        if !exists </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                return
        }</span>

        <span class="cov8" title="9">claims, ok := claimsInterface.(*auth.AuthClaims)
        if !ok </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authentication claims"})
                return
        }</span>

        // Use the username from the authenticated user
        <span class="cov8" title="8">username := claims.Username
        if username == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Username not available in authentication claims"})
                return
        }</span>

        // Get query parameters
        <span class="cov7" title="7">status := c.Query("status")
        if status == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": errors.NewMissingQueryParam("status").Error()})
                return
        }</span>

        <span class="cov7" title="6">project := c.Query("project")
        date := c.Query("date")

        // Set default date for resolved issues if not provided
        if date == "" &amp;&amp; status == "Resolved" </span><span class="cov4" title="3">{
                date = time.Now().AddDate(-1, 0, 0).Format("2006-01-02")
        }</span> else<span class="cov4" title="3"> if date != "" </span><span class="cov3" title="2">{
                // Validate date format if provided
                if _, err := time.Parse("2006-01-02", date); err != nil </span><span class="cov1" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid date format: must be yyyy-MM-dd"})
                        return
                }</span>
        }

        // Create filters with user from auth context
        <span class="cov6" title="5">filters := service.JiraIssueFilters{
                Status:  status,
                Project: project,
                User:    username,
                Date:    date,
        }

        count, err := h.service.GetIssuesCount(filters)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadGateway, gin.H{"error": "jira search failed: " + err.Error()})
                return
        }</span>

        <span class="cov5" title="4">c.JSON(http.StatusOK, gin.H{"count": count})</span>
}

// parsePaginationParams parses and validates pagination parameters from the request
func (h *JiraHandler) parsePaginationParams(c *gin.Context) (page, limit int, err error) <span class="cov10" title="13">{
        // Default values
        page = 1
        limit = 50

        // Parse page parameter
        if pageStr := c.Query("page"); pageStr != "" </span><span class="cov6" title="5">{
                if page, err = strconv.Atoi(pageStr); err != nil </span><span class="cov3" title="2">{
                        return 0, 0, fmt.Errorf("invalid page parameter: must be a positive integer")
                }</span>
                <span class="cov4" title="3">if page &lt; 1 </span><span class="cov1" title="1">{
                        return 0, 0, fmt.Errorf("invalid page parameter: must be greater than 0")
                }</span>
        }

        // Parse limit parameter
        <span class="cov9" title="10">if limitStr := c.Query("limit"); limitStr != "" </span><span class="cov6" title="5">{
                if limit, err = strconv.Atoi(limitStr); err != nil </span><span class="cov1" title="1">{
                        return 0, 0, fmt.Errorf("invalid limit parameter: must be a positive integer")
                }</span>
                <span class="cov5" title="4">if limit &lt; 1 </span><span class="cov1" title="1">{
                        return 0, 0, fmt.Errorf("invalid limit parameter: must be greater than 0")
                }</span>
                <span class="cov4" title="3">if limit &gt; 100 </span><span class="cov1" title="1">{
                        return 0, 0, fmt.Errorf("invalid limit parameter: maximum allowed is 100")
                }</span>
        }

        <span class="cov7" title="7">return page, limit, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import (
        "errors"
        "net/http"

        apperrors "developer-portal-backend/internal/errors"
        "developer-portal-backend/internal/service"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// LandscapeHandler handles HTTP requests for landscape operations
type LandscapeHandler struct {
        landscapeService service.LandscapeServiceInterface
}

// NewLandscapeHandler creates a new landscape handler
func NewLandscapeHandler(landscapeService service.LandscapeServiceInterface) *LandscapeHandler <span class="cov10" title="13">{
        return &amp;LandscapeHandler{
                landscapeService: landscapeService,
        }
}</span>

// ListLandscapesByQuery handles GET /landscapes?project-name=&lt;project_name&gt;
// @Summary List landscapes by project name
// @Description Return all landscapes that belong to the specified project (unpaginated, minimal fields)
// @Tags landscapes
// @Accept json
// @Produce json
// @Param project-name query string true "Project name"
// @Success 200 {array} service.LandscapeMinimalResponse "Successfully retrieved landscapes by project name"
// @Failure 400 {object} map[string]interface{} "project-name is required"
// @Failure 404 {object} map[string]interface{} "Project not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /landscapes [get]
func (h *LandscapeHandler) ListLandscapesByQuery(c *gin.Context) <span class="cov7" title="7">{
        projectName := c.Query("project-name")
        if projectName == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": apperrors.NewMissingQueryParam("project-name").Error()})
                return
        }</span>

        <span class="cov7" title="6">mins, err := h.landscapeService.GetByProjectNameAll(projectName)
        if err != nil </span><span class="cov3" title="2">{
                if errors.Is(err, apperrors.ErrProjectNotFound) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return</span>
        }

        <span class="cov5" title="4">c.JSON(http.StatusOK, mins)</span>
}

// DeleteLandscape handles DELETE /landscapes/:id
// @Summary Delete a landscape by ID
// @Description Delete a landscape by its ID
// @Tags landscapes
// @Accept json
// @Produce json
// @Param id path string true "Landscape ID"
// @Success 204 "Successfully deleted landscape"
// @Failure 400 {object} map[string]interface{} "Invalid landscape ID"
// @Failure 404 {object} map[string]interface{} "Landscape not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /landscapes/{id} [delete]
func (h *LandscapeHandler) DeleteLandscape(c *gin.Context) <span class="cov5" title="4">{
        idParam := c.Param("id")
        if idParam == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "landscape ID is required"})
                return
        }</span>

        <span class="cov5" title="4">landscapeID, err := uuid.Parse(idParam)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid landscape ID format"})
                return
        }</span>

        <span class="cov4" title="3">err = h.landscapeService.DeleteLandscape(landscapeID)
        if err != nil </span><span class="cov3" title="2">{
                if errors.Is(err, apperrors.ErrLandscapeNotFound) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return</span>
        }

        <span class="cov1" title="1">c.Status(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package handlers

import (
        "net/http"

        apperrors "developer-portal-backend/internal/errors"
        "developer-portal-backend/internal/repository"
        "developer-portal-backend/internal/service"

        "github.com/gin-gonic/gin"
)

// LDAPHandler handles LDAP-related HTTP requests
type LDAPHandler struct {
        service  service.LDAPServiceInterface
        userRepo repository.UserRepositoryInterface
}

// NewLDAPHandler creates a new LDAP handler
func NewLDAPHandler(s service.LDAPServiceInterface, r repository.UserRepositoryInterface) *LDAPHandler <span class="cov10" title="7">{
        return &amp;LDAPHandler{service: s, userRepo: r}
}</span>

// UserSearch searches LDAP users by name prefix
// @Summary Search LDAP users by name prefix
// @Description Searches LDAP directory for users where name starts with given prefix
// @Tags users
// @Produce json
// @Param name query string true "Name prefix"
// @Success 200 {object} service.LDAPUserSearchResponse "Search results"
// @Failure 400 {object} map[string]interface{} "Missing or invalid query parameter"
// @Failure 502 {object} map[string]interface{} "LDAP connection or search failed"
// @Security BearerAuth
// @Router /users/search/new [get]
func (h *LDAPHandler) UserSearch(c *gin.Context) <span class="cov10" title="7">{
        name := c.Query("name")
        if name == "" </span><span class="cov4" title="2">{
                c.JSON(http.StatusBadRequest, gin.H{"error": apperrors.NewMissingQueryParam("name").Error()})
                return
        }</span>

        // 1) Query LDAP by CN prefix
        <span class="cov8" title="5">users, ldapErr := h.service.SearchUsersByCN(name)
        if ldapErr != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadGateway, gin.H{"error": "ldap search failed: " + ldapErr.Error()})
                return
        }</span>

        // 2) Extract user_ids from LDAP results (LDAP 'name' corresponds to users.user_id)
        <span class="cov7" title="4">ids := make([]string, 0, len(users))
        for _, u := range users </span><span class="cov7" title="4">{
                if u.Name != "" </span><span class="cov7" title="4">{
                        ids = append(ids, u.Name)
                }</span>
        }

        // 3) Query DB for which of those user_ids already exist
        <span class="cov7" title="4">existing, repoErr := h.userRepo.GetExistingUserIDs(ids)
        if repoErr != nil </span><span class="cov1" title="1">{
                // If DB check fails, proceed assuming none exist
                existing = []string{}
        }</span>

        // 4) Build set of existing user_ids
        <span class="cov7" title="4">existingSet := make(map[string]struct{}, len(existing))
        for _, id := range existing </span><span class="cov1" title="1">{
                if id != "" </span><span class="cov1" title="1">{
                        existingSet[id] = struct{}{}
                }</span>
        }

        // 5) Build response; 'new' is true if user_id not found in DB
        <span class="cov7" title="4">resp := make([]gin.H, 0, len(users))
        for _, u := range users </span><span class="cov7" title="4">{
                _, exists := existingSet[u.Name] // u.Name is the LDAP-provided user_id
                resp = append(resp, gin.H{
                        "id":         u.Name,
                        "first_name": u.GivenName,
                        "last_name":  u.SN,
                        "email":      u.Mail,
                        "mobile":     u.Mobile,
                        "new":        !exists,
                })
        }</span>
        <span class="cov7" title="4">c.JSON(http.StatusOK, gin.H{"result": resp})</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "net/http"
        "errors"

        "developer-portal-backend/internal/auth"
        "developer-portal-backend/internal/service"
        apperrors "developer-portal-backend/internal/errors"
        "developer-portal-backend/internal/logger"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// LinkHandler handles HTTP requests for links
type LinkHandler struct {
        linkService service.LinkServiceInterface
}

// NewLinkHandler creates a new link handler
func NewLinkHandler(linkService service.LinkServiceInterface) *LinkHandler <span class="cov10" title="15">{
        return &amp;LinkHandler{
                linkService: linkService,
        }
}</span>

 // ListLinks handles GET /links?owner=&lt;owner_name&gt;
 // @Summary List links by owner name
 // @Description Returns all links owned by the user with the given owner name (user_id). Example: owner=cis.devops will return all links created in the initial data.
 // @Tags links
 // @Accept json
 // @Produce json
 // @Param owner query string false "Owner name (user_id). Defaults to 'cis.devops' if not provided" example(cis.devops)
 // @Success 200 {array} service.LinkResponse "Successfully retrieved links"
 // @Failure 400 {object} map[string]interface{} "Missing or invalid owner name"
 // @Failure 404 {object} map[string]interface{} "Owner user not found"
 // @Failure 500 {object} map[string]interface{} "Internal server error"
 // @Security BearerAuth
 // @Router /links [get]
func (h *LinkHandler) ListLinks(c *gin.Context) <span class="cov5" title="4">{
        ownerUserID := c.Query("owner")
        if ownerUserID == "" </span><span class="cov5" title="4">{
                ownerUserID = "cis.devops"
        }</span>

        // Get logged-in username from token (set by auth middleware)
        <span class="cov5" title="4">viewerName, _ := auth.GetUsername(c)

        var (
                links []service.LinkResponse
                err   error
        )

        if viewerName != "" </span><span class="cov3" title="2">{
                // Prefer enriched response that marks favorites based on viewer's metadata
                links, err = h.linkService.GetByOwnerUserIDWithViewer(ownerUserID, viewerName)
        }</span> else<span class="cov3" title="2"> {
                // Fallback (shouldn't happen due to RequireAuth) to non-enriched response
                links, err = h.linkService.GetByOwnerUserID(ownerUserID)
        }</span>

        <span class="cov5" title="4">if err != nil </span><span class="cov3" title="2">{
                // Distinguish between not found and other errors by simple string check
                if links == nil </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get links", "details": err.Error()})
                return</span>
        }

        // Return array of links (without audit or owner fields)
        <span class="cov3" title="2">c.JSON(http.StatusOK, links)</span>
}

// CreateLink handles POST /links
// @Summary Create a new link
// @Description Creates a new link. Title will mirror name. Validates owner (must be existing user or team) and category_id exists. Tags are optional.
// @Description created_by is derived from the bearer token 'username' claim and is NOT required in the payload.
// @Tags links
// @Accept json
// @Produce json
// @Param link body service.CreateLinkRequest true "Link data"
// @Success 201 {object} service.LinkResponse "Successfully created link"
// @Failure 400 {object} map[string]interface{} "Invalid request or validation failed"
// @Failure 401 {object} map[string]interface{} "Authentication required"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /links [post]
func (h *LinkHandler) CreateLink(c *gin.Context) <span class="cov4" title="3">{
        var req service.CreateLinkRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Populate created_by from bearer token username
        <span class="cov4" title="3">if username, ok := auth.GetUsername(c); ok &amp;&amp; username != "" </span><span class="cov3" title="2">{
                req.CreatedBy = username
        }</span> else<span class="cov1" title="1"> {
                c.JSON(http.StatusUnauthorized, gin.H{"error": "missing username in token"})
                return
        }</span>

        <span class="cov3" title="2">link, err := h.linkService.CreateLink(&amp;req)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusCreated, link)</span>
}

// UpdateLink handles PUT /links/:id
// @Summary Update a link by ID
// @Description Updates an existing link. Title will mirror name. Validates category_id exists. Tags are optional. Owner field cannot be changed.
// @Description updated_by is derived from the bearer token 'username' claim and is NOT required in the payload.
// @Tags links
// @Accept json
// @Produce json
// @Param id path string true "Link ID (UUID)"
// @Param link body service.UpdateLinkRequest true "Link data"
// @Success 200 {object} service.LinkResponse "Successfully updated link"
// @Failure 400 {object} map[string]interface{} "Invalid request or validation failed"
// @Failure 401 {object} map[string]interface{} "Authentication required"
// @Failure 404 {object} map[string]interface{} "Link not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /links/{id} [put]
func (h *LinkHandler) UpdateLink(c *gin.Context) <span class="cov6" title="5">{
        log := logger.FromGinContext(c)

        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov1" title="1">{
                log.WithField("link_id", idStr).Warn("Link update failed: invalid link ID")
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid link ID"})
                return
        }</span>

        <span class="cov5" title="4">var req service.UpdateLinkRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                log.WithFields(map[string]interface{}{
                        "link_id": id.String(),
                        "error":   err.Error(),
                }).Warn("Link update failed: invalid request body")
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Populate updated_by from bearer token username
        <span class="cov5" title="4">username, ok := auth.GetUsername(c)
        if !ok || username == "" </span><span class="cov1" title="1">{
                log.WithField("link_id", id.String()).Warn("Link update failed: missing username in token")
                c.JSON(http.StatusUnauthorized, gin.H{"error": "missing username in token"})
                return
        }</span>
        <span class="cov4" title="3">req.UpdatedBy = username

        log.WithFields(map[string]interface{}{
                "link_id":     id.String(),
                "link_name":   req.Name,
                "url":         req.URL,
                "category_id": req.CategoryID,
                "updated_by":  req.UpdatedBy,
        }).Info("Updating link")

        link, err := h.linkService.UpdateLink(id, &amp;req)
        if err != nil </span><span class="cov3" title="2">{
                // Handle specific error types using error constants
                if errors.Is(err, apperrors.ErrLinkNotFound) </span><span class="cov0" title="0">{
                        log.WithFields(map[string]interface{}{
                                "link_id": id.String(),
                                "error":   err.Error(),
                        }).Warn("Link update failed: link not found")
                        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov3" title="2">if errors.Is(err, apperrors.ErrUserNotFound) </span><span class="cov0" title="0">{
                        log.WithFields(map[string]interface{}{
                                "link_id": id.String(),
                                "error":   err.Error(),
                        }).Warn("Link update failed: user not found")
                        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov3" title="2">if errors.Is(err, apperrors.ErrCategoryNotFound) </span><span class="cov0" title="0">{
                        log.WithFields(map[string]interface{}{
                                "link_id": id.String(),
                                "error":   err.Error(),
                        }).Warn("Link update failed: category not found")
                        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov3" title="2">if apperrors.IsValidation(err) </span><span class="cov0" title="0">{
                        log.WithFields(map[string]interface{}{
                                "link_id": id.String(),
                                "error":   err.Error(),
                        }).Warn("Link update failed: validation error")
                        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>
                // Generic error
                <span class="cov3" title="2">log.WithFields(map[string]interface{}{
                        "link_id": id.String(),
                        "error":   err.Error(),
                }).Error("Link update failed")
                c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to update link"})
                return</span>
        }

        <span class="cov1" title="1">log.WithFields(map[string]interface{}{
                "link_id":   link.ID,
                "link_name": link.Name,
        }).Info("Link updated successfully")

        c.JSON(http.StatusOK, link)</span>
}

// DeleteLink handles DELETE /links/:id
// @Summary Delete a link by ID
// @Description Deletes a link from the links table by the given UUID
// @Tags links
// @Accept json
// @Produce json
// @Param id path string true "Link ID (UUID)"
// @Success 204 "Successfully deleted link"
// @Failure 400 {object} map[string]interface{} "Invalid link ID"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /links/{id} [delete]
func (h *LinkHandler) DeleteLink(c *gin.Context) <span class="cov4" title="3">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid link ID"})
                return
        }</span>

        <span class="cov3" title="2">if err := h.linkService.DeleteLink(id); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to delete link", "details": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusNoContent, nil)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package handlers

import (
        "developer-portal-backend/internal/auth"
        "developer-portal-backend/internal/service"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// pluginProxyCache represents a cached response with expiration
type pluginProxyCache struct {
        response  map[string]interface{}
        expiresAt time.Time
}

// PluginHandler handles HTTP requests for plugins
type PluginHandler struct {
        pluginService service.PluginServiceInterface
        githubService service.GitHubServiceInterface
        proxyCache    map[string]*pluginProxyCache
        cacheMux      sync.RWMutex
}

// NewPluginHandler creates a new plugin handler
func NewPluginHandler(pluginService service.PluginServiceInterface) *PluginHandler <span class="cov10" title="35">{
        return &amp;PluginHandler{
                pluginService: pluginService,
                proxyCache:    make(map[string]*pluginProxyCache),
        }
}</span>

// NewPluginHandlerWithGitHub creates a new plugin handler with GitHub service
func NewPluginHandlerWithGitHub(pluginService service.PluginServiceInterface, githubService service.GitHubServiceInterface) *PluginHandler <span class="cov5" title="6">{
        return &amp;PluginHandler{
                pluginService: pluginService,
                githubService: githubService,
                proxyCache:    make(map[string]*pluginProxyCache),
        }
}</span>

// GetAllPlugins handles GET /plugins
// @Summary Get all plugins or only subscribed plugins
// @Description Retrieve all plugins with pagination. When subscribed=true, returns only plugins the authenticated user is subscribed to. When subscribed=false or omitted, returns all plugins with subscription status marked for authenticated users.
// @Tags plugins
// @Accept json
// @Produce json
// @Param limit query int false "Number of items to return" default(20)
// @Param offset query int false "Number of items to skip" default(0)
// @Param subscribed query bool false "When true, return only subscribed plugins. When false, return all plugins with subscription status." default(false)
// @Success 200 {object} service.PluginListResponse "Successfully retrieved plugins list"
// @Failure 400 {object} map[string]interface{} "Invalid parameters"
// @Failure 401 {object} map[string]interface{} "Authentication required when subscribed=true"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /plugins [get]
func (h *PluginHandler) GetAllPlugins(c *gin.Context) <span class="cov6" title="10">{
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
        subscribed := c.DefaultQuery("subscribed", "false") == "true"

        // Validate pagination parameters
        if limit &lt; 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "limit must be non-negative"})
                return
        }</span>
        <span class="cov6" title="9">if offset &lt; 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "offset must be non-negative"})
                return
        }</span>

        <span class="cov6" title="8">var plugins *service.PluginListResponse
        var err error

        if subscribed </span><span class="cov4" title="4">{
                // Extract user claims from authentication context
                claimsInterface, exists := c.Get("auth_claims")
                if !exists </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                        return
                }</span>

                <span class="cov3" title="3">claims, ok := claimsInterface.(*auth.AuthClaims)
                if !ok </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid authentication claims"})
                        return
                }</span>

                // Get all plugins with subscription status, then filter to only subscribed ones
                <span class="cov3" title="3">allPlugins, err := h.pluginService.GetAllPluginsWithViewer(limit, offset, claims.Username)
                if err != nil </span><span class="cov1" title="1">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve plugins", "details": err.Error()})
                        return
                }</span>

                // Filter to only subscribed plugins
                <span class="cov2" title="2">subscribedPlugins := make([]service.PluginResponse, 0)
                for _, plugin := range allPlugins.Plugins </span><span class="cov4" title="4">{
                        if plugin.Subscribed </span><span class="cov1" title="1">{
                                subscribedPlugins = append(subscribedPlugins, plugin)
                        }</span>
                }

                // Create filtered response
                <span class="cov2" title="2">plugins = &amp;service.PluginListResponse{
                        Plugins: subscribedPlugins,
                        Total:   int64(len(subscribedPlugins)),
                        Limit:   allPlugins.Limit,
                        Offset:  allPlugins.Offset,
                }</span>
        } else<span class="cov4" title="4"> {
                // Use the viewer method to include subscription status for all plugins
                claimsInterface, exists := c.Get("auth_claims")
                if exists </span><span class="cov2" title="2">{
                        if claims, ok := claimsInterface.(*auth.AuthClaims); ok </span><span class="cov2" title="2">{
                                // Include subscription status for authenticated users
                                plugins, err = h.pluginService.GetAllPluginsWithViewer(limit, offset, claims.Username)
                        }</span> else<span class="cov0" title="0"> {
                                // Fallback to standard method if claims are invalid
                                plugins, err = h.pluginService.GetAllPlugins(limit, offset)
                        }</span>
                } else<span class="cov2" title="2"> {
                        // Use standard method for unauthenticated requests
                        plugins, err = h.pluginService.GetAllPlugins(limit, offset)
                }</span>
        }

        <span class="cov5" title="6">if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve plugins", "details": err.Error()})
                return
        }</span>

        <span class="cov5" title="6">c.JSON(http.StatusOK, plugins)</span>
}

// GetPluginByID handles GET /plugins/{id}
// @Summary Get plugin by ID
// @Description Retrieve a specific plugin by its ID
// @Tags plugins
// @Accept json
// @Produce json
// @Param id path string true "Plugin ID (UUID)"
// @Success 200 {object} service.PluginResponse "Successfully retrieved plugin"
// @Failure 400 {object} map[string]interface{} "Invalid plugin ID"
// @Failure 404 {object} map[string]interface{} "Plugin not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /plugins/{id} [get]
func (h *PluginHandler) GetPluginByID(c *gin.Context) <span class="cov3" title="3">{
        idStr := c.Param("id")
        if idStr == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "plugin ID is required"})
                return
        }</span>

        <span class="cov3" title="3">id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid plugin ID format"})
                return
        }</span>

        // Always use the standard method (subscription logic removed)
        <span class="cov2" title="2">plugin, err := h.pluginService.GetPluginByID(id)

        if err != nil </span><span class="cov1" title="1">{
                // Check if it's a "not found" error (GORM returns specific error types)
                if err.Error() == "record not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "Plugin not found"})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve plugin", "details": err.Error()})
                return</span>
        }

        <span class="cov1" title="1">c.JSON(http.StatusOK, plugin)</span>
}

// CreatePlugin handles POST /plugins
// @Summary Create a new plugin
// @Description Create a new plugin with the provided information
// @Tags plugins
// @Accept json
// @Produce json
// @Param plugin body service.CreatePluginRequest true "Plugin creation request"
// @Success 201 {object} service.PluginResponse "Successfully created plugin"
// @Failure 400 {object} map[string]interface{} "Invalid request body or validation error"
// @Failure 409 {object} map[string]interface{} "Plugin with same name already exists"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /plugins [post]
func (h *PluginHandler) CreatePlugin(c *gin.Context) <span class="cov5" title="5">{
        var req service.CreatePluginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body", "details": err.Error()})
                return
        }</span>

        <span class="cov4" title="4">plugin, err := h.pluginService.CreatePlugin(&amp;req)
        if err != nil </span><span class="cov3" title="3">{
                // Check if it's a validation error
                if validationErr, ok := err.(*service.ValidationError); ok </span><span class="cov1" title="1">{
                        c.JSON(http.StatusConflict, gin.H{"error": validationErr.Message})
                        return
                }</span>
                <span class="cov2" title="2">c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create plugin", "details": err.Error()})
                return</span>
        }

        <span class="cov1" title="1">c.JSON(http.StatusCreated, plugin)</span>
}

// UpdatePlugin handles PUT /plugins/{id}
// @Summary Update a plugin
// @Description Update an existing plugin with the provided information
// @Tags plugins
// @Accept json
// @Produce json
// @Param id path string true "Plugin ID (UUID)"
// @Param plugin body service.UpdatePluginRequest true "Plugin update request"
// @Success 200 {object} service.PluginResponse "Successfully updated plugin"
// @Failure 400 {object} map[string]interface{} "Invalid plugin ID or request body"
// @Failure 404 {object} map[string]interface{} "Plugin not found"
// @Failure 409 {object} map[string]interface{} "Plugin with same name already exists"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /plugins/{id} [put]
func (h *PluginHandler) UpdatePlugin(c *gin.Context) <span class="cov5" title="6">{
        idStr := c.Param("id")
        if idStr == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "plugin ID is required"})
                return
        }</span>

        <span class="cov5" title="6">id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid plugin ID format"})
                return
        }</span>

        <span class="cov5" title="5">var req service.UpdatePluginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body", "details": err.Error()})
                return
        }</span>

        <span class="cov4" title="4">plugin, err := h.pluginService.UpdatePlugin(id, &amp;req)
        if err != nil </span><span class="cov3" title="3">{
                // Check if it's a "not found" error
                if err.Error() == "record not found" </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "Plugin not found"})
                        return
                }</span>
                // Check if it's a validation error
                <span class="cov2" title="2">if validationErr, ok := err.(*service.ValidationError); ok </span><span class="cov1" title="1">{
                        c.JSON(http.StatusConflict, gin.H{"error": validationErr.Message})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update plugin", "details": err.Error()})
                return</span>
        }

        <span class="cov1" title="1">c.JSON(http.StatusOK, plugin)</span>
}

// DeletePlugin handles DELETE /plugins/{id}
// @Summary Delete a plugin
// @Description Delete a plugin by its ID
// @Tags plugins
// @Accept json
// @Produce json
// @Param id path string true "Plugin ID (UUID)"
// @Success 204 "Successfully deleted plugin"
// @Failure 400 {object} map[string]interface{} "Invalid plugin ID"
// @Failure 404 {object} map[string]interface{} "Plugin not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /plugins/{id} [delete]
func (h *PluginHandler) DeletePlugin(c *gin.Context) <span class="cov4" title="4">{
        idStr := c.Param("id")
        if idStr == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "plugin ID is required"})
                return
        }</span>

        <span class="cov4" title="4">id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid plugin ID format"})
                return
        }</span>

        <span class="cov3" title="3">err = h.pluginService.DeletePlugin(id)
        if err != nil </span><span class="cov2" title="2">{
                // Check if it's a "not found" error
                if err.Error() == "record not found" </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "Plugin not found"})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete plugin", "details": err.Error()})
                return</span>
        }

        <span class="cov1" title="1">c.Status(http.StatusNoContent)</span>
}

// GetPluginUI handles GET /plugins/{id}/ui
// @Summary Get plugin UI content
// @Description Retrieve the TSX React component content from GitHub for a specific plugin
// @Tags plugins
// @Accept json
// @Produce json
// @Param id path string true "Plugin ID (UUID)"
// @Success 200 {object} service.PluginUIResponse "Successfully retrieved plugin UI content"
// @Failure 400 {object} map[string]interface{} "Invalid plugin ID"
// @Failure 404 {object} map[string]interface{} "Plugin not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /plugins/{id}/ui [get]
func (h *PluginHandler) GetPluginUI(c *gin.Context) <span class="cov5" title="6">{
        idStr := c.Param("id")
        if idStr == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "plugin ID is required"})
                return
        }</span>

        <span class="cov5" title="6">id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid plugin ID format"})
                return
        }</span>

        // Check if GitHub service is available
        <span class="cov5" title="5">if h.githubService == nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "GitHub service not available"})
                return
        }</span>

        // Extract user claims from authentication context
        // This follows the same pattern as other GitHub endpoints in the codebase
        <span class="cov4" title="4">claimsInterface, exists := c.Get("auth_claims")
        if !exists </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                return
        }</span>

        <span class="cov3" title="3">claims, ok := claimsInterface.(*auth.AuthClaims)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid authentication claims"})
                return
        }</span>

        // Default to "githubtools" provider - this could be made configurable
        <span class="cov3" title="3">provider := c.DefaultQuery("provider", "githubtools")

        // Get plugin UI content
        uiContent, err := h.pluginService.GetPluginUIContent(c.Request.Context(), id, h.githubService, claims.UUID, provider)
        if err != nil </span><span class="cov2" title="2">{
                // Check if it's a "not found" error
                if err.Error() == "record not found" </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "Plugin not found"})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve plugin UI content", "details": err.Error()})
                return</span>
        }

        <span class="cov1" title="1">c.JSON(http.StatusOK, uiContent)</span>
}

// ProxyPluginBackend handles GET /plugins/{id}/proxy?path={targetPath}
// @Summary Proxy requests to plugin backend
// @Description Proxy requests to plugin backend server with 30-second timeout, caching (5 minutes for successful GET responses), and standardized response format. Always returns 200 OK with metadata including actual backend status, response time, and success flag.
// @Tags plugins
// @Accept json
// @Produce json
// @Param id path string true "Plugin ID (UUID)" format(uuid)
// @Param path query string true "Target path to proxy to plugin backend (e.g., /api/health, /api/status)"
// @Success 200 {object} object{data=object,responseTime=int,statusCode=int,pluginSuccess=bool,error=string} "Proxy response with metadata - always returns 200 OK regardless of backend status"
// @Failure 400 {object} ErrorResponse "Invalid plugin ID format or missing path parameter"
// @Failure 404 {object} ErrorResponse "Plugin not found"
// @Failure 500 {object} ErrorResponse "Internal server error (e.g., database connection issues)"
// @Security BearerAuth
// @Router /plugins/{id}/proxy [get]
func (h *PluginHandler) ProxyPluginBackend(c *gin.Context) <span class="cov5" title="7">{
        idStr := c.Param("id")
        if idStr == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "plugin ID is required"})
                return
        }</span>

        <span class="cov5" title="7">id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid plugin ID format"})
                return
        }</span>

        <span class="cov5" title="6">targetPath := c.Query("path")
        if targetPath == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "path parameter is required"})
                return
        }</span>

        // Create cache key from plugin ID and target path
        <span class="cov5" title="5">cacheKey := fmt.Sprintf("%s:%s", id.String(), targetPath)

        // Check cache first (only for GET requests)
        if c.Request.Method == "GET" </span><span class="cov5" title="5">{
                h.cacheMux.RLock()
                if cached, exists := h.proxyCache[cacheKey]; exists </span><span class="cov1" title="1">{
                        if time.Now().Before(cached.expiresAt) </span><span class="cov1" title="1">{
                                h.cacheMux.RUnlock()
                                log.Printf("Cache hit for plugin proxy: %s", cacheKey)
                                c.JSON(http.StatusOK, cached.response)
                                return
                        }</span>
                }
                <span class="cov4" title="4">h.cacheMux.RUnlock()</span>
        }

        // Get the plugin to retrieve backend server URL
        <span class="cov4" title="4">plugin, err := h.pluginService.GetPluginByID(id)
        if err != nil </span><span class="cov1" title="1">{
                if err.Error() == "record not found" </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "Plugin not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve plugin", "details": err.Error()})
                return</span>
        }

        // Construct the target URL
        <span class="cov3" title="3">backendURL := plugin.BackendServerURL
        if !strings.HasSuffix(backendURL, "/") &amp;&amp; !strings.HasPrefix(targetPath, "/") </span><span class="cov0" title="0">{
                backendURL += "/"
        }</span>
        <span class="cov3" title="3">targetURL := backendURL + targetPath

        // Log the request
        log.Printf("Proxying request to plugin backend: %s -&gt; %s", c.Request.URL.String(), targetURL)

        // Create HTTP client with 30-second timeout
        client := &amp;http.Client{
                Timeout: 30 * time.Second,
        }

        // Make request to plugin backend
        startTime := time.Now()
        resp, err := client.Get(targetURL)
        responseTime := time.Since(startTime).Milliseconds()

        // Prepare response structure
        response := map[string]interface{}{
                "responseTime": responseTime,
        }

        if err != nil </span><span class="cov0" title="0">{
                response["statusCode"] = 200
                response["pluginSuccess"] = false
                response["error"] = fmt.Sprintf("Failed to fetch from plugin backend: %s", err.Error())

                log.Printf("Plugin backend request failed: %s - %v", targetURL, err)
                c.JSON(http.StatusOK, response)
                return
        }</span>
        <span class="cov3" title="3">defer resp.Body.Close()

        // Read response body
        var result interface{}
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                response["statusCode"] = resp.StatusCode
                response["pluginSuccess"] = false
                response["error"] = "Invalid JSON response from plugin backend"

                log.Printf("Plugin backend returned invalid JSON: %s - %v", targetURL, err)
                c.JSON(http.StatusOK, response)
                return
        }</span>

        // Set response data
        <span class="cov3" title="3">response["data"] = result
        response["statusCode"] = resp.StatusCode
        response["pluginSuccess"] = resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 300

        if !response["pluginSuccess"].(bool) </span><span class="cov1" title="1">{
                response["error"] = fmt.Sprintf("Plugin backend returned error status: %d", resp.StatusCode)
                log.Printf("Plugin backend returned error status: %s - %d", targetURL, resp.StatusCode)
        }</span> else<span class="cov2" title="2"> {
                log.Printf("Plugin backend request successful: %s - %d (%dms)", targetURL, resp.StatusCode, responseTime)

                // Cache successful GET responses for 5 minutes
                if c.Request.Method == "GET" </span><span class="cov2" title="2">{
                        h.cacheMux.Lock()
                        h.proxyCache[cacheKey] = &amp;pluginProxyCache{
                                response:  response,
                                expiresAt: time.Now().Add(5 * time.Minute),
                        }
                        h.cacheMux.Unlock()
                        log.Printf("Cached plugin proxy response: %s", cacheKey)
                }</span>
        }

        // Always return 200 OK with metadata
        <span class="cov3" title="3">c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strings"

        "developer-portal-backend/internal/service"

        "github.com/gin-gonic/gin"
)

// ProjectHandler handles HTTP requests for project operations
type ProjectHandler struct {
        projectService service.ProjectServiceInterface
}

// NewProjectHandler creates a new project handler
func NewProjectHandler(projectService service.ProjectServiceInterface) *ProjectHandler <span class="cov10" title="8">{
        return &amp;ProjectHandler{
                projectService: projectService,
        }
}</span>

// Project represents the structure of a project (local struct)
type Project struct {
        ID          string                 `json:"id"`
        Name        string                 `json:"name"`
        Title       string                 `json:"title"`
        Description string                 `json:"description"`
        Metadata    map[string]interface{} `json:"metadata"`
}

// ProjectResponse represents a trimmed project projection for list endpoints
type ProjectResponse struct {
        ID          string `json:"id"`
        Name        string `json:"name"`
        Title       string `json:"title"`
        Description string `json:"description"`
        // Enriched fields extracted from metadata
        Alerts            string `json:"alerts,omitempty"`
        Views             string `json:"views,omitempty"`
        ComponentsMetrics bool   `json:"components-metrics"`
}

// GetAllProjects handles GET /projects
func (h *ProjectHandler) GetAllProjects(c *gin.Context) <span class="cov9" title="7">{
        serviceProjects, err := h.projectService.GetAllProjects()
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="6">var responses []ProjectResponse
        for _, sp := range serviceProjects </span><span class="cov7" title="5">{
                // Unmarshal Metadata from json.RawMessage to map[string]interface{}
                var metadata map[string]interface{}
                if len(sp.Metadata) &gt; 0 </span><span class="cov7" title="5">{
                        if err := json.Unmarshal(sp.Metadata, &amp;metadata); err != nil </span><span class="cov0" title="0">{
                                metadata = map[string]interface{}{} // fallback if unmarshal fails
                        }</span>
                } else<span class="cov0" title="0"> {
                        metadata = map[string]interface{}{}
                }</span>

                <span class="cov7" title="5">alerts, _ := metadata["alerts"].(string)
                componentsMetrics, _ := metadata["components-metrics"].(bool)

                // Extract views from metadata.views (array) and join with commas
                rawViews, _ := metadata["views"].([]interface{})
                views := make([]string, 0, len(rawViews))
                for _, v := range rawViews </span><span class="cov4" title="2">{
                        if s, ok := v.(string); ok </span><span class="cov4" title="2">{
                                views = append(views, s)
                        }</span>
                }
                <span class="cov7" title="5">viewsStr := strings.Join(views, ",")

                response := ProjectResponse{
                        ID:                sp.ID.String(),
                        Name:              sp.Name,
                        Title:             sp.Title,
                        Description:       sp.Description,
                        Alerts:            alerts,
                        Views:             viewsStr,
                        ComponentsMetrics: componentsMetrics,
                }

                responses = append(responses, response)</span>
        }

        <span class="cov8" title="6">c.JSON(http.StatusOK, responses)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package handlers

import (
        "developer-portal-backend/internal/errors"
        "net/http"

        "developer-portal-backend/internal/service"

        "github.com/gin-gonic/gin"
)

// SonarHandler handles Sonar-related HTTP requests
type SonarHandler struct {
        service service.SonarServiceInterface
}

// NewSonarHandler creates a new Sonar handler
func NewSonarHandler(s service.SonarServiceInterface) *SonarHandler <span class="cov10" title="5">{
        return &amp;SonarHandler{service: s}
}</span>

// GetMeasures merges Sonar measures and quality gate status for a given component (project key).
// @Summary Get Sonar measures and quality gate status
// @Description Calls Sonar APIs to retrieve measures (coverage, vulnerabilities, code_smells) and quality gate status for the given component key, merges them and returns as JSON.
// @Tags sonar
// @Produce json
// @Param component query string true "Sonar project key"
// @Success 200 {object} service.SonarCombinedResponse
// @Failure 400 {object} map[string]string "Missing or invalid query parameter"
// @Failure 502 {object} map[string]string "Sonar request failed"
// @Security BearerAuth
// @Router /sonar/measures [get]
func (h *SonarHandler) GetMeasures(c *gin.Context) <span class="cov10" title="5">{
        component := c.Query("component")
        if component == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": errors.NewMissingQueryParam("component").Error()})
                return
        }</span>

        <span class="cov8" title="4">resp, err := h.service.GetComponentMeasures(component)
        if err != nil </span><span class="cov4" title="2">{
                c.JSON(http.StatusBadGateway, gin.H{"error": "sonar request failed: " + err.Error()})
                return
        }</span>

        <span class="cov4" title="2">c.JSON(http.StatusOK, resp)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package handlers

import (
        "encoding/json"
        "errors"
        "net/http"

        "developer-portal-backend/internal/auth"
        apperrors "developer-portal-backend/internal/errors"
        "developer-portal-backend/internal/service"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// TeamHandler handles HTTP requests for team operations
type TeamHandler struct {
        teamService service.TeamServiceInterface
}

// NewTeamHandler creates a new team handler
func NewTeamHandler(teamService service.TeamServiceInterface) *TeamHandler <span class="cov10" title="19">{
        return &amp;TeamHandler{
                teamService: teamService,
        }
}</span>

// GetAllTeams handles GET /teams with optional team-name or team-id filters
// @Summary List teams or fetch a specific team by name/ID
// @Description
// - Without query: returns a list of teams (id, group_id, name, title, description, picture_url)
// - With team-id (UUID): returns a single team enriched with members and links (and jira_team extracted from metadata)
// - With team-name (string): same as team-id variant, by simple name (global)
// @Tags teams
// @Accept json
// @Produce json
// @Param team-name query string false "Team simple name; when provided returns team with members and links"
// @Param team-id query string false "Team ID (UUID); when provided returns team with members and links"
// @Success 200 {object} map[string]interface{} "Teams list or single team response"
// @Failure 400 {object} map[string]interface{} "Invalid parameters"
// @Failure 404 {object} map[string]interface{} "Team not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /teams [get]
func (h *TeamHandler) GetAllTeams(c *gin.Context) <span class="cov8" title="11">{
        // 1) team-id branch: resolve ID -&gt; name, then return enriched team by name
        if teamIDStr := c.Query("team-id"); teamIDStr != "" </span><span class="cov5" title="5">{
                id, err := uuid.Parse(teamIDStr)
                if err != nil </span><span class="cov1" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid team ID"})
                        return
                }</span>
                <span class="cov5" title="4">team, err := h.teamService.GetByID(id)
                if err != nil </span><span class="cov3" title="2">{
                        if errors.Is(err, apperrors.ErrTeamNotFound) </span><span class="cov1" title="1">{
                                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                                return
                        }</span>
                        <span class="cov1" title="1">c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return</span>
                }

                // Use name-based retrieval to enrich with members and links, marking favorites for viewer when available
                <span class="cov3" title="2">viewerName, _ := auth.GetUsername(c)
                var teamWithMembers *service.TeamWithMembersResponse
                if viewerName != "" </span><span class="cov1" title="1">{
                        teamWithMembers, err = h.teamService.GetBySimpleNameWithViewer(team.Name, viewerName)
                }</span> else<span class="cov1" title="1"> {
                        teamWithMembers, err = h.teamService.GetBySimpleName(team.Name)
                }</span>
                <span class="cov3" title="2">if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, apperrors.ErrTeamNotFound) </span><span class="cov0" title="0">{
                                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                                return
                        }</span>
                        <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return</span>
                }

                // Transform response: extract metadata.jira.team into jira_team and parse metadata for response
                <span class="cov3" title="2">var jiraTeam string
                var metadata map[string]interface{}
                if len(teamWithMembers.TeamResponse.Metadata) &gt; 0 </span><span class="cov3" title="2">{
                        if err := json.Unmarshal(teamWithMembers.TeamResponse.Metadata, &amp;metadata); err == nil &amp;&amp; metadata != nil </span><span class="cov3" title="2">{
                                if jiraVal, ok := metadata["jira"].(map[string]interface{}); ok &amp;&amp; jiraVal != nil </span><span class="cov3" title="2">{
                                        if jt, ok := jiraVal["team"].(string); ok </span><span class="cov3" title="2">{
                                                jiraTeam = jt
                                        }</span>
                                }
                        }
                }
                <span class="cov3" title="2">resp := gin.H{
                        "id":              teamWithMembers.TeamResponse.ID,
                        "group_id":        teamWithMembers.TeamResponse.GroupID,
                        "organization_id": teamWithMembers.TeamResponse.OrganizationID,
                        "name":            teamWithMembers.TeamResponse.Name,
                        "title":           teamWithMembers.TeamResponse.Title,
                        "description":     teamWithMembers.TeamResponse.Description,
                        "owner":           teamWithMembers.TeamResponse.Owner,
                        "email":           teamWithMembers.TeamResponse.Email,
                        "picture_url":     teamWithMembers.TeamResponse.PictureURL,
                        "created_at":      teamWithMembers.TeamResponse.CreatedAt,
                        "updated_at":      teamWithMembers.TeamResponse.UpdatedAt,
                        "jira_team":       jiraTeam,
                        "metadata":        metadata,
                        "members":         teamWithMembers.Members,
                        "links":           teamWithMembers.Links,
                }
                c.JSON(http.StatusOK, resp)
                return</span>
        }

        // 2) team-name branch: return enriched team by simple name (global)
        <span class="cov6" title="6">if teamName := c.Query("team-name"); teamName != "" </span><span class="cov5" title="4">{
                viewerName, _ := auth.GetUsername(c)
                var teamWithMembers *service.TeamWithMembersResponse
                var err error
                if viewerName != "" </span><span class="cov1" title="1">{
                        teamWithMembers, err = h.teamService.GetBySimpleNameWithViewer(teamName, viewerName)
                }</span> else<span class="cov4" title="3"> {
                        teamWithMembers, err = h.teamService.GetBySimpleName(teamName)
                }</span>
                <span class="cov5" title="4">if err != nil </span><span class="cov3" title="2">{
                        if errors.Is(err, apperrors.ErrTeamNotFound) </span><span class="cov1" title="1">{
                                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                                return
                        }</span>
                        <span class="cov1" title="1">c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return</span>
                }

                // Transform: extract metadata.jira.team into jira_team and parse metadata for response
                <span class="cov3" title="2">var jiraTeam string
                var metadata map[string]interface{}
                if len(teamWithMembers.TeamResponse.Metadata) &gt; 0 </span><span class="cov3" title="2">{
                        if err := json.Unmarshal(teamWithMembers.TeamResponse.Metadata, &amp;metadata); err == nil &amp;&amp; metadata != nil </span><span class="cov3" title="2">{
                                if jiraVal, ok := metadata["jira"].(map[string]interface{}); ok &amp;&amp; jiraVal != nil </span><span class="cov3" title="2">{
                                        if jt, ok := jiraVal["team"].(string); ok </span><span class="cov3" title="2">{
                                                jiraTeam = jt
                                        }</span>
                                }
                        }
                }
                <span class="cov3" title="2">resp := gin.H{
                        "id":              teamWithMembers.TeamResponse.ID,
                        "group_id":        teamWithMembers.TeamResponse.GroupID,
                        "organization_id": teamWithMembers.TeamResponse.OrganizationID,
                        "name":            teamWithMembers.TeamResponse.Name,
                        "title":           teamWithMembers.TeamResponse.Title,
                        "description":     teamWithMembers.TeamResponse.Description,
                        "owner":           teamWithMembers.TeamResponse.Owner,
                        "email":           teamWithMembers.TeamResponse.Email,
                        "picture_url":     teamWithMembers.TeamResponse.PictureURL,
                        "created_at":      teamWithMembers.TeamResponse.CreatedAt,
                        "updated_at":      teamWithMembers.TeamResponse.UpdatedAt,
                        "jira_team":       jiraTeam,
                        "metadata":        metadata,
                        "members":         teamWithMembers.Members,
                        "links":           teamWithMembers.Links,
                }
                c.JSON(http.StatusOK, resp)
                return</span>
        }

        // 3) Default: list teams (global)
        <span class="cov3" title="2">teams, err := h.teamService.GetAllTeams(nil, 1, 1000)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">items := make([]gin.H, 0, len(teams.Teams))
        for _, t := range teams.Teams </span><span class="cov1" title="1">{
                // Parse metadata to include in response
                var metadata map[string]interface{}
                if len(t.Metadata) &gt; 0 </span><span class="cov0" title="0">{
                        _ = json.Unmarshal(t.Metadata, &amp;metadata)
                }</span>

                <span class="cov1" title="1">items = append(items, gin.H{
                        "id":          t.ID,
                        "group_id":    t.GroupID,
                        "name":        t.Name,
                        "title":       t.Title,
                        "description": t.Description,
                        "picture_url": t.PictureURL,
                        "metadata":    metadata,
                })</span>
        }
        <span class="cov1" title="1">response := gin.H{
                "teams":     items,
                "total":     teams.Total,
                "page":      teams.Page,
                "page_size": teams.PageSize,
        }
        c.JSON(http.StatusOK, response)</span>
}

// UpdateTeamMetadataRequest represents a request to update team metadata
type UpdateTeamMetadataRequest struct {
        Metadata map[string]interface{} `json:"metadata" binding:"required"`
}

// UpdateTeamMetadata handles PATCH /teams/:id/metadata
// @Summary Update team metadata (merge, not replace)
// @Description Merges the provided metadata fields with existing team metadata. Only updates/adds the fields provided, preserves other existing fields (e.g., updating color preserves jira config)
// @Tags teams
// @Accept json
// @Produce json
// @Param id path string true "Team ID (UUID)"
// @Param request body UpdateTeamMetadataRequest true "Metadata fields to update/add"
// @Success 200 {object} map[string]interface{} "Updated team with merged metadata"
// @Failure 400 {object} map[string]interface{} "Invalid request"
// @Failure 404 {object} map[string]interface{} "Team not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /teams/{id}/metadata [patch]
func (h *TeamHandler) UpdateTeamMetadata(c *gin.Context) <span class="cov7" title="8">{
        teamIDStr := c.Param("id")
        teamID, err := uuid.Parse(teamIDStr)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid team ID"})
                return
        }</span>

        <span class="cov6" title="7">var req UpdateTeamMetadataRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov3" title="2">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Convert metadata map to JSON
        <span class="cov5" title="5">metadataJSON, err := json.Marshal(req.Metadata)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid metadata format"})
                return
        }</span>

        // Update team metadata via service
        <span class="cov5" title="5">updatedTeam, err := h.teamService.UpdateTeamMetadata(teamID, metadataJSON)
        if err != nil </span><span class="cov3" title="2">{
                if errors.Is(err, apperrors.ErrTeamNotFound) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return</span>
        }

        // Parse metadata back for response
        <span class="cov4" title="3">var metadata map[string]interface{}
        if len(updatedTeam.Metadata) &gt; 0 </span><span class="cov4" title="3">{
                _ = json.Unmarshal(updatedTeam.Metadata, &amp;metadata)
        }</span>

        <span class="cov4" title="3">c.JSON(http.StatusOK, gin.H{
                "id":          updatedTeam.ID,
                "name":        updatedTeam.Name,
                "title":       updatedTeam.Title,
                "description": updatedTeam.Description,
                "metadata":    metadata,
                "updated_at":  updatedTeam.UpdatedAt,
        })</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package handlers

import (
        "developer-portal-backend/internal/auth"
        "developer-portal-backend/internal/database/models"
        "developer-portal-backend/internal/service"
        "errors"
        "net/http"
        "strconv"

        apperrors "developer-portal-backend/internal/errors"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// UserHandler handles HTTP requests for users (members endpoints removed)
type UserHandler struct {
        memberService service.UserServiceInterface
        teamService   service.TeamServiceInterface
}

// NewUserHandler creates a new user handler
func NewUserHandler(memberService service.UserServiceInterface, teamService service.TeamServiceInterface) *UserHandler <span class="cov10" title="20">{
        return &amp;UserHandler{
                memberService: memberService,
                teamService:   teamService,
        }
}</span>

// CreateUserBody represents the expected request body for POST /users
type CreateUserBody struct {
        ID         string    `json:"id" binding:"required,min=5,max=20"`
        FirstName  string    `json:"first_name" binding:"required,max=100"`
        LastName   string    `json:"last_name" binding:"required,max=100"`
        Email      string    `json:"email" binding:"required,email,max=255"`
        Mobile     string    `json:"mobile"`      // optional
        TeamDomain *string   `json:"team_domain"` // optional, defaults to 'developer' if omitted
        TeamRole   *string   `json:"team_role"`   // optional, defaults to 'member' if omitted
        TeamID     uuid.UUID `json:"team_id" binding:"required"`
}

// CreateUser handles POST /users
// @Summary Create a new user
// @Description Create a new user row in users table
// @Description Optional fields: team_domain (default 'developer'), team_role (default 'member')
// @Description created_by is derived from the bearer token 'username' claim and is NOT required in the payload
// @Tags users
// @Accept json
// @Produce json
// @Param user body CreateUserBody true "User data"
// @Success 201 {object} service.UserResponse "Successfully created user"
// @Failure 400 {object} map[string]interface{} "Invalid request body"
// @Security BearerAuth
// @Router /users [post]
func (h *UserHandler) CreateUser(c *gin.Context) <span class="cov5" title="4">{
        var body CreateUserBody
        if err := c.ShouldBindJSON(&amp;body); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Validate team_id exists
        <span class="cov5" title="4">if _, err := h.teamService.GetByID(body.TeamID); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid team_id"})
                return
        }</span>

        // Validate team_domain against allowed values (optional; default handled in service)
        <span class="cov4" title="3">if body.TeamDomain != nil </span><span class="cov3" title="2">{
                switch models.TeamDomain(*body.TeamDomain) </span>{
                case models.TeamDomainDeveloper, models.TeamDomainDevOps, models.TeamDomainPO, models.TeamDomainArchitect:<span class="cov1" title="1"></span>
                        // ok
                default:<span class="cov1" title="1">
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid team_domain"})
                        return</span>
                }
        }

        // Validate team_role against allowed values (optional; default handled in service)
        <span class="cov3" title="2">if body.TeamRole != nil </span><span class="cov1" title="1">{
                switch models.TeamRole(*body.TeamRole) </span>{
                case models.TeamRoleMember, models.TeamRoleScM, models.TeamRoleManager, models.TeamRoleMMM:<span class="cov1" title="1"></span>
                        // ok
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid team_role"})
                        return</span>
                }
        }

        <span class="cov3" title="2">req := service.CreateUserRequest{
                TeamID:    &amp;body.TeamID,
                FirstName: body.FirstName,
                LastName:  body.LastName,
                Email:     body.Email,
                Mobile:    body.Mobile,
                IUser:     body.ID,
        }
        if body.TeamDomain != nil </span><span class="cov1" title="1">{
                role := *body.TeamDomain
                req.Role = &amp;role
        }</span>
        <span class="cov3" title="2">if body.TeamRole != nil </span><span class="cov1" title="1">{
                tr := *body.TeamRole
                req.TeamRole = &amp;tr
        }</span>

        // Populate created_by from bearer token username
        <span class="cov3" title="2">if username, ok := auth.GetUsername(c); ok &amp;&amp; username != "" </span><span class="cov1" title="1">{
                req.CreatedBy = username
        }</span> else<span class="cov1" title="1"> {
                c.JSON(http.StatusUnauthorized, gin.H{"error": "missing username in token"})
                return
        }</span>

        <span class="cov1" title="1">user, err := h.memberService.CreateUser(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusCreated, user)</span>
}

// GetMemberByUserID retrieves a user by UserID string (I/C/D ID)
// @Summary Get user by UserID
// @Description Get a specific user by their UserID (e.g., I123456)
// @Tags users
// @Accept json
// @Produce json
// @Param user_id path string true "UserID (I/C/D)"
// @Success 200 {object} service.UserWithLinksAndPluginsResponse "Successfully retrieved user"
// @Failure 400 {object} map[string]interface{} "Invalid user_id"
// @Failure 404 {object} map[string]interface{} "User not found"
// @Security BearerAuth
// @Router /users/{user_id} [get]
func (h *UserHandler) GetMemberByUserID(c *gin.Context) <span class="cov3" title="2">{
        userID := c.Param("user_id")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "user_id is required"})
                return
        }</span>

        <span class="cov3" title="2">member, err := h.memberService.GetUserByUserIDWithLinks(userID)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, member)</span>
}

// ListUsers retrieves all users with pagination
// @Summary List users
// @Description Get all users with pagination
// @Tags users
// @Accept json
// @Produce json
// @Param limit query int false "Number of items to return" default(20)
// @Param offset query int false "Number of items to skip" default(0)
// @Param q query string false "Search query by name or title (case-insensitive)"
// @Success 200 {object} service.UsersListResponse "Successfully retrieved users list"
// @Failure 400 {object} map[string]interface{} "Invalid parameters"
// @Security BearerAuth
// @Router /users [get]
func (h *UserHandler) ListUsers(c *gin.Context) <span class="cov4" title="3">{
        // If user-name query param is provided, return the user by name (with links)
        if userName := c.Query("user-name"); userName != "" </span><span class="cov1" title="1">{
                user, err := h.memberService.GetUserByNameWithLinks(userName)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusOK, user)
                return</span>
        }

        // Otherwise, list users with pagination
        <span class="cov3" title="2">limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))

        // If 'q' is provided, perform global search by name or title
        if q := c.Query("q"); q != "" </span><span class="cov1" title="1">{
                users, total, err := h.memberService.SearchUsersGlobal(q, limit, offset)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{
                        "users":  users,
                        "total":  total,
                        "limit":  limit,
                        "offset": offset,
                })
                return</span>
        }

        <span class="cov1" title="1">users, total, err := h.memberService.GetAllUsers(limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{
                "users":  users,
                "total":  total,
                "limit":  limit,
                "offset": offset,
        })</span>
}

// GetCurrentUser handles GET /users/me
// @Summary Get current user
// @Description Returns the user matching the bearer token 'username' claim, mapped to users.name
// @Tags users
// @Produce json
// @Success 200 {object} service.UserWithLinksAndPluginsResponse "Successfully retrieved current user"
// @Failure 401 {object} map[string]interface{} "Missing username in token"
// @Failure 404 {object} map[string]interface{} "User not found"
// @Security BearerAuth
// @Router /users/me [get]
func (h *UserHandler) GetCurrentUser(c *gin.Context) <span class="cov3" title="2">{
        username, ok := auth.GetUsername(c)
        if !ok || username == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "missing username in token"})
                return
        }</span>
        <span class="cov1" title="1">user, err := h.memberService.GetUserByNameWithLinksAndPlugins(username)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
                return
        }</span>
        <span class="cov1" title="1">c.JSON(http.StatusOK, user)</span>
}

// UpdateUserTeamBody represents the expected request body for PUT /users
type UpdateUserTeamBody struct {
        UserUUID    string `json:"user_uuid" binding:"required"`
        NewTeamUUID string `json:"new_team_uuid" binding:"required"`
}

// UpdateUserTeam handles PUT /users
// @Summary Update user's team
// @Description Update the user's team by UUID. Sets updated_by from token; updated_at is automatic.
// @Tags users
// @Accept json
// @Produce json
// @Param body body UpdateUserTeamBody true "Update user's team payload"
// @Success 200 {object} service.UserResponse "Successfully updated user's team"
// @Failure 400 {object} map[string]interface{} "Invalid request body or UUIDs"
// @Failure 401 {object} map[string]interface{} "Missing username in token"
// @Failure 404 {object} map[string]interface{} "User not found"
// @Security BearerAuth
// @Router /users [put]
func (h *UserHandler) UpdateUserTeam(c *gin.Context) <span class="cov5" title="5">{
        var body UpdateUserTeamBody
        if err := c.ShouldBindJSON(&amp;body); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov5" title="5">userID, err := uuid.Parse(body.UserUUID)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid user_uuid"})
                return
        }</span>
        <span class="cov5" title="4">teamID, err := uuid.Parse(body.NewTeamUUID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid new_team_uuid"})
                return
        }</span>

        // Validate team exists
        <span class="cov5" title="4">if _, err := h.teamService.GetByID(teamID); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid new_team_uuid"})
                return
        }</span>

        // Get username from token for audit
        <span class="cov4" title="3">username, ok := auth.GetUsername(c)
        if !ok || username == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "missing username in token"})
                return
        }</span>

        <span class="cov3" title="2">user, err := h.memberService.UpdateUserTeam(userID, teamID, username)
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, apperrors.ErrUserNotFound) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return</span>
        }

        <span class="cov1" title="1">c.JSON(http.StatusOK, user)</span>
}

// AddFavoriteLink handles POST /users/:user_id/favorites/:link_id
// @Summary Add a favorite link to a user
// @Description Adds the given link_id to the user's metadata.favorites array. Initializes metadata and favorites if missing, and avoids duplicates.
// @Tags users
// @Accept json
// @Produce json
// @Param user_id path string true "User ID (I/C/D user id, e.g. cis.devops)"
// @Param link_id path string true "Link ID (UUID)"
// @Success 200 {object} service.UserResponse "Successfully added favorite link"
// @Failure 400 {object} map[string]interface{} "Invalid user_id or link_id"
// @Failure 404 {object} map[string]interface{} "User not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /users/{user_id}/favorites/{link_id} [post]
func (h *UserHandler) AddFavoriteLink(c *gin.Context) <span class="cov4" title="3">{
        userID := c.Param("user_id")
        linkIDStr := c.Param("link_id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "user_id is required"})
                return
        }</span>
        <span class="cov4" title="3">linkID, err := uuid.Parse(linkIDStr)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid link_id"})
                return
        }</span>

        <span class="cov3" title="2">user, err := h.memberService.AddFavoriteLinkByUserID(userID, linkID)
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, apperrors.ErrUserNotFound) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to add favorite", "details": err.Error()})
                return</span>
        }

        <span class="cov1" title="1">c.JSON(http.StatusOK, user)</span>
}

// RemoveFavoriteLink handles DELETE /users/:user_id/favorites/:link_id
// @Summary Remove a favorite link from a user
// @Description Removes the given link_id from the user's metadata.favorites array. Initializes metadata if missing. Idempotent if link not present.
// @Tags users
// @Accept json
// @Produce json
// @Param user_id path string true "User ID (I/C/D user id, e.g. cis.devops)"
// @Param link_id path string true "Link ID (UUID)"
// @Success 200 {object} service.UserResponse "Successfully removed favorite link"
// @Failure 400 {object} map[string]interface{} "Invalid user_id or link_id"
// @Failure 404 {object} map[string]interface{} "User not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /users/{user_id}/favorites/{link_id} [delete]
func (h *UserHandler) RemoveFavoriteLink(c *gin.Context) <span class="cov1" title="1">{
        userID := c.Param("user_id")
        linkIDStr := c.Param("link_id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "user_id is required"})
                return
        }</span>
        <span class="cov1" title="1">linkID, err := uuid.Parse(linkIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid link_id"})
                return
        }</span>

        <span class="cov1" title="1">user, err := h.memberService.RemoveFavoriteLinkByUserID(userID, linkID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, apperrors.ErrUserNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to remove favorite", "details": err.Error()})
                return</span>
        }

        <span class="cov1" title="1">c.JSON(http.StatusOK, user)</span>
}

// AddSubscribedPlugin handles POST /users/:user_id/subscribed/:plugin_id and POST /users/:user_id/plugins/:plugin_id
// @Summary Add a subscribed plugin to a user
// @Description Adds the given plugin_id to the user's metadata.subscribed array. Initializes metadata and subscribed if missing, and avoids duplicates.
// @Tags users
// @Accept json
// @Produce json
// @Param user_id path string true "User ID (I/C/D user id, e.g. cis.devops)"
// @Param plugin_id path string true "Plugin ID (UUID)"
// @Success 200 {object} service.UserResponse "Successfully added subscribed plugin"
// @Failure 400 {object} map[string]interface{} "Invalid user_id or plugin_id"
// @Failure 404 {object} map[string]interface{} "User not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /users/{user_id}/subscribed/{plugin_id} [post]
// @Router /users/{user_id}/plugins/{plugin_id} [post]
func (h *UserHandler) AddSubscribedPlugin(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("user_id")
        pluginIDStr := c.Param("plugin_id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "user_id is required"})
                return
        }</span>
        <span class="cov0" title="0">pluginID, err := uuid.Parse(pluginIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid plugin_id"})
                return
        }</span>

        <span class="cov0" title="0">user, err := h.memberService.AddSubscribedPluginByUserID(userID, pluginID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, apperrors.ErrUserNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to add subscribed plugin", "details": err.Error()})
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, user)</span>
}

// RemoveSubscribedPlugin handles DELETE /users/:user_id/subscribed/:plugin_id and DELETE /users/:user_id/plugins/:plugin_id
// @Summary Remove a subscribed plugin from a user
// @Description Removes the given plugin_id from the user's metadata.subscribed array. Initializes metadata if missing. Idempotent if plugin not present.
// @Tags users
// @Accept json
// @Produce json
// @Param user_id path string true "User ID (I/C/D user id, e.g. cis.devops)"
// @Param plugin_id path string true "Plugin ID (UUID)"
// @Success 200 {object} service.UserResponse "Successfully removed subscribed plugin"
// @Failure 400 {object} map[string]interface{} "Invalid user_id or plugin_id"
// @Failure 404 {object} map[string]interface{} "User not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /users/{user_id}/subscribed/{plugin_id} [delete]
// @Router /users/{user_id}/plugins/{plugin_id} [delete]
func (h *UserHandler) RemoveSubscribedPlugin(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("user_id")
        pluginIDStr := c.Param("plugin_id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "user_id is required"})
                return
        }</span>
        <span class="cov0" title="0">pluginID, err := uuid.Parse(pluginIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid plugin_id"})
                return
        }</span>

        <span class="cov0" title="0">user, err := h.memberService.RemoveSubscribedPluginByUserID(userID, pluginID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, apperrors.ErrUserNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to remove subscribed plugin", "details": err.Error()})
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, user)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package middleware

import (
        "net/http"

        "developer-portal-backend/internal/config"

        "github.com/gin-gonic/gin"
)

// CORS returns a middleware that handles Cross-Origin Resource Sharing
func CORS(cfg *config.Config) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                origin := c.Request.Header.Get("Origin")

                // Check if origin is allowed
                allowed := false
                for _, allowedOrigin := range cfg.AllowedOrigins </span><span class="cov0" title="0">{
                        if allowedOrigin == "*" || allowedOrigin == origin </span><span class="cov0" title="0">{
                                allowed = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if allowed </span><span class="cov0" title="0">{
                        c.Header("Access-Control-Allow-Origin", origin)
                }</span>

                <span class="cov0" title="0">c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, PATCH, DELETE, OPTIONS")
                c.Header("Access-Control-Allow-Headers", "Origin, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
                c.Header("Access-Control-Allow-Credentials", "true")
                c.Header("Access-Control-Max-Age", "86400")

                // Handle preflight requests
                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusNoContent)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package middleware

import (
        "time"

        "github.com/gin-gonic/gin"
        "github.com/sirupsen/logrus"
)

// Logger returns a gin.HandlerFunc (middleware) that logs requests using logrus
func Logger() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string </span><span class="cov0" title="0">{
                // Create structured log entry
                logrus.WithFields(logrus.Fields{
                        "status_code": param.StatusCode,
                        "latency":     param.Latency,
                        "client_ip":   param.ClientIP,
                        "method":      param.Method,
                        "path":        param.Path,
                        "user_agent":  param.Request.UserAgent(),
                        "error":       param.ErrorMessage,
                        "body_size":   param.BodySize,
                        "timestamp":   param.TimeStamp.Format(time.RFC3339),
                }).Info("HTTP Request")

                return ""
        }</span>)
}

// RequestID adds a unique request ID to each request
func RequestID() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                requestID := c.GetHeader("X-Request-ID")
                if requestID == "" </span><span class="cov0" title="0">{
                        requestID = generateRequestID()
                }</span>

                <span class="cov0" title="0">c.Header("X-Request-ID", requestID)
                c.Set("request_id", requestID)
                c.Next()</span>
        }
}

// generateRequestID generates a simple request ID
func generateRequestID() string <span class="cov0" title="0">{
        return time.Now().Format("20060102150405") + "-" + randomString(8)
}</span>

// randomString generates a random string of specified length
func randomString(length int) string <span class="cov0" title="0">{
        const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        b := make([]byte, length)
        for i := range b </span><span class="cov0" title="0">{
                b[i] = charset[time.Now().UnixNano()%int64(len(charset))]
        }</span>
        <span class="cov0" title="0">return string(b)</span>
}

// Recovery returns a middleware that recovers from any panics and writes a 500 if there was one
func Recovery() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.CustomRecovery(func(c *gin.Context, recovered interface{}) </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "error":      recovered,
                        "request_id": c.GetString("request_id"),
                        "path":       c.Request.URL.Path,
                        "method":     c.Request.Method,
                }).Error("Panic recovered")

                c.JSON(500, gin.H{
                        "error":      "Internal server error",
                        "request_id": c.GetString("request_id"),
                })
        }</span>)
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package auth

import (
        "fmt"
        "os"
        "strconv"

        "github.com/spf13/viper"
)

// AuthConfig holds all authentication configuration for the application
type AuthConfig struct {
        JWTSecret                string                    `yaml:"jwt_secret" json:"jwt_secret"`
        TokenSecret              string                    `yaml:"token_secret" json:"token_secret"`
        RedirectURL              string                    `yaml:"redirect_url" json:"redirect_url"`
        JWTExpiresInSeconds      int                       `yaml:"jwt_expires_in_seconds" json:"jwt_expires_in_seconds"`
        AccessTokenExpiresInDays int                       `yaml:"access_token_expires_in_days" json:"access_token_expires_in_days"`
        Providers                map[string]ProviderConfig `yaml:"providers" json:"providers"`
}

// ProviderConfig holds configuration for a specific provider
type ProviderConfig struct {
        ClientID          string `yaml:"client_id" json:"client_id"`
        ClientSecret      string `yaml:"client_secret" json:"client_secret"`
        EnterpriseBaseURL string `yaml:"enterprise_base_url,omitempty" json:"enterprise_base_url,omitempty"`
}

// LoadAuthConfig loads and validates authentication configuration
func LoadAuthConfig(configPath string) (*AuthConfig, error) <span class="cov0" title="0">{
        // Create a new viper instance for auth config
        v := viper.New()

        // Set config file details
        if configPath != "" </span><span class="cov0" title="0">{
                v.SetConfigFile(configPath)
        }</span> else<span class="cov0" title="0"> {
                v.SetConfigName("auth")
                v.SetConfigType("yaml")
                v.AddConfigPath(".")
                v.AddConfigPath("./config")
        }</span>

        // Set default values
        <span class="cov0" title="0">setAuthDefaults(v)

        // Read config file
        if err := v.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(viper.ConfigFileNotFoundError); ok </span>{<span class="cov0" title="0">
                        // Config file not found, use defaults and environment variables
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("error reading auth config file: %w", err)
                }</span>
        }

        // Override with environment variables
        <span class="cov0" title="0">v.AutomaticEnv()

        var config AuthConfig
        if err := v.Unmarshal(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error unmarshaling auth config: %w", err)
        }</span>

        // Manual fix for enterprise_base_url mapping issue
        // Viper seems to have trouble mapping snake_case to PascalCase, so let's do it manually
        <span class="cov0" title="0">for providerName, provider := range config.Providers </span><span class="cov0" title="0">{
                if provider.EnterpriseBaseURL == "" </span><span class="cov0" title="0">{
                        // Try to get the value directly from viper
                        viperKey := fmt.Sprintf("providers.%s.enterprise_base_url", providerName)
                        if enterpriseURL := v.GetString(viperKey); enterpriseURL != "" </span><span class="cov0" title="0">{
                                provider.EnterpriseBaseURL = enterpriseURL
                                config.Providers[providerName] = provider
                        }</span>
                }
        }

        // Override with environment variables for sensitive data
        <span class="cov0" title="0">if jwtSecret := os.Getenv("JWT_SECRET"); jwtSecret != "" </span><span class="cov0" title="0">{
                config.JWTSecret = jwtSecret
        }</span>
        <span class="cov0" title="0">if tokenSecret := os.Getenv("TOKEN_SECRET"); tokenSecret != "" </span><span class="cov0" title="0">{
                config.TokenSecret = tokenSecret
        }</span>

        // Check for AUTH_REDIRECT_URL environment variable
        <span class="cov0" title="0">authRedirectURL := os.Getenv("AUTH_REDIRECT_URL")
        if authRedirectURL != "" </span><span class="cov0" title="0">{
                config.RedirectURL = authRedirectURL
        }</span> else<span class="cov0" title="0"> {
                // If config.RedirectURL is still empty after unmarshal, use the default
                if config.RedirectURL == "" </span><span class="cov0" title="0">{
                        config.RedirectURL = v.GetString("redirect_url")
                }</span>
        }

        // JWT expiration seconds: allow env override and default
        <span class="cov0" title="0">if expStr := os.Getenv("JWT_EXPIRES_IN_SECONDS"); expStr != "" </span><span class="cov0" title="0">{
                if exp, err := strconv.Atoi(expStr); err == nil &amp;&amp; exp &gt; 0 </span><span class="cov0" title="0">{
                        config.JWTExpiresInSeconds = exp
                }</span>
        }
        <span class="cov0" title="0">if config.JWTExpiresInSeconds &lt;= 0 </span><span class="cov0" title="0">{
                config.JWTExpiresInSeconds = v.GetInt("jwt_expires_in_seconds")
                if config.JWTExpiresInSeconds &lt;= 0 </span><span class="cov0" title="0">{
                        config.JWTExpiresInSeconds = 3600
                }</span>
        }

        // Token expiration days: allow env override; rely on viper defaults and ValidateConfig for final defaulting
        <span class="cov0" title="0">if smStr := os.Getenv("ACCESS_TOKEN_EXPIRATION_IN_DAYS"); smStr != "" </span><span class="cov0" title="0">{
                if sm, err := strconv.Atoi(smStr); err == nil &amp;&amp; sm &gt; 0 </span><span class="cov0" title="0">{
                        config.AccessTokenExpiresInDays = sm
                }</span>
        }

        // Override provider secrets from environment using your specific variable names
        <span class="cov0" title="0">config = overrideFromEnvironment(config)

        // Validate configuration
        if err := config.ValidateConfig(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("auth config validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

// GetProvider returns the configuration for a specific provider
func (c *AuthConfig) GetProvider(provider string) (*ProviderConfig, error) <span class="cov4" title="3">{
        providerConfig, exists := c.Providers[provider]
        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("provider '%s' not found", provider)
        }</span>

        <span class="cov3" title="2">return &amp;providerConfig, nil</span>
}

// ValidateConfig validates the authentication configuration
func (c *AuthConfig) ValidateConfig() error <span class="cov10" title="16">{
        if c.JWTSecret == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("JWT secret is required")
        }</span>

        <span class="cov9" title="15">if c.RedirectURL == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("redirect URL is required")
        }</span>

        <span class="cov9" title="14">if len(c.Providers) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("at least one provider must be configured")
        }</span>

        // Validate each provider
        <span class="cov9" title="13">for providerName, provider := range c.Providers </span><span class="cov9" title="15">{
                if provider.ClientID == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("client_id is required for provider '%s'", providerName)
                }</span>
                <span class="cov9" title="14">if provider.ClientSecret == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("client_secret is required for provider '%s'", providerName)
                }</span>
        }

        <span class="cov9" title="12">if c.JWTExpiresInSeconds &lt;= 0 </span><span class="cov8" title="10">{
                // Default to 3600 seconds if not set to support programmatic construction in tests and dev
                c.JWTExpiresInSeconds = 3600
        }</span>
        <span class="cov9" title="12">if c.AccessTokenExpiresInDays &lt;= 0 </span><span class="cov8" title="11">{
                // Default to 14 days to ensure non-zero session lifetime for provider tokens
                c.AccessTokenExpiresInDays = 14
        }</span>

        <span class="cov9" title="12">return nil</span>
}

// setAuthDefaults sets default values for auth configuration
func setAuthDefaults(v *viper.Viper) <span class="cov0" title="0">{
        v.SetDefault("redirect_url", "http://localhost:3000")
        // No default JWT secret - must be provided via environment variable or generated
        // Default JWT expiration (in seconds)
        v.SetDefault("jwt_expires_in_seconds", 3600)
        // Default session duration in days for stored provider access tokens
        v.SetDefault("access_token_expires_in_days", 14)

        // Default providers configuration - don't set enterprise_base_url defaults to let YAML values take precedence
        v.SetDefault("providers", map[string]interface{}{
                "githubtools": map[string]interface{}{
                        "client_id":     "",
                        "client_secret": "",
                },
                "githubwdf": map[string]interface{}{
                        "client_id":     "",
                        "client_secret": "",
                },
        })
}</span>

// overrideFromEnvironment overrides config values with your specific environment variables
func overrideFromEnvironment(config AuthConfig) AuthConfig <span class="cov0" title="0">{
        // Helper function to safely update provider config
        updateProviderConfig := func(providerName, clientID, clientSecret string) </span><span class="cov0" title="0">{
                if provider, exists := config.Providers[providerName]; exists </span><span class="cov0" title="0">{
                        // Create a copy of the provider config to modify
                        newProvider := provider

                        // Override client credentials if provided
                        if clientID != "" </span><span class="cov0" title="0">{
                                newProvider.ClientID = clientID
                        }</span>
                        <span class="cov0" title="0">if clientSecret != "" </span><span class="cov0" title="0">{
                                newProvider.ClientSecret = clientSecret
                        }</span>

                        // Expand environment variables in existing values if they contain ${...}
                        <span class="cov0" title="0">if newProvider.ClientID != "" &amp;&amp; len(newProvider.ClientID) &gt; 3 &amp;&amp; newProvider.ClientID[:2] == "${" &amp;&amp; newProvider.ClientID[len(newProvider.ClientID)-1:] == "}" </span><span class="cov0" title="0">{
                                envVar := newProvider.ClientID[2 : len(newProvider.ClientID)-1]
                                if envValue := os.Getenv(envVar); envValue != "" </span><span class="cov0" title="0">{
                                        newProvider.ClientID = envValue
                                }</span>
                        }
                        <span class="cov0" title="0">if newProvider.ClientSecret != "" &amp;&amp; len(newProvider.ClientSecret) &gt; 3 &amp;&amp; newProvider.ClientSecret[:2] == "${" &amp;&amp; newProvider.ClientSecret[len(newProvider.ClientSecret)-1:] == "}" </span><span class="cov0" title="0">{
                                envVar := newProvider.ClientSecret[2 : len(newProvider.ClientSecret)-1]
                                if envValue := os.Getenv(envVar); envValue != "" </span><span class="cov0" title="0">{
                                        newProvider.ClientSecret = envValue
                                }</span>
                        }

                        // EnterpriseBaseURL is preserved from the original config

                        <span class="cov0" title="0">config.Providers[providerName] = newProvider</span>
                }
        }

        // GitHub Tools
        <span class="cov0" title="0">updateProviderConfig("githubtools",
                os.Getenv("GITHUB_TOOLS_APP_CLIENT_ID"),
                os.Getenv("GITHUB_TOOLS_APP_CLIENT_SECRET"))

        // GitHub WDF
        updateProviderConfig("githubwdf",
                os.Getenv("GITHUB_WDF_APP_CLIENT_ID"),
                os.Getenv("GITHUB_WDF_APP_CLIENT_SECRET"))

        return config</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package auth

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "crypto/subtle"
        "encoding/base64"
        "errors"
        "os"
        "strings"
        "sync"
)

const (
        // encPrefix helps us detect if a token is encrypted and supports future versioning
        encPrefix   = "enc:v1:"
        gcmNonceLen = 12 // AES-GCM standard nonce length
)

var (
        keyOnce       sync.Once
        keyInitErr    error
        encryptionKey []byte
)

// initKeyFromEnv lazily reads TOKEN_SECRET from the environment and prepares the AES-256 key.
// TOKEN_SECRET is expected to be a base64 encoded 32-byte value (openssl rand -base64 32).
func initKeyFromEnv() error <span class="cov0" title="0">{
        keyOnce.Do(func() </span><span class="cov0" title="0">{
                secret := os.Getenv("TOKEN_SECRET")
                if strings.TrimSpace(secret) == "" </span><span class="cov0" title="0">{
                        keyInitErr = errors.New("TOKEN_SECRET env var is empty")
                        return
                }</span>
                <span class="cov0" title="0">raw, err := base64.StdEncoding.DecodeString(secret)
                if err != nil </span><span class="cov0" title="0">{
                        keyInitErr = errors.New("failed to base64 decode TOKEN_SECRET")
                        return
                }</span>
                <span class="cov0" title="0">if len(raw) != 32 </span><span class="cov0" title="0">{
                        keyInitErr = errors.New("TOKEN_SECRET must decode to exactly 32 bytes")
                        return
                }</span>
                <span class="cov0" title="0">encryptionKey = raw</span>
        })
        <span class="cov0" title="0">return keyInitErr</span>
}

// SetTokenSecret allows tests (or controlled initialization) to set the key explicitly.
// The provided secret must be a base64-encoded 32-byte string.
func SetTokenSecret(base64Secret string) error <span class="cov5" title="4">{
        raw, err := base64.StdEncoding.DecodeString(base64Secret)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to base64 decode provided secret")
        }</span>
        <span class="cov5" title="4">if len(raw) != 32 </span><span class="cov1" title="1">{
                return errors.New("provided secret must decode to exactly 32 bytes")
        }</span>
        // Reset lazy init state
        <span class="cov4" title="3">keyOnce = sync.Once{}
        encryptionKey = raw
        keyInitErr = nil
        return nil</span>
}

// EncryptToken encrypts the plaintext token using AES-256-GCM and returns an encoded string.
// Format: "enc:v1:" + base64(nonce || ciphertext)
func EncryptToken(plaintext string) (string, error) <span class="cov8" title="11">{
        if err := ensureKey(); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="11">block, err := aes.NewCipher(encryptionKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="11">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="11">nonce := make([]byte, gcmNonceLen)
        if _, err := rand.Read(nonce); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="11">ciphertext := gcm.Seal(nil, nonce, []byte(plaintext), nil)
        combined := append(nonce, ciphertext...)
        return encPrefix + base64.StdEncoding.EncodeToString(combined), nil</span>
}

// DecryptToken decrypts an encrypted token. Returns an error if the input does not have the expected prefix.
func DecryptToken(s string) (string, error) <span class="cov7" title="10">{
        // Strict mode: require encryption prefix, no plaintext backward compatibility (constant-time)
        if len(s) &lt; len(encPrefix) || subtle.ConstantTimeCompare([]byte(s[:len(encPrefix)]), []byte(encPrefix)) != 1 </span><span class="cov1" title="1">{
                return "", errors.New("token is not encrypted (missing " + encPrefix + " prefix)")
        }</span>

        <span class="cov7" title="9">if err := ensureKey(); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov7" title="9">encoded := s[len(encPrefix):]
        combined, err := base64.StdEncoding.DecodeString(encoded)
        if err != nil </span><span class="cov1" title="1">{
                return "", errors.New("failed to base64 decode encrypted token")
        }</span>
        <span class="cov7" title="8">if len(combined) &lt; gcmNonceLen </span><span class="cov0" title="0">{
                return "", errors.New("invalid encrypted token payload")
        }</span>
        <span class="cov7" title="8">nonce := combined[:gcmNonceLen]
        ciphertext := combined[gcmNonceLen:]

        block, err := aes.NewCipher(encryptionKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov7" title="8">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov7" title="8">plain, err := gcm.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New("failed to decrypt token")
        }</span>
        <span class="cov7" title="8">return string(plain), nil</span>
}

func ensureKey() error <span class="cov10" title="20">{
        // If already set via SetTokenSecret, skip env init
        if len(encryptionKey) == 32 &amp;&amp; keyInitErr == nil </span><span class="cov10" title="20">{
                return nil
        }</span>
        <span class="cov0" title="0">return initKeyFromEnv()</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package auth

import (
        "context"
        "fmt"
        "net/http"

        "github.com/google/go-github/v57/github"
        "golang.org/x/oauth2"
)

// GitHubClient wraps the GitHub API client with authentication support
type GitHubClient struct {
        config *ProviderConfig
        client *github.Client
}

// UserProfile represents a GitHub user profile
type UserProfile struct {
        ID        int64  `json:"id"`
        Username  string `json:"username"`
        Email     string `json:"email"`
        Name      string `json:"name"`
        AvatarURL string `json:"avatarUrl"`
        UUID      string `json:"uuid"` // User UUID from database table
}

// NewGitHubClient creates a new GitHub API client
func NewGitHubClient(config *ProviderConfig) *GitHubClient <span class="cov8" title="73">{
        var client *github.Client

        if config.EnterpriseBaseURL != "" </span><span class="cov8" title="67">{
                // GitHub Enterprise Server
                client, _ = github.NewEnterpriseClient(config.EnterpriseBaseURL, config.EnterpriseBaseURL, nil)
        }</span> else<span class="cov4" title="6"> {
                // GitHub.com
                client = github.NewClient(nil)
        }</span>

        <span class="cov8" title="73">return &amp;GitHubClient{
                config: config,
                client: client,
        }</span>
}

// GetUserProfile fetches user profile information from GitHub API
func (c *GitHubClient) GetUserProfile(ctx context.Context, accessToken string) (*UserProfile, error) <span class="cov0" title="0">{
        // Create OAuth2 client with access token
        ts := oauth2.StaticTokenSource(
                &amp;oauth2.Token{AccessToken: accessToken},
        )
        tc := oauth2.NewClient(ctx, ts)

        // Create GitHub client with authenticated HTTP client
        var client *github.Client
        if c.config.EnterpriseBaseURL != "" </span><span class="cov0" title="0">{
                client, _ = github.NewEnterpriseClient(c.config.EnterpriseBaseURL, c.config.EnterpriseBaseURL, tc)
        }</span> else<span class="cov0" title="0"> {
                client = github.NewClient(tc)
        }</span>

        // Get authenticated user
        <span class="cov0" title="0">user, resp, err := client.Users.Get(ctx, "")
        if err != nil </span><span class="cov0" title="0">{
                if resp != nil &amp;&amp; resp.StatusCode == http.StatusUnauthorized </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid access token")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user profile: %w", err)</span>
        }

        // Get user emails
        <span class="cov0" title="0">emails, _, err := client.Users.ListEmails(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                // Don't fail if we can't get emails, just log it
                emails = []*github.UserEmail{}
        }</span>

        // Find primary email
        <span class="cov0" title="0">primaryEmail := ""
        for _, email := range emails </span><span class="cov0" title="0">{
                if email.GetPrimary() </span><span class="cov0" title="0">{
                        primaryEmail = email.GetEmail()
                        break</span>
                }
        }

        // If no primary email found, use the first verified email
        <span class="cov0" title="0">if primaryEmail == "" </span><span class="cov0" title="0">{
                for _, email := range emails </span><span class="cov0" title="0">{
                        if email.GetVerified() </span><span class="cov0" title="0">{
                                primaryEmail = email.GetEmail()
                                break</span>
                        }
                }
        }

        // Fallback to user email from profile if available
        <span class="cov0" title="0">if primaryEmail == "" &amp;&amp; user.GetEmail() != "" </span><span class="cov0" title="0">{
                primaryEmail = user.GetEmail()
        }</span>

        <span class="cov0" title="0">profile := &amp;UserProfile{
                ID:        user.GetID(),
                Username:  user.GetLogin(),
                Email:     primaryEmail,
                Name:      user.GetName(),
                AvatarURL: user.GetAvatarURL(),
        }

        return profile, nil</span>
}

// GetOAuth2Config returns the OAuth2 configuration for this GitHub client
func (c *GitHubClient) GetOAuth2Config(redirectURL string) *oauth2.Config <span class="cov2" title="2">{
        var endpoint oauth2.Endpoint

        if c.config.EnterpriseBaseURL != "" </span><span class="cov2" title="2">{
                // GitHub Enterprise Server endpoints
                endpoint = oauth2.Endpoint{
                        AuthURL:  fmt.Sprintf("%s/login/oauth/authorize", c.config.EnterpriseBaseURL),
                        TokenURL: fmt.Sprintf("%s/login/oauth/access_token", c.config.EnterpriseBaseURL),
                }
        }</span> else<span class="cov0" title="0"> {
                // GitHub.com endpoints
                endpoint = oauth2.Endpoint{
                        AuthURL:  "https://github.com/login/oauth/authorize",
                        TokenURL: "https://github.com/login/oauth/access_token",
                }
        }</span>

        <span class="cov2" title="2">return &amp;oauth2.Config{
                ClientID:     c.config.ClientID,
                ClientSecret: c.config.ClientSecret,
                RedirectURL:  redirectURL,
                Scopes:       []string{"user:email", "read:user", "repo"},
                Endpoint:     endpoint,
        }</span>
}

// ValidateConfig validates the GitHub client configuration
func (c *GitHubClient) ValidateConfig() error <span class="cov0" title="0">{
        if c.config.ClientID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("client ID is required")
        }</span>
        <span class="cov0" title="0">if c.config.ClientSecret == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("client secret is required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetEnterpriseBaseURL returns the enterprise base URL if configured
func (c *GitHubClient) GetEnterpriseBaseURL() string <span class="cov10" title="161">{
        if c.config == nil </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov9" title="160">return c.config.EnterpriseBaseURL</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package auth

import (
        "encoding/json"
        "html"
        "net/http"
        "strings"

        "developer-portal-backend/internal/logger"

        "github.com/gin-gonic/gin"
)

// formatResponseAsJSON converts the response to JSON string for embedding in HTML
func formatResponseAsJSON(response interface{}) string <span class="cov0" title="0">{
        jsonBytes, err := json.Marshal(response)
        if err != nil </span><span class="cov0" title="0">{
                return "{}"
        }</span>
        <span class="cov0" title="0">return string(jsonBytes)</span>
}

// escapeJSString safely escapes a Go string for embedding inside JS string literals.
func escapeJSString(s string) string <span class="cov0" title="0">{
        // basic HTML escape then replace newlines/quotes for safe inline JS
        e := html.EscapeString(s)
        e = strings.ReplaceAll(e, "\n", `\n`)
        e = strings.ReplaceAll(e, "\r", ``)
        return e
}</span>

// AuthHandler handles HTTP requests for authentication
type AuthHandler struct {
        service *AuthService
}

// NewAuthHandler creates a new authentication handler
func NewAuthHandler(service *AuthService) *AuthHandler <span class="cov8" title="1">{
        return &amp;AuthHandler{service: service}
}</span>

// Start handles GET /api/auth/{provider}/start
// @Summary Start OAuth authentication
// @Description Initiate OAuth authentication flow with the specified provider
// @Tags authentication
// @Accept json
// @Produce json
// @Param provider path string true "OAuth provider (githubtools or githubwdf)"
// @Success 302 {string} string "Redirect to OAuth provider authorization URL"
// @Failure 400 {object} map[string]interface{} "Invalid provider or request parameters"
// @Failure 500 {object} map[string]interface{} "Failed to generate authorization URL"
// @Router /api/auth/{provider}/start [get]
func (h *AuthHandler) Start(c *gin.Context) <span class="cov8" title="1">{
        provider := c.Param("provider")
        log := logger.FromGinContext(c).WithField("Provider", provider)

        // Validate provider
        if provider == "" </span><span class="cov0" title="0">{
                log.Warn("Provider is required")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Provider is required"})
                return
        }</span>

        // Validate supported providers
        <span class="cov8" title="1">if provider != "githubtools" &amp;&amp; provider != "githubwdf" </span><span class="cov0" title="0">{
                log.Warn("Unsupported provider")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Unsupported provider"})
                return
        }</span>

        // Generate state parameter for OAuth2 security
        <span class="cov8" title="1">state, err := h.service.generateRandomString(32)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to generate state parameter: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate state parameter"})
                return
        }</span>

        // Get authorization URL
        <span class="cov8" title="1">authURL, err := h.service.GetAuthURL(provider, state)
        if err != nil </span><span class="cov0" title="0">{
                log.WithField("State", state).Errorf("Failed to generate authorization URL: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate authorization URL", "details": err.Error()})
                return
        }</span>

        // Redirect to GitHub OAuth authorization URL
        <span class="cov8" title="1">log.WithField("Auth URL", authURL).Debug("Redirecting to OAuth provider authorization URL")
        c.Redirect(http.StatusFound, authURL)</span>
}

// HandlerFrame handles GET /api/auth/{provider}/handler/frame
// Regular-token mode: posts { type: 'authorization_response', response: { accessToken, tokenType, expiresInSeconds, scope, profile{...} } } to the opener and closes.
// @Summary Handle OAuth callback
// @Description Handle OAuth callback from provider and return authentication result in HTML frame
// @Tags authentication
// @Accept json
// @Produce text/html
// @Param provider path string true "OAuth provider (githubtools or githubwdf)"
// @Param code query string true "OAuth authorization code from provider"
// @Param state query string true "OAuth state parameter for security"
// @Param error query string false "OAuth error parameter from provider"
// @Param error_description query string false "OAuth error description from provider"
// @Success 200 {string} string "HTML page that posts authentication result to opener window"
// @Failure 400 {object} map[string]interface{} "Invalid request parameters"
// @Router /api/auth/{provider}/handler/frame [get]
func (h *AuthHandler) HandlerFrame(c *gin.Context) <span class="cov0" title="0">{
        provider := c.Param("provider")
        code := c.Query("code")
        state := c.Query("state")
        errorParam := c.Query("error")

        // structured logger with safe context (do not log auth code/token)
        log := logger.FromGinContext(c).WithFields(map[string]interface{}{
                "Provider":     provider,
                "State":        state,
                "code_present": code != "",
        })

        // OAuth errors from provider
        if errorParam != "" </span><span class="cov0" title="0">{
                errorDescription := c.Query("error_description")
                log.WithFields(map[string]interface{}{
                        "error":             errorParam,
                        "error_description": errorDescription,
                }).Error("OAuth error from provider callback")
                errorHTML := `&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;script&gt;
(function(){
  var msg = { type: "authorization_response", error: { name: "OAuthError", message: "` + escapeJSString(errorParam) + `: ` + escapeJSString(errorDescription) + `" } };
  try { if (window.opener) window.opener.postMessage(msg, "*"); } finally { window.close(); }
})();
&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;`
                c.Header("Content-Type", "text/html; charset=utf-8")
                c.String(http.StatusOK, errorHTML)
                return
        }</span>

        // Validate params
        <span class="cov0" title="0">if provider == "" </span><span class="cov0" title="0">{
                log.Error("Provider is required in callback")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Provider is required"})
                return
        }</span>
        <span class="cov0" title="0">if code == "" </span><span class="cov0" title="0">{
                log.Error("Authorization code is required")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Authorization code is required"})
                return
        }</span>
        <span class="cov0" title="0">if state == "" </span><span class="cov0" title="0">{
                log.Error("State parameter is required")
                c.JSON(http.StatusBadRequest, gin.H{"error": "State parameter is required"})
                return
        }</span>

        // Service callback  may return various shapes; we'll normalize in JS
        <span class="cov0" title="0">serviceResp, err := h.service.HandleCallback(c.Request.Context(), provider, code, state)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("HandleCallback failed: %v", err)
                errorHTML := `&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;script&gt;
(function(){
  var msg = { type: "authorization_response", error: { name: "Error", message: "` + escapeJSString(err.Error()) + `" } };
  try { if (window.opener) window.opener.postMessage(msg, "*"); } finally { window.close(); }
})();
&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;`
                c.Header("Content-Type", "text/html; charset=utf-8")
                c.String(http.StatusOK, errorHTML)
                return
        }</span>

        // Set session cookies for later use by refresh endpoint
        <span class="cov0" title="0">c.SetCookie("auth_token", serviceResp.AccessToken, h.service.config.JWTExpiresInSeconds, "/", "", true, true) // httpOnly for security
        log.Debug("OAuth callback successful; set auth cookie")

        // Embed the raw service response and normalize to the regular-token payload in the browser.
        raw := formatResponseAsJSON(serviceResp)
        log.Debug("service response was formatted for HTML embedding")

        successHTML := `&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;script&gt;
(function(){
  var src = ` + raw + ` || {};
  // Normalize various possible shapes into:
  // { accessToken, tokenType, expiresInSeconds, scope, profile{ login,email,name,avatarUrl } }
  function toStr(v){ return (v==null)? "" : (Array.isArray(v)? v.join(" ") : String(v)); }
  var accessToken = src.accessToken || src.access_token || src.token || "";
  var tokenType   = src.tokenType || src.token_type || "bearer";
  var expires     = src.expiresInSeconds || src.expires_in || 0;
  var scopeStr    = src.scope || src.scopes || "";
  scopeStr = Array.isArray(scopeStr) ? scopeStr.join(" ") : toStr(scopeStr);

  // profile could be under src.profile or src.user
  var p = src.profile || src.user || {};
  var profile = {
    login:     p.login     || p.username || "",
    email:     p.email     || "",
    name:      p.name      || p.displayName || "",
    avatarUrl: p.avatarUrl || p.avatar_url || p.picture || ""
  };

  var resp = {
    accessToken: accessToken,
    tokenType: tokenType,
    expiresInSeconds: Number(expires) || 0,
    scope: scopeStr,
    profile: profile
  };

  var message = { type: "authorization_response", response: resp };
  try { if (window.opener) window.opener.postMessage(message, "*"); } finally { window.close(); }
})();
&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;`

        c.Header("Content-Type", "text/html; charset=utf-8")
        c.String(http.StatusOK, successHTML)</span>
}

// Refresh handles GET /api/auth/refresh
// Regular-token mode JSON response. If your service returns a non-standard shape,
// we normalize it into { accessToken, tokenType, expiresInSeconds, scope, profile{...} }.
// @Summary Refresh authentication token
// @Description Refresh or validate authentication token using Authorization header or session cookies
// @Tags authentication
// @Accept json
// @Produce json
// @Param Authorization header string false "Bearer token for validation" example("Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6Ikp...")
// @Success 200 {object} AuthRefreshResponse "Successfully refreshed token"
// @Failure 400 {object} map[string]interface{} "Invalid provider"
// @Failure 401 {object} map[string]interface{} "Authentication required or token invalid"
// @Failure 500 {object} map[string]interface{} "Token refresh failed"
// @Router /api/auth/refresh [get]
func (h *AuthHandler) Refresh(c *gin.Context) <span class="cov0" title="0">{
        log := logger.FromGinContext(c)
        authTokenCookie, err := c.Cookie("auth_token")
        log = log.WithField("cookie_present", err == nil &amp;&amp; authTokenCookie != "")

        if err == nil &amp;&amp; authTokenCookie != "" </span><span class="cov0" title="0">{
                // Validate the JWT token from cookie
                claims, err := h.service.ValidateJWT(authTokenCookie)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("ValidateJWT failed: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        // Generate a new JWT token for the current session
                        userProfile := &amp;UserProfile{
                                Username: claims.Username,
                                Email:    claims.Email,
                                UUID:     claims.UUID,
                        }

                        newJWT, err := h.service.GenerateJWT(userProfile)
                        if err == nil </span><span class="cov0" title="0">{
                                log.Debug("JWT validated; issuing new token")
                                c.JSON(http.StatusOK, gin.H{
                                        "accessToken": newJWT,
                                })
                                return
                        }</span> else<span class="cov0" title="0"> {
                                log.Errorf("GenerateJWT failed: %v", err)
                        }</span>
                }
        }

        // No valid session found, return 401 Unauthorized
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Errorf("auth_token cookie read error; returning 401 Unauthorized: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Warn("No auth_token found; returning 401 Unauthorized")
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusUnauthorized, gin.H{
                "error":   "Authentication required",
                "details": "No valid auth_token found. Need to authenticate first.",
        })
        return</span>
}

// Logout handles POST /api/auth/logout
// @Summary Logout user
// @Description Logout user and invalidate authentication session
// @Tags authentication
// @Accept json
// @Produce json
// @Success 200 {object} AuthLogoutResponse "Successfully logged out"
// @Failure 400 {object} map[string]interface{} "Invalid provider"
// @Failure 500 {object} map[string]interface{} "Logout failed"
// @Router /api/auth/logout [post]
func (h *AuthHandler) Logout(c *gin.Context) <span class="cov8" title="1">{
        if err := h.service.Logout(); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Logout failed", "details": err.Error()})
                return
        }</span>

        // Clear all authentication cookies
        // Clear auth_token (access token)
        <span class="cov8" title="1">c.SetCookie(
                "auth_token",
                "",
                -1, // MaxAge &lt; 0 means delete the cookie
                "/",
                "",
                false,
                true, // HttpOnly
        )

        c.JSON(http.StatusOK, gin.H{"message": "Logged out successfully"})</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package auth

import (
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
)

// AuthMiddleware provides JWT authentication middleware
type AuthMiddleware struct {
        service *AuthService
}

// NewAuthMiddleware creates a new authentication middleware
func NewAuthMiddleware(service *AuthService) *AuthMiddleware <span class="cov2" title="2">{
        return &amp;AuthMiddleware{service: service}
}</span>

// RequireAuth validates JWT tokens and sets user context
func (m *AuthMiddleware) RequireAuth() gin.HandlerFunc <span class="cov2" title="2">{
        return func(c *gin.Context) </span><span class="cov2" title="2">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header is required"})
                        c.Abort()
                        return
                }</span>

                // Extract token from Bearer header
                <span class="cov2" title="2">tokenString := strings.TrimPrefix(authHeader, "Bearer ")
                if tokenString == authHeader </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authorization header format"})
                        c.Abort()
                        return
                }</span>

                // Validate token
                <span class="cov2" title="2">claims, err := m.service.ValidateJWT(tokenString)
                if err != nil </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token", "details": err.Error()})
                        c.Abort()
                        return
                }</span>

                // Set user context
                <span class="cov1" title="1">c.Set("user_uuid", claims.UUID)
                c.Set("username", claims.Username)
                c.Set("email", claims.Email)
                c.Set("auth_claims", claims)

                c.Next()</span>
        }
}

// RequireProvider validates that the request comes from a specific provider
func (m *AuthMiddleware) RequireProvider(allowedProviders ...string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                provider, exists := c.Get("provider")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">providerStr, ok := provider.(string)
                if !ok </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid provider context"})
                        c.Abort()
                        return
                }</span>

                // Check if provider is allowed
                <span class="cov0" title="0">allowed := false
                for _, allowedProvider := range allowedProviders </span><span class="cov0" title="0">{
                        if providerStr == allowedProvider </span><span class="cov0" title="0">{
                                allowed = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{"error": "Provider not allowed for this resource"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// GetUserID is a helper function to extract user ID from context
func GetUserID(c *gin.Context) (int64, bool) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                return 0, false
        }</span>

        <span class="cov0" title="0">id, ok := userID.(int64)
        return id, ok</span>
}

// GetUsername is a helper function to extract username from context
func GetUsername(c *gin.Context) (string, bool) <span class="cov9" title="40">{
        username, exists := c.Get("username")
        if !exists </span><span class="cov6" title="14">{
                return "", false
        }</span>

        <span class="cov8" title="26">name, ok := username.(string)
        return name, ok</span>
}

// GetUserEmail is a helper function to extract user email from context
func GetUserEmail(c *gin.Context) (string, bool) <span class="cov10" title="62">{
        email, exists := c.Get("email")
        if !exists </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov10" title="62">emailStr, ok := email.(string)
        return emailStr, ok</span>
}

// GetProvider is a helper function to extract provider from context
func GetProvider(c *gin.Context) (string, bool) <span class="cov0" title="0">{
        provider, exists := c.Get("provider")
        if !exists </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">providerStr, ok := provider.(string)
        return providerStr, ok</span>
}

// GetEnvironment is a helper function to extract environment from context
func GetEnvironment(c *gin.Context) (string, bool) <span class="cov0" title="0">{
        environment, exists := c.Get("environment")
        if !exists </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">envStr, ok := environment.(string)
        return envStr, ok</span>
}

// GetAuthClaims is a helper function to extract full auth claims from context
func GetAuthClaims(c *gin.Context) (*AuthClaims, bool) <span class="cov1" title="1">{
        claims, exists := c.Get("auth_claims")
        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov1" title="1">authClaims, ok := claims.(*AuthClaims)
        return authClaims, ok</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package auth

import (
        "context"
        "crypto/rand"
        apperrors "developer-portal-backend/internal/errors"
        "encoding/base64"
        "fmt"
        "reflect"
        "time"

        "developer-portal-backend/internal/database/models"

        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "golang.org/x/oauth2"
)

// RefreshTokenData stores information about a refresh token
type RefreshTokenData struct {
        UserUUID    string    `json:"user_uuid"`
        Provider    string    `json:"provider"`
        AccessToken string    `json:"access_token"`
        ExpiresAt   time.Time `json:"expires_at"`
}

// MemberRepository defines the interface for member operations needed by auth service
type UserRepository interface {
        GetByEmail(email string) (interface{}, error)
}

// TokenStore defines persistence API for provider access tokens
type TokenStore interface {
        UpsertToken(userUUID uuid.UUID, provider string, token string, expiresAt time.Time) error
        GetValidToken(userUUID uuid.UUID, provider string) (*models.Token, error)
        DeleteToken(userUUID uuid.UUID, provider string) error
        CleanupExpiredTokens() error
}

// AuthService provides authentication functionality
type AuthService struct {
        config        *AuthConfig
        githubClients map[string]*GitHubClient
        tokenStore    TokenStore
        userRepo      UserRepository
}

// AuthClaims represents JWT token claims
type AuthClaims struct {
        Username string `json:"username" example:"I012345"`
        Email    string `json:"email" example:"john.doe@sap.com"`
        UUID     string `json:"user_uuid" example:"550e8400-e29b-41d4-a716-446655440000"`
        // Standard JWT fields
        jwt.RegisteredClaims `swaggerignore:"true"`
}

// AuthStartResponse represents the response for auth start endpoint
type AuthStartResponse struct {
        URL string `json:"url"`
}

// AuthHandlerResponse represents the response for auth handler endpoint
type AuthHandlerResponse struct {
        AccessToken string `json:"accessToken"`
        TokenType   string `json:"tokenType"`
        ExpiresIn   int64  `json:"expiresIn"`
}

// RefreshTokenRequest represents the request for token refresh
type RefreshTokenRequest struct {
        RefreshToken string `json:"refreshToken" binding:"required"`
}

// AuthRefreshResponse represents the response from the refresh endpoint
type AuthRefreshResponse struct {
        AccessToken      string      `json:"accessToken" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."`
        TokenType        string      `json:"tokenType" example:"bearer"`
        ExpiresInSeconds int64       `json:"expiresInSeconds" example:"3600"`
        Scope            string      `json:"scope" example:"user:email read:user"`
        Profile          UserProfile `json:"profile"`
        Valid            bool        `json:"valid,omitempty" example:"true"`
}

// AuthLogoutResponse represents the response from the logout endpoint
type AuthLogoutResponse struct {
        Message string `json:"message" example:"Logged out successfully"`
}

// AuthValidateResponse represents the response from the token validation endpoint
type AuthValidateResponse struct {
        Valid  bool        `json:"valid" example:"true"`
        Claims *AuthClaims `json:"claims"`
}

// NewAuthService creates a new authentication service
func NewAuthService(config *AuthConfig, userRepo UserRepository, tokenStore TokenStore) (*AuthService, error) <span class="cov10" title="9">{
        if err := config.ValidateConfig(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid auth config: %w", err)
        }</span>

        // Initialize GitHub clients for each provider
        <span class="cov10" title="9">githubClients := make(map[string]*GitHubClient)
        for providerName, providerConfig := range config.Providers </span><span class="cov10" title="9">{
                githubClients[providerName] = NewGitHubClient(&amp;providerConfig)
        }</span>

        <span class="cov10" title="9">return &amp;AuthService{
                config:        config,
                githubClients: githubClients,
                tokenStore:    tokenStore,
                userRepo:      userRepo,
        }, nil</span>
}

// getMemberIDByEmail looks up a member by email and returns their ID as a string
// Returns empty string if member is not found or an error occurs
func (s *AuthService) getMemberIDByEmail(email string) string <span class="cov0" title="0">{
        if s.userRepo == nil || email == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">member, err := s.userRepo.GetByEmail(email)
        if err != nil || member == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Use reflection to access the ID field from the member struct
        // This works with models.Member which has an ID field of type uuid.UUID
        <span class="cov0" title="0">val := reflect.ValueOf(member)
        if val.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                val = val.Elem()
        }</span>

        <span class="cov0" title="0">if val.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                idField := val.FieldByName("ID")
                if idField.IsValid() </span><span class="cov0" title="0">{
                        // Convert UUID to string
                        idStr := fmt.Sprintf("%v", idField.Interface())
                        return idStr
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

// GetAuthURL generates OAuth2 authorization URL
func (s *AuthService) GetAuthURL(provider, state string) (string, error) <span class="cov1" title="1">{
        _, err := s.config.GetProvider(provider)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov1" title="1">githubClient, exists := s.githubClients[provider]
        if !exists </span><span class="cov0" title="0">{
                return "", fmt.Errorf("GitHub client not found for provider %s", provider)
        }</span>

        // Generate callback URL
        <span class="cov1" title="1">callbackURL := fmt.Sprintf("%s/api/auth/%s/handler/frame", s.config.RedirectURL, provider)

        oauth2Config := githubClient.GetOAuth2Config(callbackURL)
        authURL := oauth2Config.AuthCodeURL(state, oauth2.AccessTypeOffline)

        return authURL, nil</span>
}

// HandleCallback processes OAuth2 callback and returns user information
func (s *AuthService) HandleCallback(ctx context.Context, provider, code, state string) (*AuthHandlerResponse, error) <span class="cov0" title="0">{
        _, err := s.config.GetProvider(provider)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">githubClient, exists := s.githubClients[provider]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GitHub client not found for provider %s", provider)
        }</span>

        // Generate callback URL
        <span class="cov0" title="0">callbackURL := fmt.Sprintf("%s/api/auth/%s/handler/frame", s.config.RedirectURL, provider)

        oauth2Config := githubClient.GetOAuth2Config(callbackURL)

        // Exchange authorization code for access token
        token, err := oauth2Config.Exchange(ctx, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to exchange code for token: %w", err)
        }</span>

        // Get user profile from GitHub
        <span class="cov0" title="0">profile, err := githubClient.GetUserProfile(ctx, token.AccessToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user profile: %w", err)
        }</span>

        // Look up member by email and populate UUID if found
        <span class="cov0" title="0">profile.UUID = s.getMemberIDByEmail(profile.Email)

        // Persist provider access token in DB-backed token store (if user has UUID)
        if s.tokenStore != nil &amp;&amp; profile.UUID != "" </span><span class="cov0" title="0">{
                userID, parseErr := uuid.Parse(profile.UUID)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid user UUID: %w", parseErr)
                }</span>
                <span class="cov0" title="0">if upsertErr := s.tokenStore.UpsertToken(userID, provider, token.AccessToken, time.Now().AddDate(0, 0, s.config.AccessTokenExpiresInDays)); upsertErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to store provider access token: %w", upsertErr)
                }</span>
        }

        // Generate JWT token
        <span class="cov0" title="0">jwtToken, err := s.GenerateJWT(profile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate JWT: %w", err)
        }</span>

        <span class="cov0" title="0">response := &amp;AuthHandlerResponse{
                AccessToken: jwtToken,
                TokenType:   "Bearer",
                ExpiresIn:   int64(s.config.JWTExpiresInSeconds),
        }

        return response, nil</span>
}

// GenerateJWT creates a JWT token for the user (provider is deprecated hence ignored)
func (s *AuthService) GenerateJWT(userProfile *UserProfile) (string, error) <span class="cov6" title="4">{
        now := time.Now()
        claims := &amp;AuthClaims{
                Username: userProfile.Username,
                Email:    userProfile.Email,
                UUID:     userProfile.UUID,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(now.Add(time.Duration(s.config.JWTExpiresInSeconds) * time.Second)),
                        Issuer:    "developer-portal",
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(s.config.JWTSecret))
}</span>

// ValidateJWT validates and parses a JWT token
func (s *AuthService) ValidateJWT(tokenString string) (*AuthClaims, error) <span class="cov9" title="8">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;AuthClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="7">{
                // Verify signing method
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov8" title="7">return []byte(s.config.JWTSecret), nil</span>
        })

        <span class="cov9" title="8">if err != nil </span><span class="cov5" title="3">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>

        <span class="cov7" title="5">if claims, ok := token.Claims.(*AuthClaims); ok &amp;&amp; token.Valid </span><span class="cov7" title="5">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("invalid token")</span>
}

// generateRandomString generates a random base64 encoded string
func (s *AuthService) generateRandomString(length int) (string, error) <span class="cov1" title="1">{
        bytes := make([]byte, length)
        _, err := rand.Read(bytes)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate random bytes: %w", err)
        }</span>
        <span class="cov1" title="1">return base64.URLEncoding.EncodeToString(bytes), nil</span>
}

func (s *AuthService) GetGitHubAccessToken(userUUID, provider string) (string, error) <span class="cov3" title="2">{
        if s == nil </span><span class="cov0" title="0">{
                return "", apperrors.ErrAuthServiceNotInitialized
        }</span>
        // check userUUID is not empty
        <span class="cov3" title="2">if userUUID == "" </span><span class="cov0" title="0">{
                return "", apperrors.ErrUserUUIDMissing
        }</span>
        // check provider is not empty
        <span class="cov3" title="2">if provider == "" </span><span class="cov0" title="0">{
                return "", apperrors.ErrProviderMissing
        }</span>

        // Use DB-backed token store
        <span class="cov3" title="2">if s.tokenStore == nil </span><span class="cov0" title="0">{
                return "", apperrors.ErrTokenStoreNotInitialized
        }</span>
        <span class="cov3" title="2">uid, err := uuid.Parse(userUUID)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid userUUID: %w", err)
        }</span>
        <span class="cov3" title="2">tok, err := s.tokenStore.GetValidToken(uid, provider)
        if err != nil || tok == nil || time.Now().After(tok.ExpiresAt) </span><span class="cov1" title="1">{
                return "", fmt.Errorf("no valid GitHub token found for user %s with provider %s", userUUID, provider)
        }</span>
        <span class="cov1" title="1">return tok.Token, nil</span>
}

// GetGitHubClient retrieves the GitHub client for a specific provider
func (s *AuthService) GetGitHubClient(provider string) (*GitHubClient, error) <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrAuthServiceNotInitialized
        }</span>

        <span class="cov0" title="0">client, exists := s.githubClients[provider]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GitHub client not found for provider %s", provider)
        }</span>
        <span class="cov0" title="0">return client, nil</span>
}

// Logout handles user logout (stateless JWT tokens don't require server-side logout)
func (s *AuthService) Logout() error <span class="cov1" title="1">{
        // For JWT tokens, logout is typically handled client-side by removing the token
        // In a production system, you might maintain a blacklist of invalidated tokens
        return nil
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package cache

import (
        "encoding/json"
        "errors"
        "time"

        gocache "github.com/patrickmn/go-cache"
)

// Common cache errors
var (
        ErrCacheMiss     = errors.New("cache miss")
        ErrCacheDisabled = errors.New("cache is disabled")
)

// CacheService defines the interface for caching operations.
// This interface allows swapping in-memory implementation for Redis without major refactoring.
type CacheService interface {
        // Get retrieves a value from cache by key
        Get(key string) ([]byte, error)
        // Set stores a value in cache with the given TTL
        Set(key string, value []byte, ttl time.Duration) error
        // Delete removes a value from cache
        Delete(key string) error
        // Clear removes all items from cache
        Clear()
        // GetWithTTL retrieves a value and checks if it exists
        GetWithTTL(key string) ([]byte, time.Duration, bool)
}

// CacheConfig holds configuration for the cache service
type CacheConfig struct {
        // DefaultTTL is the default expiration time for cached items
        DefaultTTL time.Duration
        // CleanupInterval is how often expired items are cleaned up
        CleanupInterval time.Duration
        // Enabled determines if caching is active
        Enabled bool
}

// DefaultCacheConfig returns a sensible default configuration
func DefaultCacheConfig() CacheConfig <span class="cov1" title="1">{
        return CacheConfig{
                DefaultTTL:      5 * time.Minute,
                CleanupInterval: 10 * time.Minute,
                Enabled:         true,
        }
}</span>

// InMemoryCache implements CacheService using go-cache
type InMemoryCache struct {
        cache   *gocache.Cache
        config  CacheConfig
        enabled bool
}

// NewInMemoryCache creates a new in-memory cache instance
func NewInMemoryCache(config CacheConfig) *InMemoryCache <span class="cov10" title="87">{
        return &amp;InMemoryCache{
                cache:   gocache.New(config.DefaultTTL, config.CleanupInterval),
                config:  config,
                enabled: config.Enabled,
        }
}</span>

// Get retrieves a value from the cache
func (c *InMemoryCache) Get(key string) ([]byte, error) <span class="cov7" title="23">{
        if !c.enabled </span><span class="cov1" title="1">{
                return nil, ErrCacheDisabled
        }</span>

        <span class="cov7" title="22">value, found := c.cache.Get(key)
        if !found </span><span class="cov6" title="16">{
                return nil, ErrCacheMiss
        }</span>

        <span class="cov4" title="6">data, ok := value.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrCacheMiss
        }</span>

        <span class="cov4" title="6">return data, nil</span>
}

// Set stores a value in the cache with the given TTL
func (c *InMemoryCache) Set(key string, value []byte, ttl time.Duration) error <span class="cov7" title="21">{
        if !c.enabled </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov7" title="20">if ttl &lt;= 0 </span><span class="cov1" title="1">{
                ttl = c.config.DefaultTTL
        }</span>

        <span class="cov7" title="20">c.cache.Set(key, value, ttl)
        return nil</span>
}

// Delete removes a value from the cache
func (c *InMemoryCache) Delete(key string) error <span class="cov3" title="3">{
        if !c.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov3" title="3">c.cache.Delete(key)
        return nil</span>
}

// Clear removes all items from the cache
func (c *InMemoryCache) Clear() <span class="cov2" title="2">{
        if c.enabled </span><span class="cov2" title="2">{
                c.cache.Flush()
        }</span>
}

// GetWithTTL retrieves a value and returns remaining TTL
func (c *InMemoryCache) GetWithTTL(key string) ([]byte, time.Duration, bool) <span class="cov2" title="2">{
        if !c.enabled </span><span class="cov0" title="0">{
                return nil, 0, false
        }</span>

        <span class="cov2" title="2">value, expiration, found := c.cache.GetWithExpiration(key)
        if !found </span><span class="cov1" title="1">{
                return nil, 0, false
        }</span>

        <span class="cov1" title="1">data, ok := value.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return nil, 0, false
        }</span>

        <span class="cov1" title="1">var remainingTTL time.Duration
        if !expiration.IsZero() </span><span class="cov1" title="1">{
                remainingTTL = time.Until(expiration)
        }</span>

        <span class="cov1" title="1">return data, remainingTTL, true</span>
}

// IsEnabled returns whether the cache is enabled
func (c *InMemoryCache) IsEnabled() bool <span class="cov0" title="0">{
        return c.enabled
}</span>

// SetEnabled enables or disables the cache
func (c *InMemoryCache) SetEnabled(enabled bool) <span class="cov2" title="2">{
        c.enabled = enabled
}</span>

// Stats returns cache statistics
func (c *InMemoryCache) Stats() map[string]interface{} <span class="cov1" title="1">{
        return map[string]interface{}{
                "item_count": c.cache.ItemCount(),
                "enabled":    c.enabled,
        }
}</span>

// NoOpCache implements CacheService but does nothing (useful for testing or when cache is disabled)
type NoOpCache struct{}

// NewNoOpCache creates a new no-op cache instance
func NewNoOpCache() *NoOpCache <span class="cov3" title="4">{
        return &amp;NoOpCache{}
}</span>

// Get always returns cache miss
func (c *NoOpCache) Get(key string) ([]byte, error) <span class="cov2" title="2">{
        return nil, ErrCacheDisabled
}</span>

// Set does nothing
func (c *NoOpCache) Set(key string, value []byte, ttl time.Duration) error <span class="cov1" title="1">{
        return nil
}</span>

// Delete does nothing
func (c *NoOpCache) Delete(key string) error <span class="cov1" title="1">{
        return nil
}</span>

// Clear does nothing
func (c *NoOpCache) Clear() {<span class="cov0" title="0">}</span>

// GetWithTTL always returns not found
func (c *NoOpCache) GetWithTTL(key string) ([]byte, time.Duration, bool) <span class="cov1" title="1">{
        return nil, 0, false
}</span>

// CacheWrapper provides helper methods for common caching patterns
type CacheWrapper[T any] struct {
        cache CacheService
}

// NewCacheWrapper creates a new cache wrapper for type T
func NewCacheWrapper[T any](cache CacheService) *CacheWrapper[T] <span class="cov9" title="61">{
        return &amp;CacheWrapper[T]{cache: cache}
}</span>

// GetOrFetch attempts to get from cache, or fetches and caches if not found
func (w *CacheWrapper[T]) GetOrFetch(key string, ttl time.Duration, fetchFn func() (T, error)) (T, error) <span class="cov9" title="65">{
        var result T

        // Try to get from cache
        data, err := w.cache.Get(key)
        if err == nil </span><span class="cov4" title="5">{
                if unmarshalErr := json.Unmarshal(data, &amp;result); unmarshalErr == nil </span><span class="cov4" title="5">{
                        return result, nil
                }</span>
        }

        // Fetch fresh data
        <span class="cov9" title="60">result, err = fetchFn()
        if err != nil </span><span class="cov6" title="16">{
                return result, err
        }</span>

        // Cache the result (ignore cache errors)
        <span class="cov8" title="44">if data, marshalErr := json.Marshal(result); marshalErr == nil </span><span class="cov8" title="44">{
                _ = w.cache.Set(key, data, ttl)
        }</span>

        <span class="cov8" title="44">return result, nil</span>
}

// Invalidate removes an item from the cache
func (w *CacheWrapper[T]) Invalidate(key string) error <span class="cov2" title="2">{
        return w.cache.Delete(key)
}</span>

// InvalidatePattern removes all items matching a key prefix
// Note: This is a basic implementation. For Redis, this would use SCAN/KEYS
func (w *CacheWrapper[T]) InvalidatePattern(prefix string) {<span class="cov0" title="0">
        // In-memory cache doesn't support pattern-based deletion directly
        // This would need to be implemented differently for Redis
        // For now, we rely on individual key deletion
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package cache

import "time"

// TTLConfig defines cache TTL durations for different endpoints/services
// These can be adjusted based on data freshness requirements
type TTLConfig struct {
        // Landscape service TTLs
        LandscapeList      time.Duration
        LandscapeByID      time.Duration
        LandscapeByName    time.Duration
        LandscapeByProject time.Duration
        LandscapeSearch    time.Duration

        // External API TTLs (for future use with Jira, GitHub, Sonar)
        JiraIssues          time.Duration
        JiraIssuesCount     time.Duration
        GitHubPullRequests  time.Duration
        GitHubContributions time.Duration
        SonarMeasures       time.Duration

        // Component service TTLs
        ComponentList   time.Duration
        ComponentByID   time.Duration
        ComponentHealth time.Duration

        // Default TTL for unspecified endpoints
        Default time.Duration
}

// DefaultTTLConfig returns default TTL configuration
// These values can be overridden via environment variables or config file
func DefaultTTLConfig() TTLConfig <span class="cov9" title="75">{
        return TTLConfig{
                // Landscape data changes infrequently - use longer TTLs
                LandscapeList:      5 * time.Minute,
                LandscapeByID:      5 * time.Minute,
                LandscapeByName:    5 * time.Minute,
                LandscapeByProject: 5 * time.Minute,
                LandscapeSearch:    2 * time.Minute,

                // External APIs - shorter TTLs for more dynamic data
                JiraIssues:          2 * time.Minute,
                JiraIssuesCount:     1 * time.Minute,
                GitHubPullRequests:  3 * time.Minute,
                GitHubContributions: 10 * time.Minute,
                SonarMeasures:       5 * time.Minute,

                // Component data
                ComponentList:   5 * time.Minute,
                ComponentByID:   5 * time.Minute,
                ComponentHealth: 30 * time.Second, // Health checks need to be fresh

                // Default
                Default: 5 * time.Minute,
        }
}</span>

// CacheKeyPrefix defines prefixes for cache keys to organize cached data
type CacheKeyPrefix string

const (
        // Landscape cache key prefixes
        KeyPrefixLandscapeList      CacheKeyPrefix = "landscape:list"
        KeyPrefixLandscapeByID      CacheKeyPrefix = "landscape:id"
        KeyPrefixLandscapeByName    CacheKeyPrefix = "landscape:name"
        KeyPrefixLandscapeByProject CacheKeyPrefix = "landscape:project"
        KeyPrefixLandscapeSearch    CacheKeyPrefix = "landscape:search"

        // External API cache key prefixes
        KeyPrefixJiraIssues      CacheKeyPrefix = "jira:issues"
        KeyPrefixJiraIssuesCount CacheKeyPrefix = "jira:issues:count"
        KeyPrefixGitHubPRs       CacheKeyPrefix = "github:prs"
        KeyPrefixGitHubContrib   CacheKeyPrefix = "github:contributions"
        KeyPrefixSonarMeasures   CacheKeyPrefix = "sonar:measures"

        // Component cache key prefixes
        KeyPrefixComponentList   CacheKeyPrefix = "component:list"
        KeyPrefixComponentByID   CacheKeyPrefix = "component:id"
        KeyPrefixComponentHealth CacheKeyPrefix = "component:health"
)

// BuildKey constructs a cache key from prefix and identifiers
func BuildKey(prefix CacheKeyPrefix, parts ...string) string <span class="cov9" title="77">{
        key := string(prefix)
        for _, part := range parts </span><span class="cov10" title="84">{
                key += ":" + part
        }</span>
        <span class="cov9" title="77">return key</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package client

import (
        "bytes"
        apperrors "developer-portal-backend/internal/errors"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strings"
        "time"
)

// AlertHistoryClient handles communication with the external alert history service
type AlertHistoryClient struct {
        BaseURL    string
        HTTPClient *http.Client
}

// NewAlertHistoryClient creates a new alert history API client
func NewAlertHistoryClient(baseURL string) *AlertHistoryClient <span class="cov0" title="0">{
        return &amp;AlertHistoryClient{
                BaseURL: strings.TrimSuffix(baseURL, "/"),
                HTTPClient: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
        }
}</span>

// AlertHistoryResponse represents a single alert from the external service
type AlertHistoryResponse struct {
        Fingerprint string                 `json:"fingerprint"`
        Alertname   string                 `json:"alertname"`
        Status      string                 `json:"status"`
        Severity    string                 `json:"severity"`
        Landscape   string                 `json:"landscape"`
        Region      string                 `json:"region"`
        StartsAt    string                 `json:"startsAt"`
        EndsAt      *string                `json:"endsAt"`
        Labels      map[string]interface{} `json:"labels"`
        Annotations map[string]interface{} `json:"annotations"`
        CreatedAt   string                 `json:"createdAt"`
        UpdatedAt   string                 `json:"updatedAt"`
}

// AlertHistoryPaginatedResponse represents paginated alerts from the external service
type AlertHistoryPaginatedResponse struct {
        Data       []AlertHistoryResponse `json:"data"`
        Page       int                    `json:"page"`
        PageSize   int                    `json:"pageSize"`
        TotalCount int64                  `json:"totalCount"`
        TotalPages int                    `json:"totalPages"`
}

// ProjectsResponse represents the list of available projects
type ProjectsResponse struct {
        Projects []string `json:"projects"`
}

// UpdateLabelRequest represents a label update request
type UpdateLabelRequest struct {
        Key   string `json:"key"`
        Value string `json:"value"`
}

// UpdateLabelResponse represents the response after updating a label
type UpdateLabelResponse struct {
        Message     string `json:"message"`
        Project     string `json:"project"`
        Fingerprint string `json:"fingerprint"`
        Label       struct {
                Key   string `json:"key"`
                Value string `json:"value"`
        } `json:"label"`
}

// AlertFiltersResponse represents available filter values for alerts
// Uses a dynamic map to support any filter fields without hardcoding
type AlertFiltersResponse map[string][]string

// GetAvailableProjects retrieves all available projects from the alert history service
func (c *AlertHistoryClient) GetAvailableProjects() (*ProjectsResponse, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/api/projects", c.BaseURL)

        resp, err := c.HTTPClient.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to call alert history service: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("alert history service returned status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var result ProjectsResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;result, nil</span>
}

// GetAlertsByProject retrieves alerts for a specific project with filters
func (c *AlertHistoryClient) GetAlertsByProject(project string, params map[string]string) (*AlertHistoryPaginatedResponse, error) <span class="cov0" title="0">{
        // Build URL with query parameters
        baseURL := fmt.Sprintf("%s/api/alerts/%s", c.BaseURL, project)

        queryParams := url.Values{}
        for key, value := range params </span><span class="cov0" title="0">{
                if value != "" </span><span class="cov0" title="0">{
                        queryParams.Add(key, value)
                }</span>
        }

        <span class="cov0" title="0">fullURL := baseURL
        if len(queryParams) &gt; 0 </span><span class="cov0" title="0">{
                fullURL = fmt.Sprintf("%s?%s", baseURL, queryParams.Encode())
        }</span>

        <span class="cov0" title="0">resp, err := c.HTTPClient.Get(fullURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to call alert history service: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("alert history service returned status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var result AlertHistoryPaginatedResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;result, nil</span>
}

// GetAlertByFingerprint retrieves a specific alert by fingerprint
func (c *AlertHistoryClient) GetAlertByFingerprint(project, fingerprint string) (*AlertHistoryResponse, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/api/alerts/%s/%s", c.BaseURL, project, fingerprint)

        resp, err := c.HTTPClient.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to call alert history service: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return nil, apperrors.ErrAlertNotFound
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("alert history service returned status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var result AlertHistoryResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;result, nil</span>
}

// UpdateAlertLabel updates or adds a label to an alert
func (c *AlertHistoryClient) UpdateAlertLabel(project, fingerprint string, request UpdateLabelRequest) (*UpdateLabelResponse, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/api/alerts/%s/%s/label", c.BaseURL, project, fingerprint)

        jsonData, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("PUT", url, bytes.NewReader(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to call alert history service: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return nil, apperrors.ErrAlertNotFound
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("alert history service returned status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var result UpdateLabelResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;result, nil</span>
}

// GetAlertFilters retrieves available filter values for alerts in a specific project
func (c *AlertHistoryClient) GetAlertFilters(project string, params map[string]string) (*AlertFiltersResponse, error) <span class="cov0" title="0">{
        // Build URL with query parameters
        baseURL := fmt.Sprintf("%s/api/alerts/%s/filters", c.BaseURL, project)

        queryParams := url.Values{}
        for key, value := range params </span><span class="cov0" title="0">{
                if value != "" </span><span class="cov0" title="0">{
                        queryParams.Add(key, value)
                }</span>
        }

        <span class="cov0" title="0">fullURL := baseURL
        if len(queryParams) &gt; 0 </span><span class="cov0" title="0">{
                fullURL = fmt.Sprintf("%s?%s", baseURL, queryParams.Encode())
        }</span>

        <span class="cov0" title="0">resp, err := c.HTTPClient.Get(fullURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to call alert history service: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project not found")
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("alert history service returned status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var result AlertFiltersResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;result, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package config

import (
        "fmt"

        "github.com/spf13/viper"
)

// Config holds all configuration for the application
type Config struct {
        Environment       string `mapstructure:"ENVIRONMENT"`
        DeployEnvironment string `mapstructure:"DEPLOY_ENVIRONMENT"`
        Port              string `mapstructure:"PORT"`
        LogLevel          string `mapstructure:"LOG_LEVEL"`

        // Database configuration
        DatabaseURL      string `mapstructure:"DATABASE_URL"`
        DatabaseHost     string `mapstructure:"DB_HOST"`
        DatabasePort     string `mapstructure:"DB_PORT"`
        DatabaseUser     string `mapstructure:"DB_USER"`
        DatabasePassword string `mapstructure:"DB_PASSWORD"`
        DatabaseName     string `mapstructure:"DB_NAME"`
        DatabaseSSLMode  string `mapstructure:"DB_SSL_MODE"`

        // JWT configuration
        JWTSecret string `mapstructure:"JWT_SECRET"`

        // CORS configuration
        AllowedOrigins []string `mapstructure:"ALLOWED_ORIGINS"`

        // LDAP configuration
        LDAPHost               string `mapstructure:"LDAP_HOST"`
        LDAPPort               string `mapstructure:"LDAP_PORT"`
        LDAPBindDN             string `mapstructure:"LDAP_BIND_DN"`
        LDAPBindPW             string `mapstructure:"LDAP_BIND_PW"`
        LDAPBaseDN             string `mapstructure:"LDAP_BASE_DN"`
        LDAPInsecureSkipVerify bool   `mapstructure:"LDAP_INSECURE_SKIP_VERIFY"`
        LDAPTimeoutSec         int    `mapstructure:"LDAP_TIMEOUT_SEC"`

        // Jira configuration
        JiraDomain   string `mapstructure:"JIRA_DOMAIN"`
        JiraUser     string `mapstructure:"JIRA_USER"`
        JiraPassword string `mapstructure:"JIRA_PASSWORD"`

        // Sonar configuration
        SonarHost  string `mapstructure:"SONAR_HOST"`
        SonarToken string `mapstructure:"SONAR_TOKEN"`

        // Jenkins configuration
        JenkinsBaseURL            string `mapstructure:"JENKINS_BASE_URL"`
        JenkinsInsecureSkipVerify bool   `mapstructure:"JENKINS_INSECURE_SKIP_VERIFY"`

        // Monitoring service configuration
        MonitoringServiceURL string `mapstructure:"MONITORING_SERVICE_URL"`
}

// Load reads configuration from environment variables and config files
func Load() (*Config, error) <span class="cov0" title="0">{
        viper.SetConfigName("config")
        viper.SetConfigType("yaml")
        viper.AddConfigPath(".")
        viper.AddConfigPath("./config")

        // Set default values
        setDefaults()

        // Read config file if it exists
        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error reading config file: %w", err)
                }</span>
        }

        // Override with environment variables
        <span class="cov0" title="0">viper.AutomaticEnv()

        var config Config
        if err := viper.Unmarshal(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error unmarshaling config: %w", err)
        }</span>

        // Build database URL if not provided
        <span class="cov0" title="0">if config.DatabaseURL == "" </span><span class="cov0" title="0">{
                config.DatabaseURL = buildDatabaseURL(&amp;config)
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if err := validate(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

func setDefaults() <span class="cov0" title="0">{
        viper.SetDefault("ENVIRONMENT", "development")
        viper.SetDefault("DEPLOY_ENVIRONMENT", "local")
        viper.SetDefault("PORT", "7008")
        viper.SetDefault("LOG_LEVEL", "info")

        // Database defaults
        viper.SetDefault("DB_HOST", "localhost")
        viper.SetDefault("DB_PORT", "5432")
        viper.SetDefault("DB_USER", "postgres")
        viper.SetDefault("DB_PASSWORD", "postgres")
        viper.SetDefault("DB_NAME", "developer_portal")
        viper.SetDefault("DB_SSL_MODE", "disable")

        // JWT defaults
        viper.SetDefault("JWT_SECRET", "your-secret-key-change-in-production")

        // CORS defaults
        viper.SetDefault("ALLOWED_ORIGINS", []string{"http://localhost:3000", "http://localhost:8080"})

        // LDAP defaults
        viper.SetDefault("LDAP_HOST", "ldap.example.com")
        viper.SetDefault("LDAP_PORT", "636")
        viper.SetDefault("LDAP_BIND_DN", "CN=John Doe,OU=Users,DC=example,DC=com")
        viper.SetDefault("LDAP_BIND_PW", "SuperSecret123")
        viper.SetDefault("LDAP_BASE_DN", "DC=example,DC=com")
        viper.SetDefault("LDAP_INSECURE_SKIP_VERIFY", true)
        viper.SetDefault("LDAP_TIMEOUT_SEC", 10)

        // Jira defaults
        viper.SetDefault("JIRA_DOMAIN", "")
        viper.SetDefault("JIRA_USER", "")
        viper.SetDefault("JIRA_PASSWORD", "")

        // Sonar defaults
        viper.SetDefault("SONAR_HOST", "")
        viper.SetDefault("SONAR_TOKEN", "")

        // Jenkins defaults - production uses real JAAS URL pattern
        viper.SetDefault("JENKINS_BASE_URL", "https://{jaasName}.jaas-gcp.cloud.sap.corp")
        viper.SetDefault("JENKINS_INSECURE_SKIP_VERIFY", true)

        // Monitoring service defaults
        viper.SetDefault("MONITORING_SERVICE_URL", "http://localhost:8085")
}</span>

func buildDatabaseURL(config *Config) string <span class="cov0" title="0">{
        return fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=%s",
                config.DatabaseUser,
                config.DatabasePassword,
                config.DatabaseHost,
                config.DatabasePort,
                config.DatabaseName,
                config.DatabaseSSLMode,
        )
}</span>

func validate(config *Config) error <span class="cov0" title="0">{
        if config.Environment == "production" </span><span class="cov0" title="0">{
                if config.JWTSecret == "your-secret-key-change-in-production" </span><span class="cov0" title="0">{
                        return fmt.Errorf("JWT_SECRET must be set in production")
                }</span>
        }

        <span class="cov0" title="0">if config.DatabaseName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database name is required")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// IsDevelopment returns true if the environment is development
func (c *Config) IsDevelopment() bool <span class="cov0" title="0">{
        return c.Environment == "development"
}</span>

// IsProduction returns true if the environment is production
func (c *Config) IsProduction() bool <span class="cov0" title="0">{
        return c.Environment == "production"
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package database

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "reflect"
        "strings"
)

// loadFromYAMLFile is a generic YAML loader for a single filename in a directory.
// It returns an empty slice if the file is not found or empty.
func loadFromYAMLFile[T any](dataDir, filename string, decode func([]byte) ([]T, error)) ([]T, error) <span class="cov4" title="14">{
        path := filepath.Join(dataDir, filename)

        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov1" title="1">{
                // If the file is missing, return empty slice (no-op)
                if os.IsNotExist(err) </span><span class="cov1" title="1">{
                        return []T{}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov4" title="13">if len(data) == 0 </span><span class="cov1" title="1">{
                return []T{}, nil
        }</span>

        <span class="cov4" title="12">items, err := decode(data)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov4" title="11">return items, nil</span>
}

// jsonEqual compares two JSON payloads semantically (ignoring key order)
func jsonEqual(a json.RawMessage, b []byte) bool <span class="cov3" title="6">{
        var ja interface{}
        var jb interface{}
        // Normalize nil/empty cases
        if len(a) == 0 &amp;&amp; len(b) == 0 </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov3" title="5">if err := json.Unmarshal(a, &amp;ja); err != nil </span><span class="cov1" title="2">{
                // If existing DB value is empty or invalid, treat as unequal unless b is also empty
                if len(a) == 0 &amp;&amp; len(b) == 0 </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov1" title="2">return false</span>
        }
        <span class="cov2" title="3">if err := json.Unmarshal(b, &amp;jb); err != nil </span><span class="cov1" title="1">{
                // If YAML metadata failed to unmarshal, treat as unequal
                return false
        }</span>
        <span class="cov1" title="2">return reflect.DeepEqual(ja, jb)</span>
}

/*
mergeJSON merges two JSON object payloads from raw bytes.

- a: existing JSON (from DB), provided as json.RawMessage
- b: overriding JSON (from YAML or input), provided as []byte

Behavior:
- If both are JSON objects, fields are merged recursively with b taking precedence.
- If either payload is invalid JSON or not an object, returns an error.
- Empty payloads are treated as empty objects.

Returns the merged JSON as []byte or an error.
*/
func mergeJSON(a json.RawMessage, b []byte) ([]byte, error) <span class="cov3" title="5">{
        var ma map[string]interface{}
        var mb map[string]interface{}

        // Unmarshal 'a'
        if len(a) == 0 </span><span class="cov0" title="0">{
                ma = map[string]interface{}{}
        }</span> else<span class="cov3" title="5"> {
                if err := json.Unmarshal(a, &amp;ma); err != nil </span><span class="cov1" title="2">{
                        return nil, fmt.Errorf("mergeJSON: invalid JSON 'a': %w", err)
                }</span>
                <span class="cov2" title="3">if ma == nil </span><span class="cov0" title="0">{
                        ma = map[string]interface{}{}
                }</span>
        }

        // Unmarshal 'b'
        <span class="cov2" title="3">if len(b) == 0 </span><span class="cov0" title="0">{
                mb = map[string]interface{}{}
        }</span> else<span class="cov2" title="3"> {
                if err := json.Unmarshal(b, &amp;mb); err != nil </span><span class="cov1" title="2">{
                        return nil, fmt.Errorf("mergeJSON: invalid JSON 'b': %w", err)
                }</span>
                <span class="cov1" title="1">if mb == nil </span><span class="cov0" title="0">{
                        mb = map[string]interface{}{}
                }</span>
        }

        <span class="cov1" title="1">merged := mergeMaps(ma, mb)

        out, err := json.Marshal(merged)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("mergeJSON: marshal error: %w", err)
        }</span>
        <span class="cov1" title="1">return out, nil</span>
}

// mergeMaps performs a deep merge of two map[string]interface{} with b overriding a
func mergeMaps(a, b map[string]interface{}) map[string]interface{} <span class="cov1" title="2">{
        if a == nil </span><span class="cov0" title="0">{
                a = map[string]interface{}{}
        }</span>
        <span class="cov1" title="2">for k, v := range b </span><span class="cov2" title="4">{
                if bv, ok := v.(map[string]interface{}); ok </span><span class="cov1" title="1">{
                        if av, ok2 := a[k].(map[string]interface{}); ok2 </span><span class="cov1" title="1">{
                                a[k] = mergeMaps(av, bv)
                        }</span> else<span class="cov0" title="0"> {
                                a[k] = mergeMaps(map[string]interface{}{}, bv)
                        }</span>
                } else<span class="cov2" title="3"> {
                        a[k] = v
                }</span>
        }
        <span class="cov1" title="2">return a</span>
}

// slugifyTitle creates a URL-friendly name from a title
func slugifyTitle(s string) string <span class="cov6" title="79">{
        s = strings.ToLower(s)
        var b strings.Builder
        prevHyphen := false
        for _, r := range s </span><span class="cov10" title="1049">{
                if (r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= '0' &amp;&amp; r &lt;= '9') </span><span class="cov9" title="906">{
                        b.WriteRune(r)
                        prevHyphen = false
                }</span> else<span class="cov7" title="143"> {
                        if !prevHyphen </span><span class="cov7" title="117">{
                                b.WriteByte('-')
                                prevHyphen = true
                        }</span>
                }
        }
        <span class="cov6" title="79">out := strings.Trim(b.String(), "-")
        if out == "" </span><span class="cov1" title="2">{
                out = "link"
        }</span>
        <span class="cov6" title="79">return out</span>
}

// normalizeTagsCSV converts various YAML tag formats into a canonical CSV string
func normalizeTagsCSV(raw interface{}) string <span class="cov6" title="77">{
        if raw == nil </span><span class="cov2" title="3">{
                return ""
        }</span>
        <span class="cov6" title="74">switch v := raw.(type) </span>{
        case string:<span class="cov6" title="67">
                parts := strings.Split(v, ",")
                out := make([]string, 0, len(parts))
                for _, p := range parts </span><span class="cov7" title="155">{
                        t := strings.TrimSpace(p)
                        if t != "" </span><span class="cov7" title="154">{
                                out = append(out, t)
                        }</span>
                }
                <span class="cov6" title="67">return strings.Join(out, ",")</span>
        case []interface{}:<span class="cov3" title="6">
                out := make([]string, 0, len(v))
                for _, it := range v </span><span class="cov3" title="5">{
                        if s, ok := it.(string); ok </span><span class="cov2" title="4">{
                                s = strings.TrimSpace(s)
                                if s != "" </span><span class="cov2" title="3">{
                                        out = append(out, s)
                                }</span>
                        }
                }
                <span class="cov3" title="6">return strings.Join(out, ",")</span>
        default:<span class="cov1" title="1">
                return ""</span>
        }
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package database

import (
        "fmt"
        "log"
        "os"
        "path/filepath"
        "time"

        "developer-portal-backend/internal/database/models"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

type Options struct {
        LogLevel        logger.LogLevel
        MaxOpenConns    int
        MaxIdleConns    int
        ConnMaxLifetime time.Duration
        ConnMaxIdleTime time.Duration
        AutoMigrate     bool
}

// Initialize opens a Postgres connection and creates the schema from GORM models.
// Simplified single-phase AutoMigrate since cyclic foreign keys were removed.
func Initialize(dsn string, opts *Options) (*gorm.DB, error) <span class="cov1" title="1">{
        log.Print("Initializing database...")
        // Defaults
        if opts == nil </span><span class="cov1" title="1">{
                opts = &amp;Options{}
        }</span>
        <span class="cov1" title="1">if opts.LogLevel == 0 </span><span class="cov1" title="1">{
                opts.LogLevel = logger.Error
        }</span>
        <span class="cov1" title="1">if opts.MaxOpenConns == 0 </span><span class="cov1" title="1">{
                opts.MaxOpenConns = 20
        }</span>
        <span class="cov1" title="1">if opts.MaxIdleConns == 0 </span><span class="cov1" title="1">{
                opts.MaxIdleConns = 10
        }</span>
        <span class="cov1" title="1">if opts.ConnMaxLifetime == 0 </span><span class="cov1" title="1">{
                opts.ConnMaxLifetime = 30 * time.Minute
        }</span>
        <span class="cov1" title="1">if opts.ConnMaxIdleTime == 0 </span><span class="cov1" title="1">{
                opts.ConnMaxIdleTime = 10 * time.Minute
        }</span>
        <span class="cov1" title="1">if !opts.AutoMigrate </span><span class="cov1" title="1">{
                opts.AutoMigrate = true
        }</span>

        <span class="cov1" title="1">dataDir, err := resolveDataDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Open DB
        <span class="cov1" title="1">db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{
                Logger: logger.Default.LogMode(opts.LogLevel),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("open postgres: %w", err)
        }</span>
        <span class="cov1" title="1">if sqlDB, err := db.DB(); err == nil </span><span class="cov1" title="1">{
                sqlDB.SetMaxOpenConns(opts.MaxOpenConns)
                sqlDB.SetMaxIdleConns(opts.MaxIdleConns)
                sqlDB.SetConnMaxLifetime(opts.ConnMaxLifetime)
                sqlDB.SetConnMaxIdleTime(opts.ConnMaxIdleTime)
        }</span>

        // Ensure required extension for UUID generation (used by BaseModel default gen_random_uuid())
        <span class="cov1" title="1">_ = db.Exec(`CREATE EXTENSION IF NOT EXISTS pgcrypto`).Error

        // AutoMigrate all models (no cycles)
        if opts.AutoMigrate </span><span class="cov1" title="1">{
                all := []interface{}{
                        &amp;models.Organization{},
                        &amp;models.Group{},
                        &amp;models.User{},
                        &amp;models.Team{},
                        &amp;models.Documentation{},
                        &amp;models.Landscape{},
                        &amp;models.Project{},
                        &amp;models.Component{},
                        &amp;models.Category{},
                        &amp;models.Link{},
                        &amp;models.Plugin{},
                        &amp;models.Token{},
                }
                if err := db.AutoMigrate(all...); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("auto-migrate: %w", err)
                }</span>

        }

        <span class="cov1" title="1">if err := CreateIndexes(db); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create indexes: %w", err)
        }</span>
        <span class="cov1" title="1">if err := ErrorsFix(db); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fix errors in database: %w", err)
        }</span>

        <span class="cov1" title="1">if err := InitDataFromYAMLs(db, dataDir); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed init data from YAML files: %w", err)
        }</span>
        <span class="cov1" title="1">log.Print("Initializing database done.")
        return db, nil</span>
}

func resolveDataDir() (string, error) <span class="cov1" title="1">{
        // Try common locations to accommodate local runs, tests, and containers
        candidates := []string{
                "scripts/data",
                "/app/scripts/data",
        }
        // Walk up from current working directory to find scripts/data
        if wd, err := os.Getwd(); err == nil </span><span class="cov1" title="1">{
                dir := wd
                for i := 0; i &lt; 5 &amp;&amp; dir != "/" &amp;&amp; dir != ""; i++ </span><span class="cov10" title="5">{
                        p := filepath.Join(dir, "scripts", "data")
                        candidates = append(candidates, p)
                        parent := filepath.Dir(dir)
                        if parent == dir </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov10" title="5">dir = parent</span>
                }
        }
        <span class="cov1" title="1">for _, p := range candidates </span><span class="cov10" title="5">{
                if fi, err := os.Stat(p); err == nil &amp;&amp; fi.IsDir() </span><span class="cov1" title="1">{
                        return p, nil
                }</span>
        }
        <span class="cov0" title="0">return "", fmt.Errorf("data directory not found: tried %v", candidates)</span>
}

func CreateIndexes(db *gorm.DB) error <span class="cov1" title="1">{
        // Ensure unique index on organizations.name
        if err := db.Exec(`CREATE UNIQUE INDEX IF NOT EXISTS organizations_name_unique ON organizations (name)`).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create unique index organizations.name: %w", err)
        }</span>
        // Ensure unique index on group.name with org_id
        <span class="cov1" title="1">if err := db.Exec(`CREATE UNIQUE INDEX IF NOT EXISTS groups_name_org_id_unique ON groups (name, org_id)`).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create unique index groups.name+organization_id: %w", err)
        }</span>
        // Ensure unique index on team.name with group_id
        <span class="cov1" title="1">if err := db.Exec(`CREATE UNIQUE INDEX IF NOT EXISTS teams_name_group_id_unique ON teams (name, group_id)`).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create unique index teams.name+group_id: %w", err)
        }</span>
        // Ensure unique index on project.name
        <span class="cov1" title="1">if err := db.Exec(`CREATE UNIQUE INDEX IF NOT EXISTS projects_name_unique ON projects (name)`).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create unique index projects.name: %w", err)
        }</span>
        // Ensure unique index on landscape.name and project_id
        <span class="cov1" title="1">if err := db.Exec(`CREATE UNIQUE INDEX IF NOT EXISTS landscapes_name_project_id_unique ON landscapes (name, project_id)`).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create unique index landscapes.name+project_id: %w", err)
        }</span>
        // Ensure unique index on component.name and project_id
        <span class="cov1" title="1">if err := db.Exec(`CREATE UNIQUE INDEX IF NOT EXISTS components_name_project_id_unique ON components (name, project_id)`).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create unique index components.name+project_id: %w", err)
        }</span>
        // Ensure unique index on link.name and category_id
        <span class="cov1" title="1">if err := db.Exec(`CREATE UNIQUE INDEX IF NOT EXISTS links_name_category_id_unique ON links (name, category_id)`).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create unique index links.name+category_id: %w", err)
        }</span>
        // Ensure unique index on category.name
        <span class="cov1" title="1">if err := db.Exec(`CREATE UNIQUE INDEX IF NOT EXISTS categories_name_unique ON categories (name)`).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create unique index categories.name: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ErrorsFix removes known erroneous data from early versions of the database.
// most of those fixes can be removed after a version was deployed to 'dev' and 'prod' environments, as they are one-time fixes.
func ErrorsFix(db *gorm.DB) error <span class="cov1" title="1">{
        // remove components which belong to project 'internal' - this was a test project created in early versions:
        if err := db.Exec(`DELETE FROM components WHERE project_id IN (SELECT id FROM projects WHERE name = ?)`, "internal").Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // remove projects with name 'noe' or 'internal' - these were test projects created in early versions:
        <span class="cov1" title="1">if err := db.Exec(`DELETE FROM projects WHERE name IN (?,?)`, "noe", "internal").Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // remove 'health-success-regex' metadata entries from all projects - these had invalid data structures in early versions:
        <span class="cov1" title="1">if err := db.Exec(`UPDATE projects SET metadata = jsonb_strip_nulls(metadata - 'health-success-regex') WHERE metadata ? 'health-success-regex'`).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package database

import (
        "developer-portal-backend/internal/database/models"
        "encoding/json"
        "fmt"
        "log"
        "strings"

        "github.com/google/uuid"
        "gopkg.in/yaml.v3"
        "gorm.io/gorm"
)

// InitDataFromYAMLs migrate data from yaml files into db tables base on logic:
// check if row exists (predefined index - not UUID based) and whether it was changed,
// then decide whether to insert, update or do noting
func InitDataFromYAMLs(db *gorm.DB, dataDir string) error <span class="cov1" title="1">{
        if err := handleOrganizationsFromYAML(db, dataDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := handleGroupsFromYAML(db, dataDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := handleTeamsFromYAML(db, dataDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := handleUsersFromYAML(db, dataDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := handleProjectsFromYAML(db, dataDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := handleLandscapesFromYAML(db, dataDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := handleComponentsFromYAML(db, dataDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := handleCategoriesFromYAML(db, dataDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := handleLinksFromYAML(db, dataDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := handlePluginsFromYAML(db, dataDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func decodeOrganizations(b []byte) ([]OrganizationData, error) <span class="cov1" title="1">{
        var file OrganizationsFile
        if err := yaml.Unmarshal(b, &amp;file); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return file.Organizations, nil</span>
}

func decodeGroups(b []byte) ([]GroupData, error) <span class="cov1" title="1">{
        var file GroupsFile
        if err := yaml.Unmarshal(b, &amp;file); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return file.Groups, nil</span>
}

func decodeTeams(b []byte) ([]TeamData, error) <span class="cov1" title="1">{
        var file TeamsFile
        if err := yaml.Unmarshal(b, &amp;file); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return file.Teams, nil</span>
}

func decodeUsers(b []byte) ([]UserData, error) <span class="cov1" title="1">{
        var file UsersFile
        if err := yaml.Unmarshal(b, &amp;file); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return file.Users, nil</span>
}

func decodeProjects(b []byte) ([]ProjectData, error) <span class="cov1" title="1">{
        var file ProjectsFile
        if err := yaml.Unmarshal(b, &amp;file); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return file.Projects, nil</span>
}

func decodeLandscapes(b []byte) ([]LandscapeData, error) <span class="cov1" title="1">{
        var file LandscapesFile
        if err := yaml.Unmarshal(b, &amp;file); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return file.Landscapes, nil</span>
}

func decodeComponents(b []byte) ([]ComponentData, error) <span class="cov1" title="1">{
        var file ComponentsFile
        if err := yaml.Unmarshal(b, &amp;file); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return file.Components, nil</span>
}

func decodeCategories(b []byte) ([]CategoryData, error) <span class="cov1" title="1">{
        var file CategoriesFile
        if err := yaml.Unmarshal(b, &amp;file); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return file.Categories, nil</span>
}

func decodeLinks(b []byte) ([]LinkData, error) <span class="cov1" title="1">{
        var file LinksFile
        if err := yaml.Unmarshal(b, &amp;file); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return file.Links, nil</span>
}

func decodePlugins(b []byte) ([]PluginData, error) <span class="cov1" title="1">{
        var file PluginsFile
        if err := yaml.Unmarshal(b, &amp;file); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return file.Plugins, nil</span>
}

func handleOrganizationsFromYAML(db *gorm.DB, dataDir string) error <span class="cov1" title="1">{
        // Incremental upsert: insert new organizations, update existing if any mutable field changed.
        items, err := loadFromYAMLFile[OrganizationData](dataDir, "organizations.yaml", decodeOrganizations)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("load Organizations from YAML: %w", err)
        }</span>

        <span class="cov1" title="1">return db.Transaction(func(tx *gorm.DB) error </span><span class="cov1" title="1">{
                created := 0
                updated := 0
                unchanged := 0

                for _, o := range items </span><span class="cov1" title="1">{
                        // Lookup by unique key (name) without triggering ErrRecordNotFound logs
                        var org models.Organization
                        lookup := tx.Where("name = ?", o.Name).Limit(1).Find(&amp;org)
                        if lookup.Error != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("query organization %s: %w", o.Name, lookup.Error)
                        }</span>

                        <span class="cov1" title="1">if lookup.RowsAffected == 0 </span><span class="cov1" title="1">{
                                // Create new organization
                                metadataJSON, err := json.Marshal(o.Metadata)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("marshal organization %s metadata: %w", o.Name, err)
                                }</span>
                                <span class="cov1" title="1">newOrg := models.Organization{
                                        BaseModel: models.BaseModel{
                                                Name:        o.Name,
                                                Title:       o.Title,
                                                Description: o.Description,
                                                CreatedBy:   "cis.devops",
                                                Metadata:    metadataJSON,
                                        },
                                        Owner: o.Owner,
                                        Email: o.Email,
                                }
                                if err := tx.Create(&amp;newOrg).Error; err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to create organization: %w", err)
                                }</span>
                                <span class="cov1" title="1">created++
                                continue</span>
                        }

                        // Existing: check if data is identical (including metadata; treat nil YAML metadata as no change)
                        <span class="cov0" title="0">yamlMD, err := json.Marshal(o.Metadata)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("marshal organization %s metadata: %w", o.Name, err)
                        }</span>
                        // Merge DB metadata with YAML overrides (YAML wins on conflicts) for comparison
                        <span class="cov0" title="0">var mergedMD []byte
                        if o.Metadata != nil </span><span class="cov0" title="0">{
                                if md, err := mergeJSON(org.Metadata, yamlMD); err == nil </span><span class="cov0" title="0">{
                                        mergedMD = md
                                }</span> else<span class="cov0" title="0"> {
                                        // Fallback to YAML if merge fails
                                        mergedMD = yamlMD
                                }</span>
                        }
                        <span class="cov0" title="0">identical := org.Title == o.Title &amp;&amp;
                                org.Description == o.Description &amp;&amp;
                                org.Owner == o.Owner &amp;&amp;
                                org.Email == o.Email &amp;&amp;
                                (o.Metadata == nil || jsonEqual(org.Metadata, mergedMD))

                        if identical </span><span class="cov0" title="0">{
                                unchanged++
                                continue</span> // no-op
                        }

                        // Update mutable fields (do not touch id, created_at, created_by)
                        <span class="cov0" title="0">updates := map[string]interface{}{
                                "title":       o.Title,
                                "description": o.Description,
                                "owner":       o.Owner,
                                "email":       o.Email,
                                "updated_by":  "cis.devops",
                                "updated_at":  gorm.Expr("CURRENT_TIMESTAMP"),
                        }
                        // Update metadata only if provided in YAML (merge DB + YAML where YAML overrides)
                        if o.Metadata != nil </span><span class="cov0" title="0">{
                                if mergedMD != nil </span><span class="cov0" title="0">{
                                        updates["metadata"] = mergedMD
                                }</span> else<span class="cov0" title="0"> {
                                        updates["metadata"] = yamlMD
                                }</span>
                        }

                        <span class="cov0" title="0">if err := tx.Model(&amp;org).Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("update organization %s: %w", o.Name, err)
                        }</span>
                        <span class="cov0" title="0">updated++</span>
                }

                <span class="cov1" title="1">log.Printf("Organizations handling completed. %d created, %d updated, %d unchanged, %d total in YAML", created, updated, unchanged, len(items))
                return nil</span>
        })
}

func handleGroupsFromYAML(db *gorm.DB, dataDir string) error <span class="cov1" title="1">{
        items, err := loadFromYAMLFile[GroupData](dataDir, "groups.yaml", decodeGroups)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("load Groups from YAML: %w", err)
        }</span>

        <span class="cov1" title="1">return db.Transaction(func(tx *gorm.DB) error </span><span class="cov1" title="1">{
                created := 0
                updated := 0
                unchanged := 0

                for _, g := range items </span><span class="cov3" title="8">{
                        // Resolve organization by name (without ErrRecordNotFound logs)
                        var org models.Organization
                        orgTx := tx.Where("name = ?", g.OrgName).Limit(1).Find(&amp;org)
                        if orgTx.Error != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("query organization %s for group %s: %w", g.OrgName, g.Name, orgTx.Error)
                        }</span>
                        <span class="cov3" title="8">if orgTx.RowsAffected == 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("organization %s not found for group %s", g.OrgName, g.Name)
                        }</span>

                        // Find existing group by unique key (name, org_id)
                        <span class="cov3" title="8">var group models.Group
                        grpTx := tx.Where("name = ? AND org_id = ?", g.Name, org.ID).Limit(1).Find(&amp;group)
                        if grpTx.Error != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("query group %s: %w", g.Name, grpTx.Error)
                        }</span>
                        <span class="cov3" title="8">if grpTx.RowsAffected == 0 </span><span class="cov3" title="8">{
                                // Create new group
                                metadataJSON, err := json.Marshal(g.Metadata)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("marshal group %s metadata: %w", g.Name, err)
                                }</span>
                                <span class="cov3" title="8">newGroup := models.Group{
                                        BaseModel: models.BaseModel{
                                                Name:        g.Name,
                                                Title:       g.Title,
                                                Description: g.Description,
                                                CreatedBy:   "cis.devops",
                                                Metadata:    metadataJSON,
                                        },
                                        OrgID:      org.ID,
                                        Owner:      g.Owner,
                                        Email:      g.Email,
                                        PictureURL: g.Picture,
                                }
                                if err := tx.Create(&amp;newGroup).Error; err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to create: %w", err)
                                }</span>
                                <span class="cov3" title="8">created++
                                continue</span>
                        }

                        // Existing: check if data is identical (including metadata; treat nil YAML metadata as no change)
                        <span class="cov0" title="0">yamlMD, err := json.Marshal(g.Metadata)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("marshal group %s metadata: %w", g.Name, err)
                        }</span>
                        // Merge DB metadata with YAML overrides (YAML wins on conflicts) for comparison
                        <span class="cov0" title="0">var mergedMD []byte
                        if g.Metadata != nil </span><span class="cov0" title="0">{
                                if md, err := mergeJSON(group.Metadata, yamlMD); err == nil </span><span class="cov0" title="0">{
                                        mergedMD = md
                                }</span> else<span class="cov0" title="0"> {
                                        // Fallback to YAML if merge fails
                                        mergedMD = yamlMD
                                }</span>
                        }
                        <span class="cov0" title="0">identical := group.Title == g.Title &amp;&amp;
                                group.Description == g.Description &amp;&amp;
                                group.Owner == g.Owner &amp;&amp;
                                group.Email == g.Email &amp;&amp;
                                group.PictureURL == g.Picture &amp;&amp;
                                (g.Metadata == nil || jsonEqual(group.Metadata, mergedMD))

                        if identical </span><span class="cov0" title="0">{
                                unchanged++
                                continue</span> // no-op
                        }

                        // Update mutable fields (do not touch id, created_at, created_by)
                        <span class="cov0" title="0">updates := map[string]interface{}{
                                "title":       g.Title,
                                "description": g.Description,
                                "owner":       g.Owner,
                                "email":       g.Email,
                                "picture_url": g.Picture,
                                "updated_by":  "cis.devops",
                                "updated_at":  gorm.Expr("CURRENT_TIMESTAMP"),
                        }
                        // Update metadata only if provided in YAML (merge DB + YAML where YAML overrides)
                        if g.Metadata != nil </span><span class="cov0" title="0">{
                                if mergedMD != nil </span><span class="cov0" title="0">{
                                        updates["metadata"] = mergedMD
                                }</span> else<span class="cov0" title="0"> {
                                        updates["metadata"] = yamlMD
                                }</span>
                        }

                        <span class="cov0" title="0">if err := tx.Model(&amp;group).Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("update group %s: %w", g.Name, err)
                        }</span>
                        <span class="cov0" title="0">updated++</span>
                }

                <span class="cov1" title="1">log.Printf("Groups handling completed. %d created, %d updated, %d unchanged, %d total in YAML", created, updated, unchanged, len(items))
                return nil</span>
        })
}

func handleTeamsFromYAML(db *gorm.DB, dataDir string) error <span class="cov1" title="1">{
        items, err := loadFromYAMLFile[TeamData](dataDir, "teams.yaml", decodeTeams)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("load Teams from YAML: %w", err)
        }</span>

        <span class="cov1" title="1">return db.Transaction(func(tx *gorm.DB) error </span><span class="cov1" title="1">{
                created := 0
                updated := 0
                unchanged := 0

                for _, t := range items </span><span class="cov4" title="17">{
                        // Resolve group by name without ErrRecordNotFound logs
                        var group models.Group
                        grpTx := tx.Where("name = ?", t.GroupName).Limit(1).Find(&amp;group)
                        if grpTx.Error != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("query group %s for team %s: %w", t.GroupName, t.Name, grpTx.Error)
                        }</span>
                        <span class="cov4" title="17">if grpTx.RowsAffected == 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("group %s not found for team %s", t.GroupName, t.Name)
                        }</span>
                        // Try find existing team by unique key (name, group_id) without ErrRecordNotFound logs
                        <span class="cov4" title="17">var team models.Team
                        teamTx := tx.Where("name = ? AND group_id = ?", t.Name, group.ID).Limit(1).Find(&amp;team)
                        if teamTx.Error != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("query team %s: %w", t.Name, teamTx.Error)
                        }</span>
                        <span class="cov4" title="17">if teamTx.RowsAffected == 0 </span><span class="cov4" title="17">{
                                // Create new team
                                metadataJSON, err := json.Marshal(t.Metadata)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("marshal team %s metadata: %w", t.Name, err)
                                }</span>
                                <span class="cov4" title="17">newTeam := models.Team{
                                        BaseModel: models.BaseModel{
                                                Name:        t.Name,
                                                Title:       t.Title,
                                                Description: t.Description,
                                                CreatedBy:   "cis.devops",
                                                Metadata:    metadataJSON,
                                        },
                                        GroupID:    group.ID,
                                        Owner:      t.Owner,
                                        Email:      t.Email,
                                        PictureURL: t.Picture,
                                }
                                if err := tx.Create(&amp;newTeam).Error; err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to create team: %w", err)
                                }</span>
                                <span class="cov4" title="17">created++
                                continue</span>
                        }

                        // Existing: check if data is identical (including metadata; treat nil YAML metadata as no change)
                        <span class="cov0" title="0">yamlMD, err := json.Marshal(t.Metadata)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("marshal team %s metadata: %w", t.Name, err)
                        }</span>
                        // Merge DB metadata with YAML overrides (YAML wins on conflicts) for comparison
                        <span class="cov0" title="0">var mergedMD []byte
                        if t.Metadata != nil </span><span class="cov0" title="0">{
                                if md, err := mergeJSON(team.Metadata, yamlMD); err == nil </span><span class="cov0" title="0">{
                                        mergedMD = md
                                }</span> else<span class="cov0" title="0"> {
                                        // Fallback to YAML if merge fails
                                        mergedMD = yamlMD
                                }</span>
                        }

                        <span class="cov0" title="0">identical := team.Title == t.Title &amp;&amp;
                                team.Description == t.Description &amp;&amp;
                                team.Owner == t.Owner &amp;&amp;
                                team.Email == t.Email &amp;&amp;
                                team.PictureURL == t.Picture &amp;&amp;
                                (t.Metadata == nil || jsonEqual(team.Metadata, mergedMD))

                        if identical </span><span class="cov0" title="0">{
                                unchanged++
                                continue</span> // no-op
                        }

                        // Update mutable fields (do not touch id, created_at, created_by)
                        <span class="cov0" title="0">updates := map[string]interface{}{
                                "title":       t.Title,
                                "description": t.Description,
                                "owner":       t.Owner,
                                "email":       t.Email,
                                "picture_url": t.Picture,
                                "updated_by":  "cis.devops",
                                "updated_at":  gorm.Expr("CURRENT_TIMESTAMP"),
                        }
                        // Update metadata if provided in YAML (merge DB + YAML where YAML overrides)
                        if t.Metadata != nil </span><span class="cov0" title="0">{
                                if mergedMD != nil </span><span class="cov0" title="0">{
                                        updates["metadata"] = mergedMD
                                }</span> else<span class="cov0" title="0"> {
                                        updates["metadata"] = yamlMD
                                }</span>
                        }

                        <span class="cov0" title="0">if err := tx.Model(&amp;team).Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("update team %s: %w", t.Name, err)
                        }</span>
                        <span class="cov0" title="0">updated++</span>
                }

                <span class="cov1" title="1">log.Printf("Teams handling completed. %d created, %d updated, %d unchanged, %d total in YAML", created, updated, unchanged, len(items))
                return nil</span>
        })
}

func handleUsersFromYAML(db *gorm.DB, dataDir string) error <span class="cov1" title="1">{
        items, err := loadFromYAMLFile[UserData](dataDir, "users.yaml", decodeUsers)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("load Users from YAML: %w", err)
        }</span>

        <span class="cov1" title="1">return db.Transaction(func(tx *gorm.DB) error </span><span class="cov1" title="1">{
                created := 0
                updated := 0
                unchanged := 0

                for _, u := range items </span><span class="cov10" title="875">{
                        var dbUser models.User
                        // Resolve user by name without ErrRecordNotFound logs:
                        if err := tx.Where("user_id = ?", u.UserID).Limit(1).Find(&amp;dbUser).Error; err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("query user %s: %w", u.UserID, err)
                        }</span>
                        // if dbUser found, compare metadata.ai_instances
                        <span class="cov10" title="875">if dbUser.ID != uuid.Nil </span><span class="cov0" title="0">{
                                // Safely unmarshal existing metadata; empty/invalid, start with empty map
                                var dbUserMetadata map[string]interface{}
                                if len(dbUser.Metadata) &gt; 0 </span><span class="cov0" title="0">{
                                        if err := json.Unmarshal(dbUser.Metadata, &amp;dbUserMetadata); err != nil || dbUserMetadata == nil </span><span class="cov0" title="0">{
                                                dbUserMetadata = map[string]interface{}{}
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        dbUserMetadata = map[string]interface{}{}
                                }</span>

                                // YAML is the source of truth for ai_instances:
                                // - If YAML provides ai_instances: set DB to that value (update only if different)
                                // - If YAML omits ai_instances (including nil metadata): remove ai_instances from DB metadata if present
                                <span class="cov0" title="0">var yamlAI interface{}
                                yamlHasAI := false
                                if u.Metadata != nil </span><span class="cov0" title="0">{
                                        if v, ok := u.Metadata["ai_instances"]; ok </span><span class="cov0" title="0">{
                                                yamlHasAI = true
                                                yamlAI = v
                                        }</span>
                                }

                                <span class="cov0" title="0">existingAI, exists := dbUserMetadata["ai_instances"]

                                if yamlHasAI </span><span class="cov0" title="0">{
                                        // Compare existing vs YAML value semantically
                                        existingJSONBytes, err := json.Marshal(existingAI)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("marshal existing ai_instances for user %s: %w", u.UserID, err)
                                        }</span>
                                        <span class="cov0" title="0">yamlJSONBytes, err := json.Marshal(yamlAI)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("marshal YAML ai_instances for user %s: %w", u.UserID, err)
                                        }</span>

                                        <span class="cov0" title="0">if !jsonEqual(json.RawMessage(existingJSONBytes), json.RawMessage(yamlJSONBytes)) </span><span class="cov0" title="0">{
                                                // Update metadata.ai_instances to YAML-provided value
                                                dbUserMetadata["ai_instances"] = yamlAI
                                                updatedMetadataJSON, err := json.Marshal(dbUserMetadata)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("marshal updated metadata for user %s: %w", u.UserID, err)
                                                }</span>
                                                <span class="cov0" title="0">if err := tx.Model(&amp;dbUser).Updates(map[string]interface{}{
                                                        "metadata":   updatedMetadataJSON,
                                                        "updated_by": "cis.devops",
                                                        "updated_at": gorm.Expr("CURRENT_TIMESTAMP"),
                                                }).Error; err != nil </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("update user %s metadata.ai_instances: %w", u.UserID, err)
                                                }</span>
                                                <span class="cov0" title="0">updated++
                                                continue</span>
                                        }

                                        <span class="cov0" title="0">unchanged++
                                        continue</span>
                                } else<span class="cov0" title="0"> {
                                        // YAML omits ai_instances: ensure DB does not have it
                                        if exists </span><span class="cov0" title="0">{
                                                delete(dbUserMetadata, "ai_instances")
                                                updatedMetadataJSON, err := json.Marshal(dbUserMetadata)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("marshal updated metadata for user %s: %w", u.UserID, err)
                                                }</span>
                                                <span class="cov0" title="0">if err := tx.Model(&amp;dbUser).Updates(map[string]interface{}{
                                                        "metadata":   updatedMetadataJSON,
                                                        "updated_by": "cis.devops",
                                                        "updated_at": gorm.Expr("CURRENT_TIMESTAMP"),
                                                }).Error; err != nil </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("remove user %s metadata.ai_instances: %w", u.UserID, err)
                                                }</span>
                                                <span class="cov0" title="0">updated++
                                                continue</span>
                                        }

                                        <span class="cov0" title="0">unchanged++
                                        continue</span>
                                }
                        }
                        // Create new user
                        <span class="cov10" title="875">metadataJSON, err := json.Marshal(u.Metadata)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("marshal user %s metadata: %w", u.UserID, err)
                        }</span>
                        <span class="cov10" title="875">fullTitle := u.FirstName + " " + u.LastName
                        newUser := models.User{
                                BaseModel: models.BaseModel{
                                        Name:        u.UserID,
                                        Title:       fullTitle,
                                        Description: "",
                                        CreatedBy:   "cis.devops",
                                        Metadata:    metadataJSON,
                                },
                                UserID:     u.UserID,
                                FirstName:  u.FirstName,
                                LastName:   u.LastName,
                                Email:      u.Email,
                                Mobile:     u.PhoneNumber,
                                TeamDomain: models.TeamDomain(u.TeamDomain),
                                TeamRole:   models.TeamRole(u.TeamRole),
                                Metadata:   metadataJSON,
                        }
                        // Optionally resolve team by name for assignment (do not enforce group/org existence)
                        var team models.Team
                        if u.TeamName != "" </span><span class="cov7" title="128">{
                                if err := tx.Where("name = ?", u.TeamName).Limit(1).Find(&amp;team).Error; err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("query team %s for user %s: %w", u.TeamName, u.UserID, err)
                                }</span>
                        }
                        <span class="cov10" title="875">if team.ID != uuid.Nil </span><span class="cov7" title="128">{
                                newUser.TeamID = &amp;team.ID
                        }</span>

                        <span class="cov10" title="875">if err := tx.Create(&amp;newUser).Error; err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create user %s: %w", u.UserID, err)
                        }</span>
                        <span class="cov10" title="875">created++</span>
                }
                <span class="cov1" title="1">log.Printf("Users handling completed. %d created, %d updated, %d unchanged, %d total in YAML", created, updated, unchanged, len(items))
                return nil</span>

        })
}

func handleProjectsFromYAML(db *gorm.DB, dataDir string) error <span class="cov1" title="1">{
        items, err := loadFromYAMLFile[ProjectData](dataDir, "projects.yaml", decodeProjects)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("load Projects from YAML: %w", err)
        }</span>

        <span class="cov1" title="1">return db.Transaction(func(tx *gorm.DB) error </span><span class="cov1" title="1">{
                created := 0
                updated := 0
                unchanged := 0

                for _, p := range items </span><span class="cov3" title="6">{
                        // Lookup by unique key (name)
                        var proj models.Project
                        projTx := tx.Where("name = ?", p.Name).Limit(1).Find(&amp;proj)
                        if projTx.Error != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("query project %s: %w", p.Name, projTx.Error)
                        }</span>

                        <span class="cov3" title="6">if projTx.RowsAffected == 0 </span><span class="cov3" title="6">{
                                // Create new project
                                metadataJSON, err := json.Marshal(p.Metadata)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("marshal project %s metadata: %w", p.Name, err)
                                }</span>
                                <span class="cov3" title="6">newProj := models.Project{
                                        BaseModel: models.BaseModel{
                                                Name:        p.Name,
                                                Title:       p.Title,
                                                Description: p.Description,
                                                CreatedBy:   "cis.devops",
                                                Metadata:    metadataJSON,
                                        },
                                }
                                if err := tx.Create(&amp;newProj).Error; err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to create project: %w", err)
                                }</span>
                                <span class="cov3" title="6">created++
                                continue</span>
                        }

                        // Existing: check if data is identical (including metadata; treat nil YAML metadata as no change)
                        <span class="cov0" title="0">yamlMD, err := json.Marshal(p.Metadata)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("marshal project %s metadata: %w", p.Name, err)
                        }</span>
                        // Merge DB metadata with YAML overrides (YAML wins on conflicts) for comparison
                        <span class="cov0" title="0">var mergedMD []byte
                        if p.Metadata != nil </span><span class="cov0" title="0">{
                                if md, err := mergeJSON(proj.Metadata, yamlMD); err == nil </span><span class="cov0" title="0">{
                                        mergedMD = md
                                }</span> else<span class="cov0" title="0"> {
                                        // Fallback to YAML if merge fails
                                        mergedMD = yamlMD
                                }</span>
                        }
                        <span class="cov0" title="0">identical := proj.Title == p.Title &amp;&amp;
                                proj.Description == p.Description &amp;&amp;
                                (p.Metadata == nil || jsonEqual(proj.Metadata, mergedMD))

                        if identical </span><span class="cov0" title="0">{
                                unchanged++
                                continue</span> // no-op
                        }

                        // Update mutable fields (do not touch id, created_at, created_by)
                        <span class="cov0" title="0">updates := map[string]interface{}{
                                "title":       p.Title,
                                "description": p.Description,
                                "updated_by":  "cis.devops",
                                "updated_at":  gorm.Expr("CURRENT_TIMESTAMP"),
                        }
                        // Update metadata only if provided in YAML (merge DB + YAML where YAML overrides)
                        if p.Metadata != nil </span><span class="cov0" title="0">{
                                if mergedMD != nil </span><span class="cov0" title="0">{
                                        updates["metadata"] = mergedMD
                                }</span> else<span class="cov0" title="0"> {
                                        updates["metadata"] = yamlMD
                                }</span>
                        }

                        <span class="cov0" title="0">if err := tx.Model(&amp;proj).Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("update project %s: %w", p.Name, err)
                        }</span>
                        <span class="cov0" title="0">updated++</span>
                }

                <span class="cov1" title="1">log.Printf("Projects handling completed. %d created, %d updated, %d unchanged, %d total in YAML", created, updated, unchanged, len(items))
                return nil</span>
        })
}

func handleLandscapesFromYAML(db *gorm.DB, dataDir string) error <span class="cov1" title="1">{
        items, err := loadFromYAMLFile[LandscapeData](dataDir, "landscapes.yaml", decodeLandscapes)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("load Landscapes from YAML: %w", err)
        }</span>

        <span class="cov1" title="1">return db.Transaction(func(tx *gorm.DB) error </span><span class="cov1" title="1">{
                created := 0
                updated := 0
                unchanged := 0

                for _, l := range items </span><span class="cov7" title="119">{
                        // Resolve project by name (without ErrRecordNotFound logs)
                        var proj models.Project
                        projTx := tx.Where("name = ?", l.Project).Limit(1).Find(&amp;proj)
                        if projTx.Error != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("query project %s for landscape %s: %w", l.Project, l.Name, projTx.Error)
                        }</span>
                        <span class="cov7" title="119">if projTx.RowsAffected == 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("project %s not found for landscape %s", l.Project, l.Name)
                        }</span>

                        <span class="cov7" title="119">env := strings.ToLower(l.Environment)

                        // Find existing landscape by unique key (name, project_id)
                        var landscape models.Landscape
                        lsTx := tx.Where("name = ? AND project_id = ?", l.Name, proj.ID).Limit(1).Find(&amp;landscape)
                        if lsTx.Error != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("query landscape %s: %w", l.Name, lsTx.Error)
                        }</span>
                        <span class="cov7" title="119">if lsTx.RowsAffected == 0 </span><span class="cov7" title="119">{
                                // Create new landscape
                                metadataJSON, err := json.Marshal(l.Metadata)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("marshal landscape %s metadata: %w", l.Name, err)
                                }</span>
                                <span class="cov7" title="119">newLandscape := models.Landscape{
                                        BaseModel: models.BaseModel{
                                                Name:        l.Name,
                                                Title:       l.Title,
                                                Description: l.Description,
                                                CreatedBy:   "cis.devops",
                                                Metadata:    metadataJSON,
                                        },
                                        ProjectID:   proj.ID,
                                        Domain:      l.Domain,
                                        Environment: env,
                                }
                                if err := tx.Create(&amp;newLandscape).Error; err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to create landscape: %w", err)
                                }</span>
                                <span class="cov7" title="119">created++
                                continue</span>
                        }

                        // Existing: check if data is identical (including metadata; treat nil YAML metadata as no change)
                        <span class="cov0" title="0">yamlMD, err := json.Marshal(l.Metadata)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("marshal landscape %s metadata: %w", l.Name, err)
                        }</span>
                        // Merge DB metadata with YAML overrides (YAML wins on conflicts) for comparison
                        <span class="cov0" title="0">var mergedMD []byte
                        if l.Metadata != nil </span><span class="cov0" title="0">{
                                if md, err := mergeJSON(landscape.Metadata, yamlMD); err == nil </span><span class="cov0" title="0">{
                                        mergedMD = md
                                }</span> else<span class="cov0" title="0"> {
                                        // Fallback to YAML if merge fails
                                        mergedMD = yamlMD
                                }</span>
                        }
                        <span class="cov0" title="0">identical := landscape.Title == l.Title &amp;&amp;
                                landscape.Description == l.Description &amp;&amp;
                                landscape.Domain == l.Domain &amp;&amp;
                                landscape.Environment == env &amp;&amp;
                                (l.Metadata == nil || jsonEqual(landscape.Metadata, mergedMD))

                        if identical </span><span class="cov0" title="0">{
                                unchanged++
                                continue</span> // no-op
                        }

                        // Update mutable fields (do not touch id, created_at, created_by, project_id)
                        <span class="cov0" title="0">updates := map[string]interface{}{
                                "title":       l.Title,
                                "description": l.Description,
                                "domain":      l.Domain,
                                "environment": env,
                                "updated_by":  "cis.devops",
                                "updated_at":  gorm.Expr("CURRENT_TIMESTAMP"),
                        }
                        // Update metadata only if provided in YAML (merge DB + YAML where YAML overrides)
                        if l.Metadata != nil </span><span class="cov0" title="0">{
                                if mergedMD != nil </span><span class="cov0" title="0">{
                                        updates["metadata"] = mergedMD
                                }</span> else<span class="cov0" title="0"> {
                                        updates["metadata"] = yamlMD
                                }</span>
                        }

                        <span class="cov0" title="0">if err := tx.Model(&amp;landscape).Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("update landscape %s: %w", l.Name, err)
                        }</span>
                        <span class="cov0" title="0">updated++</span>
                }

                <span class="cov1" title="1">log.Printf("Landscapes handling completed. %d created, %d updated, %d unchanged, %d total in YAML", created, updated, unchanged, len(items))
                return nil</span>
        })
}

func handleComponentsFromYAML(db *gorm.DB, dataDir string) error <span class="cov1" title="1">{
        items, err := loadFromYAMLFile[ComponentData](dataDir, "components.yaml", decodeComponents)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("load Components from YAML: %w", err)
        }</span>

        <span class="cov1" title="1">return db.Transaction(func(tx *gorm.DB) error </span><span class="cov1" title="1">{
                created := 0
                updated := 0
                unchanged := 0

                for _, c := range items </span><span class="cov7" title="113">{
                        // Resolve project by name (without ErrRecordNotFound logs)
                        var proj models.Project
                        projTx := tx.Where("name = ?", c.Project).Limit(1).Find(&amp;proj)
                        if projTx.Error != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("query project %s for component %s: %w", c.Project, c.Name, projTx.Error)
                        }</span>
                        <span class="cov7" title="113">if projTx.RowsAffected == 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("project %s not found for component %s", c.Project, c.Name)
                        }</span>

                        // Resolve owner team by name
                        <span class="cov7" title="113">var team models.Team
                        teamTx := tx.Where("name = ?", c.Owner).Limit(1).Find(&amp;team)
                        if teamTx.Error != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("query owner team %s for component %s: %w", c.Owner, c.Name, teamTx.Error)
                        }</span>
                        <span class="cov7" title="113">if teamTx.RowsAffected == 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("owner team %s not found for component %s", c.Owner, c.Name)
                        }</span>

                        // Find existing component by unique key (name, project_id)
                        <span class="cov7" title="113">var component models.Component
                        compTx := tx.Where("name = ? AND project_id = ?", c.Name, proj.ID).Limit(1).Find(&amp;component)
                        if compTx.Error != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("query component %s: %w", c.Name, compTx.Error)
                        }</span>
                        <span class="cov7" title="113">if compTx.RowsAffected == 0 </span><span class="cov7" title="113">{
                                // Create new component
                                metadataJSON, err := json.Marshal(c.Metadata)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("marshal component %s metadata: %w", c.Name, err)
                                }</span>
                                <span class="cov7" title="113">newComponent := models.Component{
                                        BaseModel: models.BaseModel{
                                                Name:        c.Name,
                                                Title:       c.Title,
                                                Description: c.Description,
                                                CreatedBy:   "cis.devops",
                                                Metadata:    metadataJSON,
                                        },
                                        ProjectID: proj.ID,
                                        OwnerID:   team.ID,
                                }
                                if err := tx.Create(&amp;newComponent).Error; err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to create component: %w", err)
                                }</span>
                                <span class="cov7" title="113">created++
                                continue</span>
                        }

                        // Existing check if data is identical (including metadata; treat nil YAML metadata as no change)
                        <span class="cov0" title="0">yamlMD, err := json.Marshal(c.Metadata)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("marshal component %s metadata: %w", c.Name, err)
                        }</span>
                        // Merge DB metadata with YAML overrides (YAML wins on conflicts) for comparison
                        <span class="cov0" title="0">var mergedMD []byte
                        if c.Metadata != nil </span><span class="cov0" title="0">{
                                if md, err := mergeJSON(component.Metadata, yamlMD); err == nil </span><span class="cov0" title="0">{
                                        mergedMD = md
                                }</span> else<span class="cov0" title="0"> {
                                        // Fallback to YAML if merge fails
                                        mergedMD = yamlMD
                                }</span>
                        }
                        <span class="cov0" title="0">identical := component.Title == c.Title &amp;&amp;
                                component.Description == c.Description &amp;&amp;
                                component.OwnerID == team.ID &amp;&amp;
                                (c.Metadata == nil || jsonEqual(component.Metadata, mergedMD))

                        if identical </span><span class="cov0" title="0">{
                                unchanged++
                                continue</span> // no-op
                        }

                        // Update mutable fields (do not touch id, created_at, created_by, project_id)
                        <span class="cov0" title="0">updates := map[string]interface{}{
                                "title":       c.Title,
                                "description": c.Description,
                                "owner_id":    team.ID,
                                "updated_by":  "cis.devops",
                                "updated_at":  gorm.Expr("CURRENT_TIMESTAMP"),
                        }
                        // Update metadata only if provided in YAML (merge DB + YAML where YAML overrides)
                        if c.Metadata != nil </span><span class="cov0" title="0">{
                                if mergedMD != nil </span><span class="cov0" title="0">{
                                        updates["metadata"] = mergedMD
                                }</span> else<span class="cov0" title="0"> {
                                        updates["metadata"] = yamlMD
                                }</span>
                        }

                        <span class="cov0" title="0">if err := tx.Model(&amp;component).Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("update component %s: %w", c.Name, err)
                        }</span>
                        <span class="cov0" title="0">updated++</span>
                }

                <span class="cov1" title="1">log.Printf("Components handling completed. %d created, %d updated, %d unchanged, %d total in YAML", created, updated, unchanged, len(items))
                return nil</span>
        })
}

func handleCategoriesFromYAML(db *gorm.DB, dataDir string) error <span class="cov1" title="1">{
        items, err := loadFromYAMLFile[CategoryData](dataDir, "categories.yaml", decodeCategories)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("load Categories from YAML: %w", err)
        }</span>

        <span class="cov1" title="1">return db.Transaction(func(tx *gorm.DB) error </span><span class="cov1" title="1">{
                created := 0
                updated := 0
                unchanged := 0

                for _, c := range items </span><span class="cov4" title="10">{
                        // Lookup by unique key (name)
                        var cat models.Category
                        catTx := tx.Where("name = ?", c.Name).Limit(1).Find(&amp;cat)
                        if catTx.Error != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("query category %s: %w", c.Name, catTx.Error)
                        }</span>

                        <span class="cov4" title="10">if catTx.RowsAffected == 0 </span><span class="cov4" title="10">{
                                // Create new category
                                metadataJSON, err := json.Marshal(c.Metadata)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("marshal category %s metadata: %w", c.Name, err)
                                }</span>
                                <span class="cov4" title="10">newCat := models.Category{
                                        BaseModel: models.BaseModel{
                                                Name:        c.Name,
                                                Title:       c.Title,
                                                Description: c.Description,
                                                CreatedBy:   "cis.devops",
                                                Metadata:    metadataJSON,
                                        },
                                        Icon:  c.Icon,
                                        Color: c.Color,
                                }
                                if err := tx.Create(&amp;newCat).Error; err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to create category: %w", err)
                                }</span>
                                <span class="cov4" title="10">created++
                                continue</span>
                        }

                        // Existing: check if data is identical (including metadata; treat nil YAML metadata as no change)
                        <span class="cov0" title="0">yamlMD, err := json.Marshal(c.Metadata)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("marshal category %s metadata: %w", c.Name, err)
                        }</span>
                        // Merge DB metadata with YAML overrides (YAML wins on conflicts) for comparison
                        <span class="cov0" title="0">var mergedMD []byte
                        if c.Metadata != nil </span><span class="cov0" title="0">{
                                if md, err := mergeJSON(cat.Metadata, yamlMD); err == nil </span><span class="cov0" title="0">{
                                        mergedMD = md
                                }</span> else<span class="cov0" title="0"> {
                                        // Fallback to YAML if merge fails
                                        mergedMD = yamlMD
                                }</span>
                        }
                        <span class="cov0" title="0">identical := cat.Title == c.Title &amp;&amp;
                                cat.Description == c.Description &amp;&amp;
                                cat.Icon == c.Icon &amp;&amp;
                                cat.Color == c.Color &amp;&amp;
                                (c.Metadata == nil || jsonEqual(cat.Metadata, mergedMD))

                        if identical </span><span class="cov0" title="0">{
                                unchanged++
                                continue</span> // no-op
                        }

                        // Update mutable fields (do not touch id, created_at, created_by)
                        <span class="cov0" title="0">updates := map[string]interface{}{
                                "title":       c.Title,
                                "description": c.Description,
                                "icon":        c.Icon,
                                "color":       c.Color,
                                "updated_by":  "cis.devops",
                                "updated_at":  gorm.Expr("CURRENT_TIMESTAMP"),
                        }
                        // Update metadata only if provided in YAML (merge DB + YAML where YAML overrides)
                        if c.Metadata != nil </span><span class="cov0" title="0">{
                                if mergedMD != nil </span><span class="cov0" title="0">{
                                        updates["metadata"] = mergedMD
                                }</span> else<span class="cov0" title="0"> {
                                        updates["metadata"] = yamlMD
                                }</span>
                        }

                        <span class="cov0" title="0">if err := tx.Model(&amp;cat).Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("update category %s: %w", c.Name, err)
                        }</span>
                        <span class="cov0" title="0">updated++</span>
                }

                <span class="cov1" title="1">log.Printf("Categories handling completed. %d created, %d updated, %d unchanged, %d total in YAML", created, updated, unchanged, len(items))
                return nil</span>
        })
}

func handleLinksFromYAML(db *gorm.DB, dataDir string) error <span class="cov1" title="1">{
        items, err := loadFromYAMLFile[LinkData](dataDir, "links.yaml", decodeLinks)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("load Links from YAML: %w", err)
        }</span>

        <span class="cov1" title="1">return db.Transaction(func(tx *gorm.DB) error </span><span class="cov1" title="1">{
                created := 0
                updated := 0
                unchanged := 0

                // Resolve owner user by fixed user_id 'cis.devops'
                var owner models.User
                ownerTx := tx.Where("user_id = ?", "cis.devops").Limit(1).Find(&amp;owner)
                if ownerTx.Error != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("query owner user 'cis.devops': %w", ownerTx.Error)
                }</span>
                <span class="cov1" title="1">if ownerTx.RowsAffected == 0 </span><span class="cov0" title="0">{
                        log.Printf("  Links handling skipped: owner user 'cis.devops' not found")
                        return nil
                }</span>

                <span class="cov1" title="1">for _, l := range items </span><span class="cov6" title="72">{
                        // Resolve category by name
                        var cat models.Category
                        catTx := tx.Where("name = ?", l.Category).Limit(1).Find(&amp;cat)
                        if catTx.Error != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("query category %s for link %s: %w", l.Category, l.Title, catTx.Error)
                        }</span>
                        <span class="cov6" title="72">if catTx.RowsAffected == 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("category %s not found for link %s", l.Category, l.Title)
                        }</span>

                        // Derive stable name from title
                        <span class="cov6" title="72">name := slugifyTitle(l.Title)

                        // Normalize tags to CSV string
                        tagsCSV := normalizeTagsCSV(l.TagsRaw)

                        // Find existing link by (name, category_id, created_by='cis.devops') only
                        var link models.Link
                        lookup := tx.Where("name = ? AND category_id = ? AND created_by = ?", name, cat.ID, "cis.devops").Limit(1).Find(&amp;link)
                        if lookup.Error != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("query link %s: %w", l.Title, lookup.Error)
                        }</span>

                        <span class="cov6" title="72">yamlMD, err := json.Marshal(l.Metadata)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("marshal link %s metadata: %w", l.Title, err)
                        }</span>

                        <span class="cov6" title="72">if lookup.RowsAffected == 0 </span><span class="cov6" title="72">{
                                // Create new link
                                newLink := models.Link{
                                        BaseModel: models.BaseModel{
                                                Name:        name,
                                                Title:       l.Title,
                                                Description: l.Description,
                                                CreatedBy:   "cis.devops",
                                                Metadata:    yamlMD,
                                        },
                                        Owner:      owner.ID,
                                        URL:        l.URL,
                                        CategoryID: cat.ID,
                                        Tags:       tagsCSV,
                                }
                                if err := tx.Create(&amp;newLink).Error; err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to create link %s: %w", l.Title, err)
                                }</span>
                                <span class="cov6" title="72">created++
                                continue</span>
                        }

                        // Merge DB metadata with YAML overrides (YAML wins on conflicts) for comparison
                        <span class="cov0" title="0">var mergedMD []byte
                        if l.Metadata != nil </span><span class="cov0" title="0">{
                                if md, err := mergeJSON(link.Metadata, yamlMD); err == nil </span><span class="cov0" title="0">{
                                        mergedMD = md
                                }</span> else<span class="cov0" title="0"> {
                                        // Fallback to YAML if merge fails
                                        mergedMD = yamlMD
                                }</span>
                        }
                        // Compare fields: title, description, metadata, url, category_id, tags
                        <span class="cov0" title="0">identical := link.Title == l.Title &amp;&amp;
                                link.Description == l.Description &amp;&amp;
                                link.URL == l.URL &amp;&amp;
                                link.CategoryID == cat.ID &amp;&amp;
                                link.Tags == tagsCSV &amp;&amp;
                                (l.Metadata == nil || jsonEqual(link.Metadata, mergedMD))

                        if identical </span><span class="cov0" title="0">{
                                unchanged++
                                continue</span> // no-op
                        }

                        <span class="cov0" title="0">updatedDescription := l.Description
                        if updatedDescription == "" </span><span class="cov0" title="0">{
                                updatedDescription = link.Description
                        }</span>

                        <span class="cov0" title="0">updates := map[string]interface{}{
                                "title":       l.Title,
                                "description": updatedDescription,
                                "url":         l.URL,
                                "category_id": cat.ID,
                                "tags":        tagsCSV,
                                "updated_by":  "cis.devops",
                                "updated_at":  gorm.Expr("CURRENT_TIMESTAMP"),
                        }
                        if l.Metadata != nil </span><span class="cov0" title="0">{
                                if mergedMD != nil </span><span class="cov0" title="0">{
                                        updates["metadata"] = mergedMD
                                }</span> else<span class="cov0" title="0"> {
                                        updates["metadata"] = yamlMD
                                }</span>
                        }

                        <span class="cov0" title="0">if err := tx.Model(&amp;link).Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("update link %s: %w", l.Title, err)
                        }</span>
                        <span class="cov0" title="0">updated++</span>
                }

                <span class="cov1" title="1">log.Printf("Links handling completed. %d created, %d updated, %d unchanged, %d total in YAML", created, updated, unchanged, len(items))
                return nil</span>
        })
}

func handlePluginsFromYAML(db *gorm.DB, dataDir string) error <span class="cov1" title="1">{
        items, err := loadFromYAMLFile[PluginData](dataDir, "plugins.yaml", decodePlugins)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("load Plugins from YAML: %w", err)
        }</span>

        <span class="cov1" title="1">return db.Transaction(func(tx *gorm.DB) error </span><span class="cov1" title="1">{
                created := 0
                updated := 0
                unchanged := 0

                for _, p := range items </span><span class="cov1" title="2">{
                        // Lookup by unique key (name)
                        var plugin models.Plugin
                        pluginTx := tx.Where("name = ?", p.Name).Limit(1).Find(&amp;plugin)
                        if pluginTx.Error != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("query plugin %s: %w", p.Name, pluginTx.Error)
                        }</span>

                        <span class="cov1" title="2">if pluginTx.RowsAffected == 0 </span><span class="cov1" title="2">{
                                // Create new plugin
                                metadataJSON, err := json.Marshal(p.Metadata)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("marshal plugin %s metadata: %w", p.Name, err)
                                }</span>
                                <span class="cov1" title="2">newPlugin := models.Plugin{
                                        BaseModel: models.BaseModel{
                                                Name:        p.Name,
                                                Title:       p.Title,
                                                Description: p.Description,
                                                CreatedBy:   "cis.devops",
                                                Metadata:    metadataJSON,
                                        },
                                        Icon:               p.Icon,
                                        ReactComponentPath: p.ReactComponentPath,
                                        BackendServerURL:   p.BackendServerURL,
                                        Owner:              p.Owner,
                                }
                                if err := tx.Create(&amp;newPlugin).Error; err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to create plugin: %w", err)
                                }</span>
                                <span class="cov1" title="2">created++
                                continue</span>
                        }

                        // Existing: check if data is identical (including metadata; treat nil YAML metadata as no change)
                        <span class="cov0" title="0">yamlMD, err := json.Marshal(p.Metadata)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("marshal plugin %s metadata: %w", p.Name, err)
                        }</span>
                        // Merge DB metadata with YAML overrides (YAML wins on conflicts) for comparison
                        <span class="cov0" title="0">var mergedMD []byte
                        if p.Metadata != nil </span><span class="cov0" title="0">{
                                if md, err := mergeJSON(plugin.Metadata, yamlMD); err == nil </span><span class="cov0" title="0">{
                                        mergedMD = md
                                }</span> else<span class="cov0" title="0"> {
                                        // Fallback to YAML if merge fails
                                        mergedMD = yamlMD
                                }</span>
                        }
                        <span class="cov0" title="0">identical := plugin.Title == p.Title &amp;&amp;
                                plugin.Description == p.Description &amp;&amp;
                                plugin.Icon == p.Icon &amp;&amp;
                                plugin.ReactComponentPath == p.ReactComponentPath &amp;&amp;
                                plugin.BackendServerURL == p.BackendServerURL &amp;&amp;
                                plugin.Owner == p.Owner &amp;&amp;
                                (p.Metadata == nil || jsonEqual(plugin.Metadata, mergedMD))

                        if identical </span><span class="cov0" title="0">{
                                unchanged++
                                continue</span> // no-op
                        }

                        // Update mutable fields (do not touch id, created_at, created_by)
                        <span class="cov0" title="0">updates := map[string]interface{}{
                                "title":                p.Title,
                                "description":          p.Description,
                                "icon":                 p.Icon,
                                "react_component_path": p.ReactComponentPath,
                                "backend_server_url":   p.BackendServerURL,
                                "owner":                p.Owner,
                                "updated_by":           "cis.devops",
                                "updated_at":           gorm.Expr("CURRENT_TIMESTAMP"),
                        }
                        // Update metadata only if provided in YAML (merge DB + YAML where YAML overrides)
                        if p.Metadata != nil </span><span class="cov0" title="0">{
                                if mergedMD != nil </span><span class="cov0" title="0">{
                                        updates["metadata"] = mergedMD
                                }</span> else<span class="cov0" title="0"> {
                                        updates["metadata"] = yamlMD
                                }</span>
                        }

                        <span class="cov0" title="0">if err := tx.Model(&amp;plugin).Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("update plugin %s: %w", p.Name, err)
                        }</span>
                        <span class="cov0" title="0">updated++</span>
                }

                <span class="cov1" title="1">log.Printf("Plugins handling completed. %d created, %d updated, %d unchanged, %d total in YAML", created, updated, unchanged, len(items))
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package errors

import (
        "errors"
        "fmt"
)

// NotFoundError represents an error when an entity is not found
type NotFoundError struct {
        Entity string
}

func (e *NotFoundError) Error() string <span class="cov10" title="69">{
        return fmt.Sprintf("%s not found", e.Entity)
}</span>

// Is enables errors.Is() comparison for NotFoundError
func (e *NotFoundError) Is(target error) bool <span class="cov8" title="27">{
        t, ok := target.(*NotFoundError)
        if !ok </span><span class="cov5" title="10">{
                return false
        }</span>
        <span class="cov7" title="17">return e.Entity == t.Entity</span>
}

// AlreadyExistsError represents an error when an entity already exists
type AlreadyExistsError struct {
        Entity  string
        Context string // Additional context like "in organization"
}

func (e *AlreadyExistsError) Error() string <span class="cov4" title="5">{
        if e.Context != "" </span><span class="cov3" title="4">{
                return fmt.Sprintf("%s already exists %s", e.Entity, e.Context)
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("%s already exists", e.Entity)</span>
}

// Is enables errors.Is() comparison for AlreadyExistsError
func (e *AlreadyExistsError) Is(target error) bool <span class="cov3" title="3">{
        t, ok := target.(*AlreadyExistsError)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov3" title="3">return e.Entity == t.Entity</span>
}

// ValidationError represents a validation error
type ValidationError struct {
        Field   string
        Message string
}

func (e *ValidationError) Error() string <span class="cov9" title="66">{
        if e.Field != "" </span><span class="cov9" title="45">{
                return fmt.Sprintf("validation error: %s - %s", e.Field, e.Message)
        }</span>
        <span class="cov7" title="21">return fmt.Sprintf("validation error: %s", e.Message)</span>
}

// AuthenticationError represents authentication-related errors
type AuthenticationError struct {
        Message string
}

func (e *AuthenticationError) Error() string <span class="cov6" title="14">{
        return e.Message
}</span>

// AuthorizationError represents authorization-related errors
type AuthorizationError struct {
        Message string
}

func (e *AuthorizationError) Error() string <span class="cov5" title="9">{
        return e.Message
}</span>

// ConfigurationError represents configuration-related errors
type ConfigurationError struct {
        Message string
}

func (e *ConfigurationError) Error() string <span class="cov7" title="26">{
        return e.Message
}</span>

// Entity Not Found Errors
var (
        ErrOrganizationNotFound           = &amp;NotFoundError{Entity: "organization"}
        ErrTeamNotFound                   = &amp;NotFoundError{Entity: "team"}
        ErrComponentNotFound              = &amp;NotFoundError{Entity: "component"}
        ErrUserNotFound                   = &amp;NotFoundError{Entity: "user"}
        ErrUserOrTeamNotFound             = &amp;NotFoundError{Entity: "user or team"}
        ErrProjectNotFound                = &amp;NotFoundError{Entity: "project"}
        ErrLandscapeNotFound              = &amp;NotFoundError{Entity: "landscape"}
        ErrGroupNotFound                  = &amp;NotFoundError{Entity: "group"}
        ErrComponentDeploymentNotFound    = &amp;NotFoundError{Entity: "component deployment"}
        ErrOutageCallNotFound             = &amp;NotFoundError{Entity: "outage call"}
        ErrDeploymentTimelineNotFound     = &amp;NotFoundError{Entity: "deployment timeline entry"}
        ErrDutyScheduleNotFound           = &amp;NotFoundError{Entity: "duty schedule"}
        ErrLeaderNotFound                 = &amp;NotFoundError{Entity: "leader"}
        ErrLinkNotFound                   = &amp;NotFoundError{Entity: "link"}
        ErrCategoryNotFound               = &amp;NotFoundError{Entity: "category"}
        ErrTeamComponentOwnershipNotFound = &amp;NotFoundError{Entity: "team-component ownership"}
        ErrProjectComponentNotFound       = &amp;NotFoundError{Entity: "project-component relationship"}
        ErrProjectLandscapeNotFound       = &amp;NotFoundError{Entity: "project-landscape relationship"}
        ErrOutageCallAssigneeNotFound     = &amp;NotFoundError{Entity: "outage call assignee"}
        ErrDocumentationNotFound          = &amp;NotFoundError{Entity: "documentation"}
        ErrAlertNotFound                  = &amp;NotFoundError{Entity: "alert"}
)

// Already Exists Errors
var (
        ErrOrganizationExists              = &amp;AlreadyExistsError{Entity: "organization", Context: "with this name or domain"}
        ErrTeamExists                      = &amp;AlreadyExistsError{Entity: "team", Context: "with this name in the group"}
        ErrComponentExists                 = &amp;AlreadyExistsError{Entity: "component", Context: "with this name in the organization"}
        ErrUserExists                      = &amp;AlreadyExistsError{Entity: "user", Context: "with this email"}
        ErrProjectExists                   = &amp;AlreadyExistsError{Entity: "project", Context: "with this name in the organization"}
        ErrLandscapeExists                 = &amp;AlreadyExistsError{Entity: "landscape", Context: "with this name"}
        ErrGroupExists                     = &amp;AlreadyExistsError{Entity: "group", Context: "with this name in the organization"}
        ErrLinkExists                      = &amp;AlreadyExistsError{Entity: "link", Context: "with this URL"}
        ErrComponentDeploymentExists       = &amp;AlreadyExistsError{Entity: "component deployment", Context: "for this component and landscape"}
        ErrActiveComponentDeploymentExists = &amp;AlreadyExistsError{Entity: "active component deployment", Context: "for this component and landscape"}
        ErrTeamComponentOwnershipExists    = &amp;AlreadyExistsError{Entity: "team-component ownership", Context: ""}
        ErrProjectComponentExists          = &amp;AlreadyExistsError{Entity: "project-component relationship", Context: ""}
        ErrProjectLandscapeExists          = &amp;AlreadyExistsError{Entity: "project-landscape relationship", Context: ""}
        ErrOutageCallAssigneeExists        = &amp;AlreadyExistsError{Entity: "outage call assignee", Context: ""}
)

// Association Errors
var (
        ErrComponentAlreadyAssociated = errors.New("component is already associated with this project")
        ErrComponentNotAssociated     = errors.New("component is not associated with this project")
        ErrLandscapeAlreadyAssociated = errors.New("landscape is already associated with this project")
        ErrLandscapeNotAssociated     = errors.New("landscape is not associated with this project")
        ErrMemberAlreadyAssigned      = errors.New("member is already assigned to this outage call")
        ErrMemberNotAssigned          = errors.New("member is not assigned to this outage call")
        ErrActiveDeploymentNotFound   = errors.New("active deployment not found")
)

// Business Logic Errors
var (
        ErrInvalidStatus               = errors.New("invalid status")
        ErrCallTimeInFuture            = errors.New("call time cannot be in the future")
        ErrInvalidTimeRange            = errors.New("invalid time range")
        ErrDeploymentDateInPast        = errors.New("scheduled deployment date is in the past")
        ErrTimelineCodeExists          = errors.New("timeline code already exists")
        ErrScheduleConflict            = errors.New("schedule conflict detected")
        ErrInvalidDutyRotation         = errors.New("invalid duty rotation configuration")
        ErrNoMembersInTeam             = errors.New("team has no members")
        ErrInvalidPaginationParams     = errors.New("invalid pagination parameters")
        ErrGitHubAPIRateLimitExceeded  = errors.New("GitHub API rate limit exceeded")
        ErrProviderNotConfigured       = errors.New("provider is not configured")
        ErrInvalidPeriodFormat         = errors.New("invalid period format")
        ErrInternalError               = errors.New("internal server error")
        ErrInvalidJSON                 = errors.New("invalid JSON")
        ErrInvalidJSONResponse         = errors.New("invalid JSON response")
        ErrInvalidComponentID          = errors.New("invalid component-id")
        ErrInvalidLandscapeID          = errors.New("invalid landscape-id")
        ErrInvalidTeamID               = errors.New("invalid team ID")
        ErrInvalidDocumentationID      = errors.New("invalid documentation ID")
        ErrFailedToDeleteDocumentation = errors.New("failed to delete documentation")
)

// Authentication Errors
var (
        ErrInvalidRefreshToken         = &amp;AuthenticationError{Message: "invalid refresh token"}
        ErrRefreshTokenExpired         = &amp;AuthenticationError{Message: "refresh token has expired"}
        ErrAuthenticationRequired      = &amp;AuthenticationError{Message: "authentication required"}
        ErrAuthenticationInvalidClaims = &amp;AuthenticationError{Message: "invalid authentication claims"}

        // AI Core specific authentication errors
        ErrUserEmailNotFound      = &amp;AuthenticationError{Message: "user email not found in context"}
        ErrUserNotAssignedToTeam  = &amp;AuthorizationError{Message: "user is not assigned to any team"}
        ErrUserNotFoundInDB       = &amp;AuthorizationError{Message: "user not found in database"}
        ErrTeamNotFoundInDB       = &amp;AuthorizationError{Message: "team not found in database"}
        ErrMissingUsernameInToken = &amp;AuthenticationError{Message: "missing username in token"}
)

// Configuration Errors
var (
        ErrJiraConfigMissing             = errors.New("jira configuration missing: JIRA_DOMAIN, JIRA_USER or JIRA_PASSWORD")
        ErrJenkinsTokenNotFound          = errors.New("jenkins token not found")
        ErrJenkinsUserNotFound           = errors.New("jenkins username not found")
        ErrJenkinsQueueItemNotFound      = errors.New("jenkins queue item not found")
        ErrJenkinsBuildNotFound          = errors.New("jenkins build not found")
        ErrLandscapeNotConfigured        = &amp;ConfigurationError{Message: "landscape service not configured"}
        ErrAlertsRepositoryNotConfigured = &amp;ConfigurationError{Message: "alerts repository not configured for this project"}
        ErrDatabaseConnection            = &amp;ConfigurationError{Message: "database connection failed"}
        ErrTokenStoreNotInitialized      = &amp;ConfigurationError{Message: "token store not initialized"}
        ErrAuthServiceNotInitialized     = &amp;ConfigurationError{Message: "auth service is not initialized"}

        // AI Core specific configuration errors
        ErrAICoreCredentialsNotSet        = &amp;ConfigurationError{Message: "AI_CORE_CREDENTIALS environment variable not set"}
        ErrAICoreCredentialsInvalid       = &amp;ConfigurationError{Message: "failed to parse AI_CORE_CREDENTIALS"}
        ErrAICoreCredentialsNotFound      = &amp;ConfigurationError{Message: "no credentials found for team"}
        ErrAICoreCredentialsNotConfigured = &amp;ConfigurationError{Message: "No AI Core credentials configured for your team"}
        ErrAICoreAPIRequestFailed         = errors.New("AI Core API request failed")
        ErrAICoreDeploymentNotFound       = &amp;NotFoundError{Entity: "deployment"}
        ErrBothConfigurationInputs        = &amp;ConfigurationError{Message: "ConfigurationId and configurationRequest cannot both be provided"}
        ErrMissingConfigurationInput      = &amp;ConfigurationError{Message: "Either configurationId or configurationRequest must be provided"}

        // Jira PAT (Personal Access Token) Errors
        ErrJiraPATOperation = errors.New("jira PAT operation failed")
)

// Validation Errors
var (

        // AI Core specific validation errors
        ErrMissingScenarioID             = &amp;ValidationError{Field: "scenarioId", Message: "scenarioId query parameter is required"}
        ErrMissingDeploymentID           = &amp;ValidationError{Field: "deployment", Message: "deploymentId parameter is required"}
        ErrMissingTargetStatusOrConfigID = &amp;ValidationError{Message: "At least one of targetStatus or configurationId must be provided"}
        ErrNoFilesProvided               = &amp;ValidationError{Field: "files", Message: "No files provided"}
        ErrFileSizeTooLarge              = &amp;ValidationError{Field: "files", Message: "Files too large or invalid form data. Combined size limit is 5MB"}
        ErrCombinedFileSizeExceeds       = &amp;ValidationError{Field: "files", Message: "Combined file size exceeds 5MB limit"}

        // Component specific validation errors
        ErrMissingHealthParams      = &amp;ValidationError{Message: "component-id and landscape-id parameters are required"}
        ErrMissingTeamOrProjectName = &amp;ValidationError{Message: "team-id or project-name parameter is required"}

        // Alert History specific validation errors
        ErrMissingProject     = &amp;ValidationError{Field: "project", Message: "project is required"}
        ErrMissingFingerprint = &amp;ValidationError{Field: "fingerprint", Message: "fingerprint is required"}
        ErrMissingLabelKey    = &amp;ValidationError{Field: "key", Message: "label key is required"}

        //gitHub specific validation errors
        ErrMissingUserUUIDAndProvider = &amp;ValidationError{Message: "userUUID and provider are required"}
        ErrUserUUIDMissing            = &amp;ValidationError{Field: "userUUID", Message: "userUUID cannot be empty"}
        ErrProviderMissing            = &amp;ValidationError{Field: "provider", Message: "provider cannot be empty"}
        ErrOwnerAndRepositoryMissing  = &amp;ValidationError{Message: "owner and repository are required"}
)

// Helper Functions

// IsNotFound checks if an error is a NotFoundError
func IsNotFound(err error) bool <span class="cov7" title="23">{
        var notFoundErr *NotFoundError
        return errors.Is(err, &amp;NotFoundError{}) || errors.As(err, &amp;notFoundErr)
}</span>

// IsAlreadyExists checks if an error is an AlreadyExistsError
func IsAlreadyExists(err error) bool <span class="cov3" title="3">{
        var existsErr *AlreadyExistsError
        return errors.Is(err, &amp;AlreadyExistsError{}) || errors.As(err, &amp;existsErr)
}</span>

// IsValidation checks if an error is a ValidationError
func IsValidation(err error) bool <span class="cov4" title="5">{
        var validationErr *ValidationError
        return errors.Is(err, &amp;ValidationError{}) || errors.As(err, &amp;validationErr)
}</span>

// IsAuthentication checks if an error is an AuthenticationError
func IsAuthentication(err error) bool <span class="cov6" title="15">{
        var authErr *AuthenticationError
        return errors.Is(err, &amp;AuthenticationError{}) || errors.As(err, &amp;authErr)
}</span>

// IsAuthorization checks if an error is an AuthorizationError
func IsAuthorization(err error) bool <span class="cov6" title="12">{
        var authzErr *AuthorizationError
        return errors.Is(err, &amp;AuthorizationError{}) || errors.As(err, &amp;authzErr)
}</span>

// IsConfiguration checks if an error is a ConfigurationError
func IsConfiguration(err error) bool <span class="cov5" title="8">{
        var configErr *ConfigurationError
        return errors.Is(err, &amp;ConfigurationError{}) || errors.As(err, &amp;configErr)
}</span>

// NewNotFoundError creates a new NotFoundError for a custom entity
func NewNotFoundError(entity string) error <span class="cov4" title="6">{
        return &amp;NotFoundError{Entity: entity}
}</span>

// NewAlreadyExistsError creates a new AlreadyExistsError for a custom entity
func NewAlreadyExistsError(entity, context string) error <span class="cov1" title="1">{
        return &amp;AlreadyExistsError{Entity: entity, Context: context}
}</span>

// NewValidationError creates a new ValidationError
func NewValidationError(field, message string) error <span class="cov7" title="26">{
        return &amp;ValidationError{Field: field, Message: message}
}</span>

// NewAuthenticationError creates a new AuthenticationError
func NewAuthenticationError(message string) error <span class="cov0" title="0">{
        return &amp;AuthenticationError{Message: message}
}</span>

// NewAuthorizationError creates a new AuthorizationError
func NewAuthorizationError(message string) error <span class="cov0" title="0">{
        return &amp;AuthorizationError{Message: message}
}</span>

// NewConfigurationError creates a new ConfigurationError
func NewConfigurationError(message string) error <span class="cov0" title="0">{
        return &amp;ConfigurationError{Message: message}
}</span>

// NewAICoreCredentialsNotFoundError creates a specific error for missing team credentials
func NewAICoreCredentialsNotFoundError(teamName string) error <span class="cov2" title="2">{
        return &amp;ConfigurationError{Message: fmt.Sprintf("no credentials found for team: %s", teamName)}
}</span>

// NewMissingQueryParam creates a new ValidationError for missing query parameters
func NewMissingQueryParam(queryParam string) error <span class="cov6" title="15">{
        return &amp;ValidationError{Field: queryParam, Message: fmt.Sprintf("missing required query parameter: %s", queryParam)}
}</span>

// NewJiraPATError creates a detailed Jira PAT operation error
func NewJiraPATError(operation string, details string) error <span class="cov6" title="12">{
        return fmt.Errorf("%w: %s - %s", ErrJiraPATOperation, operation, details)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package logger

import (
        "context"

        "github.com/gin-gonic/gin"
        "github.com/sirupsen/logrus"
)

// Logger wraps logrus for structured logging with context support
type Logger struct {
        *logrus.Entry
}

// New creates a new logger
func New() *Logger <span class="cov10" title="263">{
        return &amp;Logger{
                Entry: logrus.NewEntry(logrus.StandardLogger()),
        }
}</span>

// FromGinContext creates a logger with request context from gin.Context
// Includes: user_email, user_id, request_id, client_ip, method
func FromGinContext(c *gin.Context) *Logger <span class="cov6" title="30">{
        fields := make(map[string]interface{})

        // Add user email if available
        if email, exists := c.Get("email"); exists </span><span class="cov4" title="10">{
                fields["user_email"] = email
        }</span>

        // Add user ID if available
        <span class="cov6" title="30">if userID, exists := c.Get("user_id"); exists </span><span class="cov0" title="0">{
                fields["user_id"] = userID
        }</span>

        // Add request ID if available
        <span class="cov6" title="30">if requestID, exists := c.Get("request_id"); exists </span><span class="cov0" title="0">{
                fields["request_id"] = requestID
        }</span>

        // Add client IP
        <span class="cov6" title="30">fields["client_ip"] = c.ClientIP()

        // Add HTTP method
        fields["method"] = c.Request.Method

        return New().WithFields(fields)</span>
}

// WithContext creates a logger with user context information
func WithContext(ctx context.Context) *Logger <span class="cov9" title="147">{
        logger := New()

        // Extract user information from context
        if email, ok := ctx.Value("email").(string); ok &amp;&amp; email != "" </span><span class="cov0" title="0">{
                logger.Entry = logger.Entry.WithField("user", email)
        }</span> else<span class="cov9" title="147"> if username, ok := ctx.Value("username").(string); ok &amp;&amp; username != "" </span><span class="cov0" title="0">{
                logger.Entry = logger.Entry.WithField("user", username)
        }</span> else<span class="cov9" title="147"> if user, ok := ctx.Value("user").(string); ok &amp;&amp; user != "" </span><span class="cov0" title="0">{
                logger.Entry = logger.Entry.WithField("user", user)
        }</span> else<span class="cov9" title="147"> {
                logger.Entry = logger.Entry.WithField("user", "unknown")
        }</span>

        <span class="cov9" title="147">return logger</span>
}

// WithField adds a field to the logger
func (l *Logger) WithField(key string, value interface{}) *Logger <span class="cov8" title="95">{
        return &amp;Logger{
                Entry: l.Entry.WithField(key, value),
        }
}</span>

// WithFields adds multiple fields to the logger
func (l *Logger) WithFields(fields map[string]interface{}) *Logger <span class="cov9" title="202">{
        return &amp;Logger{
                Entry: l.Entry.WithFields(fields),
        }
}</span>

// Debug logs a debug message (only shown when LOG_LEVEL=debug)
func (l *Logger) Debug(args ...interface{}) <span class="cov6" title="28">{
        l.Entry.Debug(args...)
}</span>

// Debugf logs a formatted debug message (only shown when LOG_LEVEL=debug)
func (l *Logger) Debugf(format string, args ...interface{}) <span class="cov8" title="99">{
        l.Entry.Debugf(format, args...)
}</span>

// Info logs an info message
func (l *Logger) Info(args ...interface{}) <span class="cov8" title="137">{
        l.Entry.Info(args...)
}</span>

// Infof logs a formatted info message
func (l *Logger) Infof(format string, args ...interface{}) <span class="cov8" title="134">{
        l.Entry.Infof(format, args...)
}</span>

// Warn logs a warning message
func (l *Logger) Warn(args ...interface{}) <span class="cov6" title="26">{
        l.Entry.Warn(args...)
}</span>

// Warnf logs a formatted warning message
func (l *Logger) Warnf(format string, args ...interface{}) <span class="cov2" title="2">{
        l.Entry.Warnf(format, args...)
}</span>

// Error logs an error message
func (l *Logger) Error(args ...interface{}) <span class="cov6" title="28">{
        l.Entry.Error(args...)
}</span>

// Errorf logs a formatted error message
func (l *Logger) Errorf(format string, args ...interface{}) <span class="cov7" title="61">{
        l.Entry.Errorf(format, args...)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package repository

import (
        "developer-portal-backend/internal/database/models"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

// CategoryRepository handles database operations for categories
type CategoryRepository struct {
        db *gorm.DB
}

// Ensure CategoryRepository implements CategoryRepositoryInterface
var _ CategoryRepositoryInterface = (*CategoryRepository)(nil)

// NewCategoryRepository creates a new category repository
func NewCategoryRepository(db *gorm.DB) *CategoryRepository <span class="cov1" title="1">{
        return &amp;CategoryRepository{db: db}
}</span>

// GetAll retrieves all categories with pagination
func (r *CategoryRepository) GetAll(limit, offset int) ([]models.Category, int64, error) <span class="cov10" title="4">{
        var categories []models.Category
        var total int64

        // Count total
        if err := r.db.Model(&amp;models.Category{}).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Fetch page
        <span class="cov10" title="4">if err := r.db.Limit(limit).Offset(offset).Order("title ASC").Find(&amp;categories).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov10" title="4">return categories, total, nil</span>
}

// GetByID retrieves a category by its UUID
func (r *CategoryRepository) GetByID(id uuid.UUID) (*models.Category, error) <span class="cov5" title="2">{
        var category models.Category
        if err := r.db.First(&amp;category, "id = ?", id).Error; err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return &amp;category, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package repository

import (
        "developer-portal-backend/internal/database/models"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

// ComponentRepository handles database operations for components
type ComponentRepository struct {
        db *gorm.DB
}

// NewComponentRepository creates a new component repository
func NewComponentRepository(db *gorm.DB) *ComponentRepository <span class="cov1" title="1">{
        return &amp;ComponentRepository{db: db}
}</span>

// Create creates a new component
func (r *ComponentRepository) Create(component *models.Component) error <span class="cov10" title="5">{
        return r.db.Create(component).Error
}</span>

// GetByID retrieves a component by ID
func (r *ComponentRepository) GetByID(id uuid.UUID) (*models.Component, error) <span class="cov8" title="4">{
        var component models.Component
        err := r.db.First(&amp;component, "id = ?", id).Error
        if err != nil </span><span class="cov4" title="2">{
                return nil, err
        }</span>
        <span class="cov4" title="2">return &amp;component, nil</span>
}

// GetByName retrieves a component by name within an organization
func (r *ComponentRepository) GetByName(projectID uuid.UUID, name string) (*models.Component, error) <span class="cov4" title="2">{
        var component models.Component
        err := r.db.First(&amp;component, "project_id = ? AND name = ?", projectID, name).Error
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return &amp;component, nil</span>
}

// GetByOrganizationID retrieves all components for an organization with pagination
func (r *ComponentRepository) GetByOrganizationID(orgID uuid.UUID, limit, offset int) ([]models.Component, int64, error) <span class="cov0" title="0">{
        var components []models.Component
        var total int64

        // Get total count
        if err := r.db.Model(&amp;models.Component{}).Where("organization_id = ?", orgID).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get paginated results
        <span class="cov0" title="0">err := r.db.Where("organization_id = ?", orgID).Limit(limit).Offset(offset).Find(&amp;components).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return components, total, nil</span>
}

// GetByType retrieves all components of a specific type in an organization

// GetByStatus retrieves all components with a specific status in an organization

// GetActiveComponents retrieves all active components for an organization

// Update updates a component
func (r *ComponentRepository) Update(component *models.Component) error <span class="cov1" title="1">{
        return r.db.Save(component).Error
}</span>

// Delete deletes a component
func (r *ComponentRepository) Delete(id uuid.UUID) error <span class="cov4" title="2">{
        return r.db.Delete(&amp;models.Component{}, "id = ?", id).Error
}</span>

// GetWithOrganization retrieves a component with organization details
func (r *ComponentRepository) GetWithOrganization(id uuid.UUID) (*models.Component, error) <span class="cov0" title="0">{
        var component models.Component
        err := r.db.Preload("Organization").First(&amp;component, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;component, nil</span>
}

// GetWithProjects retrieves a component with all its projects
func (r *ComponentRepository) GetWithProjects(id uuid.UUID) (*models.Component, error) <span class="cov0" title="0">{
        var component models.Component
        err := r.db.Preload("Projects").First(&amp;component, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;component, nil</span>
}

// GetWithDeployments retrieves a component with all its deployments
func (r *ComponentRepository) GetWithDeployments(id uuid.UUID) (*models.Component, error) <span class="cov0" title="0">{
        var component models.Component
        err := r.db.Preload("Deployments").First(&amp;component, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;component, nil</span>
}

// GetWithTeamOwnerships retrieves a component with team ownerships
func (r *ComponentRepository) GetWithTeamOwnerships(id uuid.UUID) (*models.Component, error) <span class="cov0" title="0">{
        var component models.Component
        err := r.db.Preload("TeamOwnerships").Preload("TeamOwnerships.Team").First(&amp;component, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;component, nil</span>
}

// GetWithFullDetails retrieves a component with all relationships
func (r *ComponentRepository) GetWithFullDetails(id uuid.UUID) (*models.Component, error) <span class="cov0" title="0">{
        var component models.Component
        err := r.db.
                Preload("Organization").
                Preload("Projects").
                Preload("Deployments").
                Preload("TeamOwnerships").
                Preload("TeamOwnerships.Team").
                First(&amp;component, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;component, nil</span>
}

// SetStatus sets the status of a component

// Search searches for components by name or description
func (r *ComponentRepository) Search(orgID uuid.UUID, query string, limit, offset int) ([]models.Component, int64, error) <span class="cov0" title="0">{
        var components []models.Component
        var total int64

        searchQuery := r.db.Model(&amp;models.Component{}).Where("organization_id = ? AND (name ILIKE ? OR description ILIKE ?)", orgID, "%"+query+"%", "%"+query+"%")

        // Get total count
        if err := searchQuery.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get paginated results
        <span class="cov0" title="0">err := searchQuery.Limit(limit).Offset(offset).Find(&amp;components).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return components, total, nil</span>
}

// CheckComponentExists checks if a component exists by ID
func (r *ComponentRepository) CheckComponentExists(id uuid.UUID) (bool, error) <span class="cov0" title="0">{
        var count int64
        err := r.db.Model(&amp;models.Component{}).Where("id = ?", id).Count(&amp;count).Error
        return count &gt; 0, err
}</span>

// CheckComponentNameExists checks if a component name exists within an organization
func (r *ComponentRepository) CheckComponentNameExists(orgID uuid.UUID, name string, excludeID *uuid.UUID) (bool, error) <span class="cov0" title="0">{
        query := r.db.Model(&amp;models.Component{}).Where("organization_id = ? AND name = ?", orgID, name)
        if excludeID != nil </span><span class="cov0" title="0">{
                query = query.Where("id != ?", *excludeID)
        }</span>

        <span class="cov0" title="0">var count int64
        err := query.Count(&amp;count).Error
        return count &gt; 0, err</span>
}

// GetComponentsByTeamID retrieves all components owned by a specific team
func (r *ComponentRepository) GetComponentsByTeamID(teamID uuid.UUID, limit, offset int) ([]models.Component, int64, error) <span class="cov0" title="0">{
        var components []models.Component
        var total int64

        // New model stores ownership directly in components.owner_id
        query := r.db.Model(&amp;models.Component{}).Where("owner_id = ?", teamID)
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">if err := query.Limit(limit).Offset(offset).Find(&amp;components).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return components, total, nil</span>
}

// Added: GetByOwnerID to align with new interface
func (r *ComponentRepository) GetByOwnerID(ownerID uuid.UUID, limit, offset int) ([]models.Component, int64, error) <span class="cov0" title="0">{
        return r.GetComponentsByTeamID(ownerID, limit, offset)
}</span>

// GetComponentsByProjectID retrieves all components used by a specific project
func (r *ComponentRepository) GetComponentsByProjectID(projectID uuid.UUID, limit, offset int) ([]models.Component, int64, error) <span class="cov0" title="0">{
        var components []models.Component
        var total int64

        // New model stores project reference directly in components.project_id
        query := r.db.Model(&amp;models.Component{}).Where("project_id = ?", projectID)
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">if err := query.Limit(limit).Offset(offset).Find(&amp;components).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return components, total, nil</span>
}

// Added: GetByProjectID to align with new interface
func (r *ComponentRepository) GetByProjectID(projectID uuid.UUID, limit, offset int) ([]models.Component, int64, error) <span class="cov0" title="0">{
        return r.GetComponentsByProjectID(projectID, limit, offset)
}</span>

// GetComponentsByTypeAndStatus retrieves components by type and status

// GetComponentsByMetadata searches components by metadata field
func (r *ComponentRepository) GetComponentsByMetadata(orgID uuid.UUID, metadata string, limit, offset int) ([]models.Component, int64, error) <span class="cov0" title="0">{
        var components []models.Component
        var total int64

        // Search in JSONB field
        query := r.db.Model(&amp;models.Component{}).Where("organization_id = ? AND metadata::text ILIKE ?", orgID, "%"+metadata+"%")

        // Get total count
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get paginated results
        <span class="cov0" title="0">err := query.Limit(limit).Offset(offset).Find(&amp;components).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return components, total, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package repository

import (
        "developer-portal-backend/internal/database/models"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

// DocumentationRepository handles database operations for documentations
type DocumentationRepository struct {
        db *gorm.DB
}

// Ensure DocumentationRepository implements DocumentationRepositoryInterface
var _ DocumentationRepositoryInterface = (*DocumentationRepository)(nil)

// NewDocumentationRepository creates a new documentation repository
func NewDocumentationRepository(db *gorm.DB) *DocumentationRepository <span class="cov0" title="0">{
        return &amp;DocumentationRepository{db: db}
}</span>

// Create inserts a new documentation
func (r *DocumentationRepository) Create(doc *models.Documentation) error <span class="cov0" title="0">{
        return r.db.Create(doc).Error
}</span>

// GetByID retrieves a documentation by its ID
func (r *DocumentationRepository) GetByID(id uuid.UUID) (*models.Documentation, error) <span class="cov0" title="0">{
        var doc models.Documentation
        if err := r.db.First(&amp;doc, "id = ?", id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;doc, nil</span>
}

// GetByTeamID retrieves all documentations for a specific team
func (r *DocumentationRepository) GetByTeamID(teamID uuid.UUID) ([]models.Documentation, error) <span class="cov0" title="0">{
        var docs []models.Documentation
        if err := r.db.Where("team_id = ?", teamID).Order("title ASC").Find(&amp;docs).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return docs, nil</span>
}

// Update updates an existing documentation
func (r *DocumentationRepository) Update(doc *models.Documentation) error <span class="cov0" title="0">{
        return r.db.Save(doc).Error
}</span>

// Delete removes a documentation by ID (soft delete)
func (r *DocumentationRepository) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.Delete(&amp;models.Documentation{}, "id = ?", id).Error
}</span>

// GetAll retrieves all documentations (with optional pagination)
func (r *DocumentationRepository) GetAll(limit, offset int) ([]models.Documentation, int64, error) <span class="cov0" title="0">{
        var docs []models.Documentation
        var total int64

        // Count total
        if err := r.db.Model(&amp;models.Documentation{}).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get paginated results
        <span class="cov0" title="0">query := r.db.Order("title ASC")
        if limit &gt; 0 </span><span class="cov0" title="0">{
                query = query.Limit(limit).Offset(offset)
        }</span>

        <span class="cov0" title="0">if err := query.Find(&amp;docs).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return docs, total, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package repository

import (
        "developer-portal-backend/internal/database/models"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

// GroupRepository handles database operations for groups
type GroupRepository struct {
        db *gorm.DB
}

// NewGroupRepository creates a new group repository
func NewGroupRepository(db *gorm.DB) *GroupRepository <span class="cov7" title="12">{
        return &amp;GroupRepository{db: db}
}</span>

// Create creates a new group
func (r *GroupRepository) Create(group *models.Group) error <span class="cov10" title="29">{
        return r.db.Create(group).Error
}</span>

// GetByID retrieves a group by ID
func (r *GroupRepository) GetByID(id uuid.UUID) (*models.Group, error) <span class="cov4" title="4">{
        var group models.Group
        err := r.db.First(&amp;group, "id = ?", id).Error
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>
        <span class="cov2" title="2">return &amp;group, nil</span>
}

// GetByName retrieves a group by name within an organization
func (r *GroupRepository) GetByName(orgID uuid.UUID, name string) (*models.Group, error) <span class="cov2" title="2">{
        var group models.Group
        err := r.db.First(&amp;group, "org_id = ? AND name = ?", orgID, name).Error
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return &amp;group, nil</span>
}

// GetByOrganizationID retrieves all groups for an organization with pagination
func (r *GroupRepository) GetByOrganizationID(orgID uuid.UUID, limit, offset int) ([]models.Group, int64, error) <span class="cov4" title="4">{
        var groups []models.Group
        var total int64

        // Get total count
        if err := r.db.Model(&amp;models.Group{}).Where("org_id = ?", orgID).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get paginated results
        <span class="cov4" title="4">err := r.db.Where("org_id = ?", orgID).Limit(limit).Offset(offset).Find(&amp;groups).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov4" title="4">return groups, total, nil</span>
}

// Update updates a group using a map of updates
func (r *GroupRepository) Update(id uuid.UUID, updates map[string]interface{}) error <span class="cov1" title="1">{
        return r.db.Model(&amp;models.Group{}).Where("id = ?", id).Updates(updates).Error
}</span>

// Delete deletes a group
func (r *GroupRepository) Delete(id uuid.UUID) error <span class="cov2" title="2">{
        return r.db.Delete(&amp;models.Group{}, "id = ?", id).Error
}</span>

// GetWithTeams retrieves a group with its teams
func (r *GroupRepository) GetWithTeams(id uuid.UUID) (*models.Group, error) <span class="cov0" title="0">{
        var group models.Group
        err := r.db.Preload("Teams").First(&amp;group, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;group, nil</span>
}

// GetWithOrganization retrieves a group with its organization
func (r *GroupRepository) GetWithOrganization(id uuid.UUID) (*models.Group, error) <span class="cov0" title="0">{
        var group models.Group
        err := r.db.Preload("Organization").First(&amp;group, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;group, nil</span>
}

// Search searches for groups by name or description within an organization
func (r *GroupRepository) Search(organizationID uuid.UUID, query string, limit, offset int) ([]models.Group, int64, error) <span class="cov2" title="2">{
        var groups []models.Group
        var total int64

        // Build search query
        searchQuery := "%" + query + "%"
        whereClause := "org_id = ? AND (name ILIKE ? OR title ILIKE ? OR description ILIKE ?)"

        // Get total count
        if err := r.db.Model(&amp;models.Group{}).Where(whereClause, organizationID, searchQuery, searchQuery, searchQuery).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get paginated results
        <span class="cov2" title="2">err := r.db.Where(whereClause, organizationID, searchQuery, searchQuery, searchQuery).
                Limit(limit).Offset(offset).Find(&amp;groups).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov2" title="2">return groups, total, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package repository

import (
        "developer-portal-backend/internal/database/models"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

// LandscapeRepository handles database operations for landscapes
type LandscapeRepository struct {
        db *gorm.DB
}

// NewLandscapeRepository creates a new landscape repository
func NewLandscapeRepository(db *gorm.DB) *LandscapeRepository <span class="cov1" title="1">{
        return &amp;LandscapeRepository{db: db}
}</span>

// Create creates a new landscape
func (r *LandscapeRepository) Create(landscape *models.Landscape) error <span class="cov10" title="15">{
        return r.db.Create(landscape).Error
}</span>

// GetByID retrieves a landscape by ID
func (r *LandscapeRepository) GetByID(id uuid.UUID) (*models.Landscape, error) <span class="cov5" title="4">{
        var landscape models.Landscape
        err := r.db.First(&amp;landscape, "id = ?", id).Error
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>
        <span class="cov3" title="2">return &amp;landscape, nil</span>
}

// GetByName retrieves a landscape by name
func (r *LandscapeRepository) GetByName(name string) (*models.Landscape, error) <span class="cov3" title="2">{
        // New model has no organization scope; filter by name only
        var landscape models.Landscape
        err := r.db.First(&amp;landscape, "name = ?", name).Error
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return &amp;landscape, nil</span>
}

// GetByOrganizationID retrieves landscapes with pagination
func (r *LandscapeRepository) GetByOrganizationID(orgID uuid.UUID, limit, offset int) ([]models.Landscape, int64, error) <span class="cov5" title="4">{
        // New model has no organization scope; return all landscapes paginated
        var landscapes []models.Landscape
        var total int64

        if err := r.db.Model(&amp;models.Landscape{}).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov5" title="4">if err := r.db.Model(&amp;models.Landscape{}).Limit(limit).Offset(offset).Find(&amp;landscapes).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov5" title="4">return landscapes, total, nil</span>
}

// GetByType retrieves all landscapes of a specific environment
func (r *LandscapeRepository) GetByType(orgID uuid.UUID, landscapeType string, limit, offset int) ([]models.Landscape, int64, error) <span class="cov0" title="0">{
        var landscapes []models.Landscape
        var total int64

        query := r.db.Model(&amp;models.Landscape{}).Where("environment = ?", landscapeType)

        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if err := query.Limit(limit).Offset(offset).Find(&amp;landscapes).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return landscapes, total, nil</span>
}

// GetByStatus returns all landscapes (status not present in new model)
func (r *LandscapeRepository) GetByStatus(status string, limit, offset int) ([]models.Landscape, int64, error) <span class="cov0" title="0">{
        var landscapes []models.Landscape
        var total int64

        query := r.db.Model(&amp;models.Landscape{})

        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if err := query.Limit(limit).Offset(offset).Find(&amp;landscapes).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return landscapes, total, nil</span>
}

// GetActiveLandscapes returns all landscapes (no status column)
func (r *LandscapeRepository) GetActiveLandscapes(limit, offset int) ([]models.Landscape, int64, error) <span class="cov0" title="0">{
        var landscapes []models.Landscape
        var total int64

        if err := r.db.Model(&amp;models.Landscape{}).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if err := r.db.Model(&amp;models.Landscape{}).Limit(limit).Offset(offset).Find(&amp;landscapes).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return landscapes, total, nil</span>
}

// Update updates a landscape
func (r *LandscapeRepository) Update(landscape *models.Landscape) error <span class="cov1" title="1">{
        return r.db.Save(landscape).Error
}</span>

// Delete deletes a landscape
func (r *LandscapeRepository) Delete(id uuid.UUID) error <span class="cov3" title="2">{
        return r.db.Delete(&amp;models.Landscape{}, "id = ?", id).Error
}</span>

/* GetWithOrganization returns the landscape (no organization relation in new model) */
func (r *LandscapeRepository) GetWithOrganization(id uuid.UUID) (*models.Landscape, error) <span class="cov0" title="0">{
        return r.GetByID(id)
}</span>

// GetWithProjects returns the landscape (project relation is via ProjectID field)
func (r *LandscapeRepository) GetWithProjects(id uuid.UUID) (*models.Landscape, error) <span class="cov0" title="0">{
        return r.GetByID(id)
}</span>

// GetWithComponentDeployments returns the landscape (no direct preload on new model struct)
func (r *LandscapeRepository) GetWithComponentDeployments(id uuid.UUID) (*models.Landscape, error) <span class="cov0" title="0">{
        return r.GetByID(id)
}</span>

// GetWithFullDetails returns the landscape (no additional relations on new model struct)
func (r *LandscapeRepository) GetWithFullDetails(id uuid.UUID) (*models.Landscape, error) <span class="cov0" title="0">{
        return r.GetByID(id)
}</span>

// SetStatus is a no-op (status not present in new model)
func (r *LandscapeRepository) SetStatus(landscapeID uuid.UUID, status string) error <span class="cov0" title="0">{
        return nil
}</span>

// Search searches for landscapes by name, title, or description
func (r *LandscapeRepository) Search(orgID uuid.UUID, q string, limit, offset int) ([]models.Landscape, int64, error) <span class="cov0" title="0">{
        var landscapes []models.Landscape
        var total int64

        searchQuery := r.db.Model(&amp;models.Landscape{}).
                Where("(name ILIKE ? OR title ILIKE ? OR description ILIKE ?)", "%"+q+"%", "%"+q+"%", "%"+q+"%")

        if err := searchQuery.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if err := searchQuery.Limit(limit).Offset(offset).Find(&amp;landscapes).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return landscapes, total, nil</span>
}

// GetProjectCount returns the number of projects using a landscape (1 if ProjectID set)
func (r *LandscapeRepository) GetProjectCount(landscapeID uuid.UUID) (int64, error) <span class="cov0" title="0">{
        var l models.Landscape
        if err := r.db.Select("project_id").First(&amp;l, "id = ?", landscapeID).Error; err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if l.ProjectID == uuid.Nil </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">return 1, nil</span>
}

// CheckLandscapeExists checks if a landscape exists by ID
func (r *LandscapeRepository) CheckLandscapeExists(id uuid.UUID) (bool, error) <span class="cov0" title="0">{
        var count int64
        err := r.db.Model(&amp;models.Landscape{}).Where("id = ?", id).Count(&amp;count).Error
        return count &gt; 0, err
}</span>

// CheckLandscapeNameExists checks if a landscape name exists (ignores organization scope)
func (r *LandscapeRepository) CheckLandscapeNameExists(orgID uuid.UUID, name string, excludeID *uuid.UUID) (bool, error) <span class="cov0" title="0">{
        query := r.db.Model(&amp;models.Landscape{}).Where("name = ?", name)
        if excludeID != nil </span><span class="cov0" title="0">{
                query = query.Where("id != ?", *excludeID)
        }</span>

        <span class="cov0" title="0">var count int64
        err := query.Count(&amp;count).Error
        return count &gt; 0, err</span>
}

// GetLandscapesByProjectID retrieves all landscapes for a specific project
func (r *LandscapeRepository) GetLandscapesByProjectID(projectID uuid.UUID, limit, offset int) ([]models.Landscape, int64, error) <span class="cov0" title="0">{
        var landscapes []models.Landscape
        var total int64

        if err := r.db.Model(&amp;models.Landscape{}).Where("project_id = ?", projectID).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if err := r.db.Where("project_id = ?", projectID).Limit(limit).Offset(offset).Find(&amp;landscapes).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return landscapes, total, nil</span>
}

// GetLandscapesByTypeAndStatus retrieves landscapes by environment (status ignored)
func (r *LandscapeRepository) GetLandscapesByTypeAndStatus(orgID uuid.UUID, landscapeType string, status string, limit, offset int) ([]models.Landscape, int64, error) <span class="cov0" title="0">{
        var landscapes []models.Landscape
        var total int64

        query := r.db.Model(&amp;models.Landscape{}).Where("environment = ?", landscapeType)

        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if err := query.Limit(limit).Offset(offset).Find(&amp;landscapes).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return landscapes, total, nil</span>
}

// GetLandscapesByEnvironment retrieves landscapes by environment
func (r *LandscapeRepository) GetLandscapesByEnvironment(orgID uuid.UUID, environment string, limit, offset int) ([]models.Landscape, int64, error) <span class="cov0" title="0">{
        var landscapes []models.Landscape
        var total int64

        query := r.db.Model(&amp;models.Landscape{}).Where("environment = ?", environment)

        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if err := query.Limit(limit).Offset(offset).Find(&amp;landscapes).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return landscapes, total, nil</span>
}

// Convenience helpers by environment

func (r *LandscapeRepository) GetProductionLandscapes(orgID uuid.UUID, limit, offset int) ([]models.Landscape, int64, error) <span class="cov0" title="0">{
        return r.GetLandscapesByEnvironment(orgID, "production", limit, offset)
}</span>

func (r *LandscapeRepository) GetDevelopmentLandscapes(orgID uuid.UUID, limit, offset int) ([]models.Landscape, int64, error) <span class="cov0" title="0">{
        return r.GetLandscapesByEnvironment(orgID, "development", limit, offset)
}</span>

func (r *LandscapeRepository) GetStagingLandscapes(orgID uuid.UUID, limit, offset int) ([]models.Landscape, int64, error) <span class="cov0" title="0">{
        return r.GetLandscapesByEnvironment(orgID, "staging", limit, offset)
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package repository

import (
        "developer-portal-backend/internal/database/models"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

// LinkRepository handles database operations for links
type LinkRepository struct {
        db *gorm.DB
}

// Ensure LinkRepository implements LinkRepositoryInterface
var _ LinkRepositoryInterface = (*LinkRepository)(nil)

// NewLinkRepository creates a new link repository
func NewLinkRepository(db *gorm.DB) *LinkRepository <span class="cov1" title="1">{
        return &amp;LinkRepository{db: db}
}</span>

// GetByOwner retrieves all links owned by the specified owner (user/team) UUID
func (r *LinkRepository) GetByOwner(owner uuid.UUID) ([]models.Link, error) <span class="cov1" title="1">{
        var links []models.Link
        if err := r.db.Where("owner = ?", owner).Order("title ASC").Find(&amp;links).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return links, nil</span>
}

// GetByIDs retrieves links by a set of UUID IDs
func (r *LinkRepository) GetByIDs(ids []uuid.UUID) ([]models.Link, error) <span class="cov10" title="3">{
        if len(ids) == 0 </span><span class="cov1" title="1">{
                return []models.Link{}, nil
        }</span>
        <span class="cov6" title="2">var links []models.Link
        if err := r.db.Where("id IN ?", ids).Order("title ASC").Find(&amp;links).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="2">return links, nil</span>
}

 // Create inserts a new link
func (r *LinkRepository) Create(link *models.Link) error <span class="cov1" title="1">{
        return r.db.Create(link).Error
}</span>

// Delete removes a link by ID
func (r *LinkRepository) Delete(id uuid.UUID) error <span class="cov6" title="2">{
        return r.db.Delete(&amp;models.Link{}, "id = ?", id).Error
}</span>

// GetByID retrieves a link by its UUID
func (r *LinkRepository) GetByID(id uuid.UUID) (*models.Link, error) <span class="cov0" title="0">{
        var link models.Link
        if err := r.db.Where("id = ?", id).First(&amp;link).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;link, nil</span>
}

// Update updates an existing link
func (r *LinkRepository) Update(link *models.Link) error <span class="cov0" title="0">{
        return r.db.Save(link).Error
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package repository

import (
        "developer-portal-backend/internal/database/models"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

// OrganizationRepository handles database operations for organizations
type OrganizationRepository struct {
        db *gorm.DB
}

// NewOrganizationRepository creates a new organization repository
func NewOrganizationRepository(db *gorm.DB) *OrganizationRepository <span class="cov9" title="35">{
        return &amp;OrganizationRepository{db: db}
}</span>

// Create creates a new organization
func (r *OrganizationRepository) Create(org *models.Organization) error <span class="cov10" title="50">{
        return r.db.Create(org).Error
}</span>

// GetByID retrieves an organization by ID
func (r *OrganizationRepository) GetByID(id uuid.UUID) (*models.Organization, error) <span class="cov4" title="4">{
        var org models.Organization
        err := r.db.First(&amp;org, "id = ?", id).Error
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>
        <span class="cov2" title="2">return &amp;org, nil</span>
}

// GetByName retrieves an organization by name
func (r *OrganizationRepository) GetByName(name string) (*models.Organization, error) <span class="cov2" title="2">{
        var org models.Organization
        err := r.db.First(&amp;org, "name = ?", name).Error
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return &amp;org, nil</span>
}

// GetByDomain retrieves an organization by domain
func (r *OrganizationRepository) GetByDomain(domain string) (*models.Organization, error) <span class="cov0" title="0">{
        var org models.Organization
        err := r.db.First(&amp;org, "domain = ?", domain).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;org, nil</span>
}

// GetAll retrieves all organizations with pagination
func (r *OrganizationRepository) GetAll(limit, offset int) ([]models.Organization, int64, error) <span class="cov4" title="4">{
        var orgs []models.Organization
        var total int64

        // Get total count
        if err := r.db.Model(&amp;models.Organization{}).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get paginated results
        <span class="cov4" title="4">err := r.db.Limit(limit).Offset(offset).Find(&amp;orgs).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov4" title="4">return orgs, total, nil</span>
}

// Update updates an organization
func (r *OrganizationRepository) Update(org *models.Organization) error <span class="cov1" title="1">{
        return r.db.Save(org).Error
}</span>

// Delete deletes an organization
func (r *OrganizationRepository) Delete(id uuid.UUID) error <span class="cov2" title="2">{
        return r.db.Delete(&amp;models.Organization{}, "id = ?", id).Error
}</span>

// GetWithMembers retrieves an organization with its members
func (r *OrganizationRepository) GetWithMembers(id uuid.UUID) (*models.Organization, error) <span class="cov0" title="0">{
        var org models.Organization
        err := r.db.Preload("Users").First(&amp;org, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;org, nil</span>
}

// GetWithGroups retrieves an organization with its groups
func (r *OrganizationRepository) GetWithGroups(id uuid.UUID) (*models.Organization, error) <span class="cov0" title="0">{
        var org models.Organization
        err := r.db.Preload("Groups").First(&amp;org, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;org, nil</span>
}

// GetWithProjects retrieves an organization with its projects
func (r *OrganizationRepository) GetWithProjects(id uuid.UUID) (*models.Organization, error) <span class="cov0" title="0">{
        var org models.Organization
        err := r.db.Preload("Projects").First(&amp;org, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;org, nil</span>
}

// GetWithComponents retrieves an organization with its components
func (r *OrganizationRepository) GetWithComponents(id uuid.UUID) (*models.Organization, error) <span class="cov0" title="0">{
        var org models.Organization
        err := r.db.Preload("Components").First(&amp;org, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;org, nil</span>
}

// GetWithLandscapes retrieves an organization with its landscapes
func (r *OrganizationRepository) GetWithLandscapes(id uuid.UUID) (*models.Organization, error) <span class="cov0" title="0">{
        var org models.Organization
        err := r.db.Preload("Landscapes").First(&amp;org, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;org, nil</span>
}

// GetWithAllRelations retrieves an organization with all its relations
func (r *OrganizationRepository) GetWithAllRelations(id uuid.UUID) (*models.Organization, error) <span class="cov0" title="0">{
        var org models.Organization
        err := r.db.
                Preload("Users").
                Preload("Groups").
                Preload("Projects").
                Preload("Components").
                Preload("Landscapes").
                First(&amp;org, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;org, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package repository

import (
        "developer-portal-backend/internal/database/models"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

// PluginRepository handles database operations for plugins
type PluginRepository struct {
        db *gorm.DB
}

// NewPluginRepository creates a new plugin repository
func NewPluginRepository(db *gorm.DB) *PluginRepository <span class="cov3" title="2">{
        return &amp;PluginRepository{db: db}
}</span>

// Create creates a new plugin
func (r *PluginRepository) Create(plugin *models.Plugin) error <span class="cov10" title="11">{
        return r.db.Create(plugin).Error
}</span>

// GetByID retrieves a plugin by ID
func (r *PluginRepository) GetByID(id uuid.UUID) (*models.Plugin, error) <span class="cov9" title="9">{
        var plugin models.Plugin
        err := r.db.First(&amp;plugin, "id = ?", id).Error
        if err != nil </span><span class="cov5" title="3">{
                return nil, err
        }</span>
        <span class="cov7" title="6">return &amp;plugin, nil</span>
}

// GetByName retrieves a plugin by name
func (r *PluginRepository) GetByName(name string) (*models.Plugin, error) <span class="cov5" title="3">{
        var plugin models.Plugin
        err := r.db.First(&amp;plugin, "name = ?", name).Error
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov3" title="2">return &amp;plugin, nil</span>
}

// GetAll retrieves all plugins with pagination
func (r *PluginRepository) GetAll(limit, offset int) ([]models.Plugin, int64, error) <span class="cov7" title="5">{
        var plugins []models.Plugin
        var total int64

        // Get total count
        if err := r.db.Model(&amp;models.Plugin{}).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get paginated results
        <span class="cov7" title="5">if err := r.db.Model(&amp;models.Plugin{}).Limit(limit).Offset(offset).Find(&amp;plugins).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov7" title="5">return plugins, total, nil</span>
}

// Update updates a plugin
func (r *PluginRepository) Update(plugin *models.Plugin) error <span class="cov5" title="3">{
        return r.db.Save(plugin).Error
}</span>

// Delete deletes a plugin
func (r *PluginRepository) Delete(id uuid.UUID) error <span class="cov5" title="3">{
        return r.db.Delete(&amp;models.Plugin{}, "id = ?", id).Error
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package repository

import (
        "developer-portal-backend/internal/database/models"
        "encoding/json"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

// ProjectRepository handles database operations for projects
type ProjectRepository struct {
        db *gorm.DB
}

// NewProjectRepository creates a new project repository
func NewProjectRepository(db *gorm.DB) *ProjectRepository <span class="cov7" title="7">{
        return &amp;ProjectRepository{db: db}
}</span>

// Create creates a new project
func (r *ProjectRepository) Create(project *models.Project) error <span class="cov10" title="16">{
        return r.db.Create(project).Error
}</span>

// GetByID retrieves a project by ID
func (r *ProjectRepository) GetByID(id uuid.UUID) (*models.Project, error) <span class="cov5" title="4">{
        var project models.Project
        err := r.db.First(&amp;project, "id = ?", id).Error
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>
        <span class="cov3" title="2">return &amp;project, nil</span>
}

// GetByName retrieves a project by name within an organization
func (r *ProjectRepository) GetByName(name string) (*models.Project, error) <span class="cov3" title="2">{
        var project models.Project
        err := r.db.First(&amp;project, "name = ?", name).Error
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return &amp;project, nil</span>
}

// GetByOrganizationID retrieves all projects for an organization with pagination
func (r *ProjectRepository) GetByOrganizationID(orgID uuid.UUID, limit, offset int) ([]models.Project, int64, error) <span class="cov0" title="0">{
        var projects []models.Project
        var total int64

        // Get total count
        if err := r.db.Model(&amp;models.Project{}).Where("organization_id = ?", orgID).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get paginated results
        <span class="cov0" title="0">err := r.db.Where("organization_id = ?", orgID).Limit(limit).Offset(offset).Find(&amp;projects).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return projects, total, nil</span>
}

// GetByStatus retrieves all projects with a specific status in an organization

// GetActiveProjects retrieves all active projects for an organization

// Update updates a project
func (r *ProjectRepository) Update(project *models.Project) error <span class="cov1" title="1">{
        return r.db.Save(project).Error
}</span>

// Delete deletes a project
func (r *ProjectRepository) Delete(id uuid.UUID) error <span class="cov3" title="2">{
        return r.db.Delete(&amp;models.Project{}, "id = ?", id).Error
}</span>

// GetWithOrganization retrieves a project with organization details
func (r *ProjectRepository) GetWithOrganization(id uuid.UUID) (*models.Project, error) <span class="cov0" title="0">{
        var project models.Project
        err := r.db.Preload("Organization").First(&amp;project, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;project, nil</span>
}

// GetWithComponents retrieves a project with all its components
func (r *ProjectRepository) GetWithComponents(id uuid.UUID) (*models.Project, error) <span class="cov0" title="0">{
        var project models.Project
        err := r.db.Preload("Components").First(&amp;project, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;project, nil</span>
}

// GetWithLandscapes retrieves a project with all its landscapes
func (r *ProjectRepository) GetWithLandscapes(id uuid.UUID) (*models.Project, error) <span class="cov0" title="0">{
        var project models.Project
        err := r.db.Preload("Landscapes").First(&amp;project, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;project, nil</span>
}

// GetWithComponentsAndLandscapes retrieves a project with components and landscapes
func (r *ProjectRepository) GetWithComponentsAndLandscapes(id uuid.UUID) (*models.Project, error) <span class="cov0" title="0">{
        var project models.Project
        err := r.db.Preload("Components").Preload("Landscapes").First(&amp;project, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;project, nil</span>
}

// GetWithDeploymentTimelines retrieves a project with deployment timelines
func (r *ProjectRepository) GetWithDeploymentTimelines(id uuid.UUID) (*models.Project, error) <span class="cov0" title="0">{
        var project models.Project
        err := r.db.Preload("DeploymentTimelines").First(&amp;project, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;project, nil</span>
}

// GetWithFullDetails retrieves a project with all relationships
func (r *ProjectRepository) GetWithFullDetails(id uuid.UUID) (*models.Project, error) <span class="cov0" title="0">{
        var project models.Project
        err := r.db.
                Preload("Organization").
                Preload("Components").
                Preload("Landscapes").
                Preload("DeploymentTimelines").
                First(&amp;project, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;project, nil</span>
}

// SetStatus sets the status of a project

// Search searches for projects by name or description
func (r *ProjectRepository) Search(orgID uuid.UUID, query string, limit, offset int) ([]models.Project, int64, error) <span class="cov0" title="0">{
        var projects []models.Project
        var total int64

        searchQuery := r.db.Model(&amp;models.Project{}).Where("organization_id = ? AND (name ILIKE ? OR description ILIKE ?)", orgID, "%"+query+"%", "%"+query+"%")

        // Get total count
        if err := searchQuery.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get paginated results
        <span class="cov0" title="0">err := searchQuery.Limit(limit).Offset(offset).Find(&amp;projects).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return projects, total, nil</span>
}

// GetProjectsWithCounts retrieves projects with their component and landscape counts
func (r *ProjectRepository) GetProjectsWithCounts(orgID uuid.UUID, limit, offset int) ([]map[string]interface{}, int64, error) <span class="cov0" title="0">{
        var projects []models.Project
        var total int64
        var results []map[string]interface{}

        // Get total count
        if err := r.db.Model(&amp;models.Project{}).Where("organization_id = ?", orgID).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get projects with counts
        <span class="cov0" title="0">err := r.db.Raw(`
                SELECT p.*, 
                        COUNT(DISTINCT pc.component_id) as component_count,
                        COUNT(DISTINCT pl.landscape_id) as landscape_count
                FROM projects p
                LEFT JOIN project_components pc ON p.id = pc.project_id
                LEFT JOIN project_landscapes pl ON p.id = pl.project_id
                WHERE p.organization_id = ?
                GROUP BY p.id
                ORDER BY p.created_at DESC
                LIMIT ? OFFSET ?
        `, orgID, limit, offset).Scan(&amp;projects).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Convert to map format for easier JSON handling
        <span class="cov0" title="0">for _, project := range projects </span><span class="cov0" title="0">{
                projectMap := map[string]interface{}{
                        "id":           project.ID,
                        "name":         project.Name,
                        "display_name": project.Title,
                        "description":  project.Description,
                        "created_at":   project.CreatedAt,
                        "updated_at":   project.UpdatedAt,
                }
                results = append(results, projectMap)
        }</span>

        <span class="cov0" title="0">return results, total, nil</span>
}

// CheckProjectExists checks if a project exists by ID
func (r *ProjectRepository) CheckProjectExists(id uuid.UUID) (bool, error) <span class="cov0" title="0">{
        var count int64
        err := r.db.Model(&amp;models.Project{}).Where("id = ?", id).Count(&amp;count).Error
        return count &gt; 0, err
}</span>

// GetHealthMetadata returns the project's health URL template and success regex from metadata.
// If the project is not found, returns an error.
// If metadata or the fields are missing or not strings, returns empty strings with nil error.
func (r *ProjectRepository) GetHealthMetadata(projectID uuid.UUID) (string, string, error) <span class="cov5" title="4">{
        var project models.Project
        if err := r.db.Select("id", "metadata").First(&amp;project, "id = ?", projectID).Error; err != nil </span><span class="cov1" title="1">{
                return "", "", err
        }</span>
        // Handle null or empty metadata
        <span class="cov4" title="3">if len(project.Metadata) == 0 || string(project.Metadata) == "null" </span><span class="cov1" title="1">{
                return "", "", nil
        }</span>
        <span class="cov3" title="2">var meta map[string]interface{}
        if err := json.Unmarshal(project.Metadata, &amp;meta); err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        // URL template from metadata["health"]
        <span class="cov3" title="2">urlTemplate := ""
        if raw, ok := meta["health"]; ok </span><span class="cov1" title="1">{
                if s, ok := raw.(string); ok </span><span class="cov1" title="1">{
                        urlTemplate = s
                }</span>
        }
        // Success regex from metadata["health_success_regex"]
        <span class="cov3" title="2">successRegex := ""
        if raw, ok := meta["health_success_regex"]; ok </span><span class="cov0" title="0">{
                if s, ok := raw.(string); ok </span><span class="cov0" title="0">{
                        successRegex = s
                }</span>
        }
        <span class="cov3" title="2">return urlTemplate, successRegex, nil</span>
}

// GetAllProjects retrieves all projects
func (r *ProjectRepository) GetAllProjects() ([]models.Project, error) <span class="cov0" title="0">{
        var projects []models.Project
        err := r.db.Find(&amp;projects).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return projects, nil</span>
}

// CheckProjectNameExists checks if a project name exists within an organization
func (r *ProjectRepository) CheckProjectNameExists(orgID uuid.UUID, name string, excludeID *uuid.UUID) (bool, error) <span class="cov0" title="0">{
        query := r.db.Model(&amp;models.Project{}).Where("organization_id = ? AND name = ?", orgID, name)
        if excludeID != nil </span><span class="cov0" title="0">{
                query = query.Where("id != ?", *excludeID)
        }</span>

        <span class="cov0" title="0">var count int64
        err := query.Count(&amp;count).Error
        return count &gt; 0, err</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package repository

import (
        "developer-portal-backend/internal/database/models"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

// TeamRepository handles database operations for teams
type TeamRepository struct {
        db *gorm.DB
}

// NewTeamRepository creates a new team repository
func NewTeamRepository(db *gorm.DB) *TeamRepository <span class="cov1" title="1">{
        return &amp;TeamRepository{db: db}
}</span>

// Create creates a new team
func (r *TeamRepository) Create(team *models.Team) error <span class="cov10" title="18">{
        return r.db.Create(team).Error
}</span>

// GetByID retrieves a team by ID
func (r *TeamRepository) GetByID(id uuid.UUID) (*models.Team, error) <span class="cov5" title="4">{
        var team models.Team
        err := r.db.First(&amp;team, "id = ?", id).Error
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>
        <span class="cov3" title="2">return &amp;team, nil</span>
}

// GetByName retrieves a team by name within a group
func (r *TeamRepository) GetByName(groupID uuid.UUID, name string) (*models.Team, error) <span class="cov3" title="2">{
        var team models.Team
        err := r.db.First(&amp;team, "group_id = ? AND name = ?", groupID, name).Error
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return &amp;team, nil</span>
}

// GetByNameGlobal retrieves a team by name across all groups/organizations (first match)
func (r *TeamRepository) GetByNameGlobal(name string) (*models.Team, error) <span class="cov0" title="0">{
        var team models.Team
        err := r.db.First(&amp;team, "name = ?", name).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;team, nil</span>
}

// GetByGroupID retrieves all teams for a group with pagination
func (r *TeamRepository) GetByGroupID(groupID uuid.UUID, limit, offset int) ([]models.Team, int64, error) <span class="cov0" title="0">{
        var teams []models.Team
        var total int64

        // Get total count
        if err := r.db.Model(&amp;models.Team{}).Where("group_id = ?", groupID).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get paginated results
        <span class="cov0" title="0">err := r.db.Where("group_id = ?", groupID).Limit(limit).Offset(offset).Find(&amp;teams).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return teams, total, nil</span>
}

// GetByOrganizationID retrieves all teams for an organization (through groups) with pagination
func (r *TeamRepository) GetByOrganizationID(orgID uuid.UUID, limit, offset int) ([]models.Team, int64, error) <span class="cov5" title="4">{
        var teams []models.Team
        var total int64

        // Get total count - join with groups to filter by organization
        if err := r.db.Model(&amp;models.Team{}).
                Joins("JOIN groups ON teams.group_id = groups.id").
                Where("groups.org_id = ?", orgID).
                Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get paginated results
        <span class="cov5" title="4">err := r.db.
                Joins("JOIN groups ON teams.group_id = groups.id").
                Where("groups.org_id = ?", orgID).
                Limit(limit).Offset(offset).
                Find(&amp;teams).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov5" title="4">return teams, total, nil</span>
}

// Update updates a team
func (r *TeamRepository) Update(team *models.Team) error <span class="cov1" title="1">{
        return r.db.Save(team).Error
}</span>

// Delete deletes a team
func (r *TeamRepository) Delete(id uuid.UUID) error <span class="cov3" title="2">{
        return r.db.Delete(&amp;models.Team{}, "id = ?", id).Error
}</span>

// GetWithGroup retrieves a team with group details (and organization through group)
func (r *TeamRepository) GetWithGroup(id uuid.UUID) (*models.Team, error) <span class="cov0" title="0">{
        var team models.Team
        err := r.db.Preload("Group").Preload("Group.Organization").First(&amp;team, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;team, nil</span>
}

// GetWithOrganization retrieves a team with organization details (legacy method)
func (r *TeamRepository) GetWithOrganization(id uuid.UUID) (*models.Team, error) <span class="cov0" title="0">{
        return r.GetWithGroup(id)
}</span>

// GetWithMembers retrieves a team with all its members
func (r *TeamRepository) GetWithMembers(id uuid.UUID) (*models.Team, error) <span class="cov0" title="0">{
        var team models.Team
        err := r.db.Preload("Users").First(&amp;team, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;team, nil</span>
}

// GetWithComponentOwnerships retrieves a team with component ownerships
func (r *TeamRepository) GetWithComponentOwnerships(id uuid.UUID) (*models.Team, error) <span class="cov0" title="0">{
        var team models.Team
        err := r.db.Preload("TeamComponentOwnerships").Preload("TeamComponentOwnerships.Component").First(&amp;team, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;team, nil</span>
}

// GetWithDutySchedules retrieves a team with duty schedules
func (r *TeamRepository) GetWithDutySchedules(id uuid.UUID) (*models.Team, error) <span class="cov0" title="0">{
        var team models.Team
        err := r.db.Preload("DutySchedules").First(&amp;team, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;team, nil</span>
}

// GetWithProjects retrieves a team with their projects through component ownership
func (r *TeamRepository) GetWithProjects(id uuid.UUID) (*models.Team, error) <span class="cov0" title="0">{
        var team models.Team
        err := r.db.Preload("TeamComponentOwnerships").
                Preload("TeamComponentOwnerships.Component").
                Preload("TeamComponentOwnerships.Component.ProjectComponents").
                First(&amp;team, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;team, nil</span>
}

// Search searches for teams by name or description within an organization (through groups)
func (r *TeamRepository) Search(orgID uuid.UUID, query string, limit, offset int) ([]models.Team, int64, error) <span class="cov0" title="0">{
        var teams []models.Team
        var total int64

        searchQuery := r.db.Model(&amp;models.Team{}).
                Joins("JOIN groups ON teams.group_id = groups.id").
                Where("groups.org_id = ? AND (teams.name ILIKE ? OR teams.description ILIKE ?)", orgID, "%"+query+"%", "%"+query+"%")

        // Get total count
        if err := searchQuery.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get paginated results
        <span class="cov0" title="0">err := searchQuery.Limit(limit).Offset(offset).Find(&amp;teams).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return teams, total, nil</span>
}

// GetMemberCount returns the number of members in a team
func (r *TeamRepository) GetMemberCount(teamID uuid.UUID) (int64, error) <span class="cov0" title="0">{
        var count int64
        err := r.db.Model(&amp;models.User{}).Where("team_id = ?", teamID).Count(&amp;count).Error
        return count, err
}</span>

// GetAll retrieves all teams across all organizations
func (r *TeamRepository) GetAll() ([]models.Team, error) <span class="cov0" title="0">{
        var teams []models.Team
        err := r.db.Find(&amp;teams).Error
        return teams, err
}</span>

// GetTeamsWithMemberCount retrieves teams with their member counts for an organization (through groups)
func (r *TeamRepository) GetTeamsWithMemberCount(orgID uuid.UUID, limit, offset int) ([]map[string]interface{}, int64, error) <span class="cov0" title="0">{
        var teams []models.Team
        var total int64
        var results []map[string]interface{}

        // Get total count
        if err := r.db.Model(&amp;models.Team{}).
                Joins("JOIN groups ON teams.group_id = groups.id").
                Where("groups.org_id = ?", orgID).
                Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get teams with member counts
        <span class="cov0" title="0">err := r.db.Raw(`
                SELECT t.*, COUNT(m.id) as member_count
                FROM teams t
                JOIN groups g ON t.group_id = g.id
                LEFT JOIN members m ON t.id = m.team_id
                WHERE g.org_id = ?
                GROUP BY t.id, g.id
                LIMIT ? OFFSET ?
        `, orgID, limit, offset).Scan(&amp;teams).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Convert to map format for easier JSON handling
        <span class="cov0" title="0">for _, team := range teams </span><span class="cov0" title="0">{
                teamMap := map[string]interface{}{
                        "id":          team.ID,
                        "name":        team.Name,
                        "title":       team.Title,
                        "description": team.Description,
                        "group_id":    team.GroupID,
                        "owner":       team.Owner,
                        "email":       team.Email,
                        "picture_url": team.PictureURL,
                        "created_at":  team.CreatedAt,
                        "updated_at":  team.UpdatedAt,
                }
                results = append(results, teamMap)
        }</span>

        <span class="cov0" title="0">return results, total, nil</span>
}

// CheckTeamExists checks if a team exists by ID
func (r *TeamRepository) CheckTeamExists(id uuid.UUID) (bool, error) <span class="cov0" title="0">{
        var count int64
        err := r.db.Model(&amp;models.Team{}).Where("id = ?", id).Count(&amp;count).Error
        return count &gt; 0, err
}</span>

// CheckTeamNameExists checks if a team name exists within an organization (through groups)
func (r *TeamRepository) CheckTeamNameExists(orgID uuid.UUID, name string, excludeID *uuid.UUID) (bool, error) <span class="cov0" title="0">{
        query := r.db.Model(&amp;models.Team{}).
                Joins("JOIN groups ON teams.group_id = groups.id").
                Where("groups.organization_id = ? AND teams.name = ?", orgID, name)
        if excludeID != nil </span><span class="cov0" title="0">{
                query = query.Where("teams.id != ?", *excludeID)
        }</span>

        <span class="cov0" title="0">var count int64
        err := query.Count(&amp;count).Error
        return count &gt; 0, err</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package repository

import (
        "developer-portal-backend/internal/auth"
        "developer-portal-backend/internal/database/models"
        "errors"
        "time"

        "github.com/google/uuid"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

// TokenRepository handles database operations for provider access tokens (refresh/session tokens)
type TokenRepository struct {
        db *gorm.DB
}

// NewTokenRepository creates a new token repository
func NewTokenRepository(db *gorm.DB) *TokenRepository <span class="cov1" title="1">{
        return &amp;TokenRepository{db: db}
}</span>

// UpsertToken creates or updates a token record for a given user and provider.
// Implemented as a single-statement UPSERT to avoid race conditions.
func (r *TokenRepository) UpsertToken(userUUID uuid.UUID, provider string, token string, expiresAt time.Time) error <span class="cov6" title="2">{
        encTok, err := auth.EncryptToken(token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="2">tok := &amp;models.Token{
                UserUUID:  userUUID,
                Provider:  provider,
                Token:     encTok,
                ExpiresAt: expiresAt,
        }
        return r.db.Clauses(clause.OnConflict{
                Columns:   []clause.Column{{Name: "user_uuid"}, {Name: "provider"}},
                DoUpdates: clause.Assignments(map[string]interface{}{"token": tok.Token, "expires_at": tok.ExpiresAt}),
        }).Create(tok).Error</span>
}

// GetValidToken returns a non-expired token for the given user and provider.
func (r *TokenRepository) GetValidToken(userUUID uuid.UUID, provider string) (*models.Token, error) <span class="cov10" title="3">{
        var tok models.Token
        if err := r.db.Where("user_uuid = ? AND provider = ? AND expires_at &gt; ?", userUUID, provider, time.Now()).
                First(&amp;tok).Error; err != nil </span><span class="cov1" title="1">{
                // Mitigate timing side-channel by performing a dummy decrypt attempt even when record is not found
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        if dummy, encErr := auth.EncryptToken("dummy"); encErr == nil </span><span class="cov1" title="1">{
                                _, _ = auth.DecryptToken(dummy)
                        }</span>
                }
                <span class="cov1" title="1">return nil, err</span>
        }
        // Decrypt token before returning; tokens must be stored encrypted
        <span class="cov6" title="2">plain, decErr := auth.DecryptToken(tok.Token)
        if decErr != nil </span><span class="cov1" title="1">{
                // Perform dummy encrypt+decrypt to reduce timing side-channel differences
                if dummy, encErr := auth.EncryptToken("dummy"); encErr == nil </span><span class="cov1" title="1">{
                        _, _ = auth.DecryptToken(dummy)
                }</span>
                <span class="cov1" title="1">return nil, decErr</span>
        }
        // Perform dummy encrypt+decrypt to reduce timing side-channel differences
        <span class="cov1" title="1">if dummy, encErr := auth.EncryptToken("dummy"); encErr == nil </span><span class="cov1" title="1">{
                _, _ = auth.DecryptToken(dummy)
        }</span>
        <span class="cov1" title="1">tok.Token = plain
        return &amp;tok, nil</span>
}

// DeleteToken removes a token record for the given user and provider.
func (r *TokenRepository) DeleteToken(userUUID uuid.UUID, provider string) error <span class="cov1" title="1">{
        return r.db.Where("user_uuid = ? AND provider = ?", userUUID, provider).
                Delete(&amp;models.Token{}).Error
}</span>

// CleanupExpiredTokens deletes all expired tokens from the table.
func (r *TokenRepository) CleanupExpiredTokens() error <span class="cov1" title="1">{
        return r.db.Where("expires_at &lt;= ?", time.Now()).
                Delete(&amp;models.Token{}).Error
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package repository

import (
        "developer-portal-backend/internal/database/models"
        "strings"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

// UserRepository handles database operations for members
type UserRepository struct {
        db *gorm.DB
}

// NewUserRepository creates a new member repository
func NewUserRepository(db *gorm.DB) *UserRepository <span class="cov1" title="1">{
        return &amp;UserRepository{db: db}
}</span>

// Create creates a new member
func (r *UserRepository) Create(member *models.User) error <span class="cov10" title="2">{
        return r.db.Create(member).Error
}</span>

// GetByID retrieves a member by ID
func (r *UserRepository) GetByID(id uuid.UUID) (*models.User, error) <span class="cov0" title="0">{
        var member models.User
        err := r.db.First(&amp;member, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;member, nil</span>
}

// GetByEmail retrieves a member by email
func (r *UserRepository) GetByEmail(email string) (*models.User, error) <span class="cov0" title="0">{
        var member models.User
        err := r.db.First(&amp;member, "email = ?", email).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;member, nil</span>
}

// GetByName retrieves a member by BaseModel.Name column
func (r *UserRepository) GetByName(name string) (*models.User, error) <span class="cov0" title="0">{
        var member models.User
        err := r.db.First(&amp;member, "name = ?", name).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;member, nil</span>
}

 // GetByUserID retrieves a member by their string UserID (e.g., I123456)
func (r *UserRepository) GetByUserID(userID string) (*models.User, error) <span class="cov0" title="0">{
        var member models.User
        err := r.db.First(&amp;member, "user_id = ?", userID).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;member, nil</span>
}

// GetAll retrieves all users with pagination
func (r *UserRepository) GetAll(limit, offset int) ([]models.User, int64, error) <span class="cov0" title="0">{
        var members []models.User
        var total int64

        // Get total count
        if err := r.db.Model(&amp;models.User{}).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get paginated results
        <span class="cov0" title="0">if err := r.db.Model(&amp;models.User{}).Limit(limit).Offset(offset).Find(&amp;members).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return members, total, nil</span>
}

// GetByOrganizationID retrieves all members for an organization with pagination
func (r *UserRepository) GetByOrganizationID(orgID uuid.UUID, limit, offset int) ([]models.User, int64, error) <span class="cov0" title="0">{
        var members []models.User
        var total int64

        // Users no longer carry organization_id directly; filter by organization through team -&gt; group
        countQuery := r.db.Model(&amp;models.User{}).
                Joins("JOIN teams ON members.team_id = teams.id").
                Joins("JOIN groups ON teams.group_id = groups.id").
                Where("groups.org_id = ?", orgID)

        if err := countQuery.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get paginated results
        <span class="cov0" title="0">err := r.db.Model(&amp;models.User{}).
                Joins("JOIN teams ON members.team_id = teams.id").
                Joins("JOIN groups ON teams.group_id = groups.id").
                Where("groups.org_id = ?", orgID).
                Limit(limit).Offset(offset).
                Find(&amp;members).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return members, total, nil</span>
}

// GetByTeamID retrieves all members for a team with pagination
func (r *UserRepository) GetByTeamID(teamID uuid.UUID, limit, offset int) ([]models.User, int64, error) <span class="cov0" title="0">{
        var members []models.User
        var total int64

        // Get total count
        if err := r.db.Model(&amp;models.User{}).Where("team_id = ?", teamID).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get paginated results
        <span class="cov0" title="0">err := r.db.Where("team_id = ?", teamID).Limit(limit).Offset(offset).Find(&amp;members).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return members, total, nil</span>
}

// GetByRole retrieves all members with a specific role in an organization
func (r *UserRepository) GetByRole(orgID uuid.UUID, role models.TeamDomain, limit, offset int) ([]models.User, int64, error) <span class="cov0" title="0">{
        var members []models.User
        var total int64

        query := r.db.Model(&amp;models.User{}).
                Joins("JOIN teams ON members.team_id = teams.id").
                Joins("JOIN groups ON teams.group_id = groups.id").
                Where("groups.org_id = ? AND members.team_domain = ?", orgID, role)

        // Get total count
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get paginated results
        <span class="cov0" title="0">err := query.Limit(limit).Offset(offset).Find(&amp;members).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return members, total, nil</span>
}

// GetActiveMembers retrieves all active members for an organization
func (r *UserRepository) GetActiveMembers(orgID uuid.UUID, limit, offset int) ([]models.User, int64, error) <span class="cov0" title="0">{
        // Model no longer has an 'is_active' field; return all members for org via team-&gt;group join
        return r.GetByOrganizationID(orgID, limit, offset)
}</span>

// Update updates a member
func (r *UserRepository) Update(member *models.User) error <span class="cov0" title="0">{
        return r.db.Save(member).Error
}</span>

// Delete deletes a member
func (r *UserRepository) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.Delete(&amp;models.User{}, "id = ?", id).Error
}</span>

// GetWithOrganization retrieves a member with organization details
func (r *UserRepository) GetWithOrganization(id uuid.UUID) (*models.User, error) <span class="cov0" title="0">{
        var member models.User
        err := r.db.Preload("Organization").First(&amp;member, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;member, nil</span>
}

// GetWithTeam retrieves a member with team details
func (r *UserRepository) GetWithTeam(id uuid.UUID) (*models.User, error) <span class="cov0" title="0">{
        var member models.User
        err := r.db.Preload("Team").First(&amp;member, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;member, nil</span>
}

// GetWithLeadingTeams retrieves a member with teams they lead
func (r *UserRepository) GetWithLeadingTeams(id uuid.UUID) (*models.User, error) <span class="cov0" title="0">{
        var member models.User
        err := r.db.Preload("LeadingTeams").First(&amp;member, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;member, nil</span>
}

// GetWithDutySchedules retrieves a member with their duty schedules
func (r *UserRepository) GetWithDutySchedules(id uuid.UUID) (*models.User, error) <span class="cov0" title="0">{
        var member models.User
        err := r.db.Preload("DutySchedules").First(&amp;member, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;member, nil</span>
}

// AssignToTeam assigns a member to a team
func (r *UserRepository) AssignToTeam(memberID, teamID uuid.UUID) error <span class="cov0" title="0">{
        return r.db.Model(&amp;models.User{}).Where("id = ?", memberID).Update("team_id", teamID).Error
}</span>

// RemoveFromTeam removes a member from their team
func (r *UserRepository) RemoveFromTeam(memberID uuid.UUID) error <span class="cov0" title="0">{
        return r.db.Model(&amp;models.User{}).Where("id = ?", memberID).Update("team_id", nil).Error
}</span>

// UpdateRole updates a member's role
func (r *UserRepository) UpdateRole(memberID uuid.UUID, role models.TeamDomain) error <span class="cov0" title="0">{
        return r.db.Model(&amp;models.User{}).Where("id = ?", memberID).Update("team_domain", role).Error
}</span>

// SetActiveStatus sets the active status of a member
func (r *UserRepository) SetActiveStatus(memberID uuid.UUID, isActive bool) error <span class="cov0" title="0">{
        // Model no longer has 'is_active'; treat as no-op for backward compatibility
        return nil
}</span>

// Search searches for members by name or email
func (r *UserRepository) Search(orgID uuid.UUID, query string, limit, offset int) ([]models.User, int64, error) <span class="cov0" title="0">{
        var members []models.User
        var total int64

        searchQuery := r.db.Model(&amp;models.User{}).
                Joins("JOIN teams ON members.team_id = teams.id").
                Joins("JOIN groups ON teams.group_id = groups.id").
                Where("groups.org_id = ? AND (members.first_name ILIKE ? OR members.last_name ILIKE ? OR members.email ILIKE ?)", orgID, "%"+query+"%", "%"+query+"%", "%"+query+"%")

        // Get total count
        if err := searchQuery.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get paginated results
        <span class="cov0" title="0">err := searchQuery.Limit(limit).Offset(offset).Find(&amp;members).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return members, total, nil</span>
}

// SearchByOrganization searches for members by name or email within an organization
func (r *UserRepository) SearchByOrganization(orgID uuid.UUID, query string, limit, offset int) ([]models.User, int64, error) <span class="cov0" title="0">{
        return r.Search(orgID, query, limit, offset)
}</span>

 // GetActiveByOrganization retrieves all active members for an organization
func (r *UserRepository) GetActiveByOrganization(orgID uuid.UUID, limit, offset int) ([]models.User, int64, error) <span class="cov0" title="0">{
        return r.GetByOrganizationID(orgID, limit, offset)
}</span>

 // GetUserIDsByPrefix returns user_ids with the given prefix (case-insensitive)
func (r *UserRepository) GetUserIDsByPrefix(prefix string) ([]string, error) <span class="cov0" title="0">{
        var ids []string
        if err := r.db.Model(&amp;models.User{}).
                Where("user_id ILIKE ?", prefix+"%").
                Pluck("user_id", &amp;ids).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ids, nil</span>
}

// GetExistingUserIDs returns the subset of provided user_ids that already exist
func (r *UserRepository) GetExistingUserIDs(ids []string) ([]string, error) <span class="cov0" title="0">{
        if len(ids) == 0 </span><span class="cov0" title="0">{
                return []string{}, nil
        }</span>
        <span class="cov0" title="0">var existing []string
        if err := r.db.Model(&amp;models.User{}).
                Where("user_id IN ?", ids).
                Pluck("user_id", &amp;existing).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return existing, nil</span>
}

// SearchByNameOrTitleGlobal performs a case-insensitive search across users by BaseModel.Name or BaseModel.Title
func (r *UserRepository) SearchByNameOrTitleGlobal(query string, limit, offset int) ([]models.User, int64, error) <span class="cov0" title="0">{
        var members []models.User
        var total int64

        q := strings.TrimSpace(query)
        if q == "" </span><span class="cov0" title="0">{
                // When query is empty, behave like GetAll
                if err := r.db.Model(&amp;models.User{}).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov0" title="0">if err := r.db.Model(&amp;models.User{}).Limit(limit).Offset(offset).Find(&amp;members).Error; err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov0" title="0">return members, total, nil</span>
        }

        <span class="cov0" title="0">searchQuery := r.db.Model(&amp;models.User{}).
                Where("name ILIKE ? OR title ILIKE ?", "%"+q+"%", "%"+q+"%")

        // Get total count
        if err := searchQuery.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get paginated results
        <span class="cov0" title="0">if err := searchQuery.Limit(limit).Offset(offset).Find(&amp;members).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return members, total, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package service

import (
        "bytes"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "io"
        "mime/multipart"
        "net/http"
        "net/url"
        "os"
        "strconv"
        "strings"
        "sync"
        "time"

        "developer-portal-backend/internal/auth"
        "developer-portal-backend/internal/database/models"
        "developer-portal-backend/internal/errors"
        "developer-portal-backend/internal/logger"
        "developer-portal-backend/internal/repository"

        "github.com/gin-gonic/gin"
)

// AICoreCredentials represents the credentials for a specific team
type AICoreCredentials struct {
        Team          string `json:"team"`
        ClientID      string `json:"clientId"`
        ClientSecret  string `json:"clientSecret"`
        OAuthURL      string `json:"oauthUrl"`
        APIURL        string `json:"apiUrl"`
        ResourceGroup string `json:"resourceGroup"`
}

// AICoreTokenResponse represents the OAuth token response
type AICoreTokenResponse struct {
        AccessToken string `json:"access_token"`
        TokenType   string `json:"token_type"`
        ExpiresIn   int    `json:"expires_in"`
}

// tokenCache represents a cached access token with expiration
type tokenCache struct {
        token     string
        expiresAt time.Time
}

// AICoreDeployment represents a deployment from AI Core
type AICoreDeployment struct {
        ID                string                 `json:"id"`
        ConfigurationID   string                 `json:"configurationId"`
        ConfigurationName string                 `json:"configurationName"`
        ScenarioID        string                 `json:"scenarioId"`
        Status            string                 `json:"status"`
        StatusMessage     string                 `json:"statusMessage"`
        TargetStatus      string                 `json:"targetStatus"`
        DeploymentURL     string                 `json:"deploymentUrl"`
        CreatedAt         string                 `json:"createdAt"`
        ModifiedAt        string                 `json:"modifiedAt"`
        Details           map[string]interface{} `json:"details,omitempty"`
}

// AICoreTeamDeployments represents deployments for a specific team
type AICoreTeamDeployments struct {
        Team        string             `json:"team"`
        Deployments []AICoreDeployment `json:"deployments"`
}

// AICoreDeploymentsResponse represents the response from AI Core deployments API
type AICoreDeploymentsResponse struct {
        Count       int                     `json:"count"`
        Deployments []AICoreTeamDeployments `json:"deployments"`
}

// AICoreModel represents a model from AI Core
type AICoreModel struct {
        Model        string                   `json:"model"`
        ExecutableID string                   `json:"executableId"`
        Description  string                   `json:"description"`
        DisplayName  string                   `json:"displayName,omitempty"`
        AccessType   string                   `json:"accessType,omitempty"`
        Provider     string                   `json:"provider,omitempty"`
        Versions     []AICoreModelVersion     `json:"versions"`
        Scenarios    []map[string]interface{} `json:"allowedScenarios,omitempty"`
}

// AICoreModelVersion represents a model version
type AICoreModelVersion struct {
        Name                      string                   `json:"name"`
        IsLatest                  bool                     `json:"isLatest"`
        Deprecated                bool                     `json:"deprecated"`
        RetirementDate            string                   `json:"retirementDate,omitempty"`
        ContextLength             int                      `json:"contextLength,omitempty"`
        InputTypes                []string                 `json:"inputTypes,omitempty"`
        Capabilities              []string                 `json:"capabilities,omitempty"`
        Metadata                  []map[string]interface{} `json:"metadata,omitempty"`
        Cost                      []map[string]interface{} `json:"cost,omitempty"`
        SuggestedReplacements     []string                 `json:"suggestedReplacements,omitempty"`
        StreamingSupported        bool                     `json:"streamingSupported,omitempty"`
        OrchestrationCapabilities []string                 `json:"orchestrationCapabilities,omitempty"`
}

// AICoreModelsResponse represents the response from AI Core models API
type AICoreModelsResponse struct {
        Count     int           `json:"count"`
        Resources []AICoreModel `json:"resources"`
}

// AICoreConfigurationsResponse represents the response from AI Core configurations API
type AICoreConfigurationsResponse struct {
        Count     int                   `json:"count"`
        Resources []AICoreConfiguration `json:"resources"`
}

// AICoreMeResponse represents the response for /ai-core/me
type AICoreMeResponse struct {
        User        string   `json:"user"`
        AIInstances []string `json:"ai_instances"`
}

// AICoreConfiguration represents a configuration from AI Core
type AICoreConfiguration struct {
        ID                    string                 `json:"id"`
        Name                  string                 `json:"name"`
        ExecutableID          string                 `json:"executableId"`
        ScenarioID            string                 `json:"scenarioId"`
        ParameterBindings     []map[string]string    `json:"parameterBindings,omitempty"`
        InputArtifactBindings []map[string]string    `json:"inputArtifactBindings,omitempty"`
        CreatedAt             string                 `json:"createdAt"`
        Scenario              map[string]interface{} `json:"scenario,omitempty"`
}

// AICoreConfigurationRequest represents a request to create a configuration
type AICoreConfigurationRequest struct {
        Name                  string              `json:"name" validate:"required"`
        ExecutableID          string              `json:"executableId" validate:"required"`
        ScenarioID            string              `json:"scenarioId" validate:"required"`
        ParameterBindings     []map[string]string `json:"parameterBindings,omitempty"` // model name and model version
        InputArtifactBindings []map[string]string `json:"inputArtifactBindings,omitempty"`
}

// AICoreConfigurationResponse represents the response from creating a configuration
type AICoreConfigurationResponse struct {
        ID      string `json:"id"`
        Message string `json:"message"`
}

// AICoreDeploymentRequest represents a request to create a deployment
// Either ConfigurationID or ConfigurationRequest must be provided
type AICoreDeploymentRequest struct {
        ConfigurationID      *string                     `json:"configurationId,omitempty"`
        ConfigurationRequest *AICoreConfigurationRequest `json:"configurationRequest,omitempty"`
        TTL                  string                      `json:"ttl,omitempty"`
}

// AICoreDeploymentResponse represents the response from creating a deployment
type AICoreDeploymentResponse struct {
        ID            string `json:"id"`
        Message       string `json:"message"`
        DeploymentURL string `json:"deploymentUrl,omitempty"`
        Status        string `json:"status,omitempty"`
        TTL           string `json:"ttl,omitempty"`
}

// AICoreDeploymentModificationRequest represents a request to modify a deployment
type AICoreDeploymentModificationRequest struct {
        TargetStatus    string `json:"targetStatus,omitempty"`
        ConfigurationID string `json:"configurationId,omitempty"`
}

// AICoreDeploymentModificationResponse represents the response from modifying a deployment
type AICoreDeploymentModificationResponse struct {
        ID            string `json:"id"`
        Message       string `json:"message"`
        DeploymentURL string `json:"deploymentUrl,omitempty"`
        Status        string `json:"status,omitempty"`
        TargetStatus  string `json:"targetStatus,omitempty"`
}

// AICoreDeploymentDeletionResponse represents the response from deleting a deployment
type AICoreDeploymentDeletionResponse struct {
        ID      string `json:"id"`
        Message string `json:"message"`
}

// AICoreDeploymentDetailsResponse represents the detailed response for a specific deployment
type AICoreDeploymentDetailsResponse struct {
        ID                           string                 `json:"id"`
        DeploymentURL                string                 `json:"deploymentUrl"`
        ConfigurationID              string                 `json:"configurationId"`
        ConfigurationName            string                 `json:"configurationName"`
        ExecutableID                 string                 `json:"executableId"`
        ScenarioID                   string                 `json:"scenarioId"`
        Status                       string                 `json:"status"`
        StatusMessage                string                 `json:"statusMessage"`
        TargetStatus                 string                 `json:"targetStatus"`
        LastOperation                string                 `json:"lastOperation"`
        LatestRunningConfigurationID string                 `json:"latestRunningConfigurationId"`
        TTL                          string                 `json:"ttl"`
        Details                      map[string]interface{} `json:"details"`
        CreatedAt                    string                 `json:"createdAt"`
        ModifiedAt                   string                 `json:"modifiedAt"`
        SubmissionTime               string                 `json:"submissionTime"`
        StartTime                    string                 `json:"startTime"`
        CompletionTime               string                 `json:"completionTime"`
        StatusDetails                map[string]interface{} `json:"statusDetails"`
}

// AICoreService handles AI Core operations
type AICoreService struct {
        userRepo        repository.UserRepositoryInterface
        teamRepo        repository.TeamRepositoryInterface
        groupRepo       repository.GroupRepositoryInterface
        orgRepo         repository.OrganizationRepositoryInterface
        httpClient      *http.Client
        credentials     map[string]*AICoreCredentials // Cached credentials by team name
        credentialsMux  sync.RWMutex                  // Protects credentials cache
        tokenCache      map[string]*tokenCache        // Cached tokens by team name
        tokenCacheMux   sync.RWMutex                  // Protects token cache
        credentialsOnce sync.Once                     // Ensures credentials are loaded only once
}

/* NewAICoreService creates a new AI Core service */
func NewAICoreService(userRepo repository.UserRepositoryInterface, teamRepo repository.TeamRepositoryInterface, groupRepo repository.GroupRepositoryInterface, orgRepo repository.OrganizationRepositoryInterface) AICoreServiceInterface <span class="cov9" title="73">{
        return &amp;AICoreService{
                userRepo:    userRepo,
                teamRepo:    teamRepo,
                groupRepo:   groupRepo,
                orgRepo:     orgRepo,
                credentials: make(map[string]*AICoreCredentials),
                tokenCache:  make(map[string]*tokenCache),
                httpClient: &amp;http.Client{
                        Timeout: 120 * time.Second, // Increased timeout for AI inference requests (LLMs can take 30-60s)
                },
        }
}</span>

// SetHTTPClient sets a custom HTTP client (useful for testing with shorter timeouts)
func (s *AICoreService) SetHTTPClient(client *http.Client) <span class="cov8" title="57">{
        s.httpClient = client
}</span>

// getTeamLimit returns the configurable team limit from environment variable or default
func (s *AICoreService) getTeamLimit() int <span class="cov4" title="6">{
        limitStr := os.Getenv("AI_CORE_TEAM_LIMIT")
        if limitStr == "" </span><span class="cov4" title="6">{
                return 1000 // Default limit
        }</span>

        <span class="cov0" title="0">limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt;= 0 </span><span class="cov0" title="0">{
                return 1000 // Default limit if invalid
        }</span>

        <span class="cov0" title="0">return limit</span>
}

// loadCredentials loads and caches all AI Core credentials from environment variable
func (s *AICoreService) loadCredentials() error <span class="cov8" title="58">{
        credentialsJSON := os.Getenv("AI_CORE_CREDENTIALS")
        if credentialsJSON == "" </span><span class="cov2" title="2">{
                return errors.ErrAICoreCredentialsNotSet
        }</span>

        <span class="cov8" title="56">var credentialsList []AICoreCredentials
        if err := json.Unmarshal([]byte(credentialsJSON), &amp;credentialsList); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %v", errors.ErrAICoreCredentialsInvalid, err)
        }</span>

        <span class="cov8" title="56">s.credentialsMux.Lock()
        defer s.credentialsMux.Unlock()

        // Clear existing credentials and rebuild cache
        s.credentials = make(map[string]*AICoreCredentials)
        for i := range credentialsList </span><span class="cov9" title="74">{
                cred := &amp;credentialsList[i]
                s.credentials[cred.Team] = cred
        }</span>

        <span class="cov8" title="56">return nil</span>
}

// getCredentialsForTeam retrieves AI Core credentials for a specific team from cache
func (s *AICoreService) getCredentialsForTeam(teamName string) (*AICoreCredentials, error) <span class="cov9" title="77">{
        // Load credentials once
        var loadErr error
        s.credentialsOnce.Do(func() </span><span class="cov8" title="50">{
                loadErr = s.loadCredentials()
        }</span>)
        <span class="cov9" title="77">if loadErr != nil </span><span class="cov1" title="1">{
                return nil, loadErr
        }</span>

        <span class="cov9" title="76">s.credentialsMux.RLock()
        defer s.credentialsMux.RUnlock()

        cred, exists := s.credentials[teamName]
        if !exists </span><span class="cov0" title="0">{
                return nil, errors.NewAICoreCredentialsNotFoundError(teamName)
        }</span>

        <span class="cov9" title="76">return cred, nil</span>
}

// getUserTeam retrieves the team name for the authenticated user
func (s *AICoreService) getUserTeam(c *gin.Context) (string, error) <span class="cov6" title="20">{
        // Get user email from auth context
        email, exists := auth.GetUserEmail(c)
        if !exists </span><span class="cov0" title="0">{
                logger.New().Error("AI Core: User email not found in context - authentication middleware not applied")
                return "", errors.ErrUserEmailNotFound
        }</span>

        // Build contextual logger with user email
        <span class="cov6" title="20">log := logger.New().WithField("user_email", email)

        // Get user from database
        member, err := s.userRepo.GetByEmail(email)
        if err != nil </span><span class="cov3" title="3">{
                if errors.IsNotFound(err) </span><span class="cov3" title="3">{
                        log.Error("AI Core: User not found in database")
                        return "", errors.ErrUserNotFoundInDB
                }</span>
                <span class="cov0" title="0">log.Errorf("AI Core: Failed to get user from database: %v", err)
                return "", fmt.Errorf("failed to get user from database: %w", err)</span>
        }

        // Get user's team
        <span class="cov6" title="17">if member.TeamID == nil </span><span class="cov0" title="0">{
                log.Error("AI Core: User is not assigned to any team")
                return "", errors.ErrUserNotAssignedToTeam
        }</span>

        <span class="cov6" title="17">team, err := s.teamRepo.GetByID(*member.TeamID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        log.WithField("team_id", *member.TeamID).Error("AI Core: Team not found in database")
                        return "", errors.ErrTeamNotFoundInDB
                }</span>
                <span class="cov0" title="0">log.WithField("team_id", *member.TeamID).Errorf("AI Core: Failed to get team from database: %v", err)
                return "", fmt.Errorf("failed to get team from database: %w", err)</span>
        }

        // Log team info - critical for debugging team name/credential matching
        <span class="cov6" title="17">log.WithFields(map[string]interface{}{
                "team_name":  team.Name,
                "team_id":    team.ID,
                "team_owner": team.Owner,
        }).Info("AI Core: Retrieved team for user")
        return team.Name, nil</span>
}

// getAccessToken retrieves an access token for AI Core API with caching
func (s *AICoreService) getAccessToken(credentials *AICoreCredentials) (string, error) <span class="cov9" title="76">{
        teamName := credentials.Team

        // Check cache first
        s.tokenCacheMux.RLock()
        if cached, exists := s.tokenCache[teamName]; exists </span><span class="cov6" title="20">{
                if time.Now().Before(cached.expiresAt) </span><span class="cov6" title="20">{
                        s.tokenCacheMux.RUnlock()
                        return cached.token, nil
                }</span>
        }
        <span class="cov8" title="56">s.tokenCacheMux.RUnlock()

        // Token not cached or expired, get new token
        token, expiresIn, err := s.requestNewToken(credentials)
        if err != nil </span><span class="cov2" title="2">{
                return "", err
        }</span>

        // Cache the token with a buffer (expire 5 minutes early to be safe)
        <span class="cov8" title="54">expiresAt := time.Now().Add(time.Duration(expiresIn-300) * time.Second)

        s.tokenCacheMux.Lock()
        s.tokenCache[teamName] = &amp;tokenCache{
                token:     token,
                expiresAt: expiresAt,
        }
        s.tokenCacheMux.Unlock()

        return token, nil</span>
}

// requestNewToken requests a new access token from the OAuth endpoint
func (s *AICoreService) requestNewToken(credentials *AICoreCredentials) (string, int, error) <span class="cov8" title="56">{
        // Use proper form encoding instead of string concatenation for security
        data := url.Values{}
        data.Set("grant_type", "client_credentials")
        data.Set("client_id", credentials.ClientID)
        data.Set("client_secret", credentials.ClientSecret)

        req, err := http.NewRequest("POST", credentials.OAuthURL, strings.NewReader(data.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("failed to create token request: %w", err)
        }</span>

        <span class="cov8" title="56">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov1" title="1">{
                return "", 0, fmt.Errorf("failed to get access token: %w", err)
        }</span>
        <span class="cov8" title="55">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                body, _ := io.ReadAll(resp.Body)
                return "", 0, fmt.Errorf("token request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov8" title="54">var tokenResp AICoreTokenResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;tokenResp); err != nil </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("failed to decode token response: %w", err)
        }</span>

        <span class="cov8" title="54">return tokenResp.AccessToken, tokenResp.ExpiresIn, nil</span>
}

// makeAICoreRequest makes an authenticated request to AI Core API
func (s *AICoreService) makeAICoreRequest(method, url, accessToken, resourceGroup string, body interface{}) (*http.Response, error) <span class="cov9" title="74">{
        var reqBody io.Reader
        if body != nil </span><span class="cov7" title="28">{
                jsonBody, err := json.Marshal(body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal request body: %w", err)
                }</span>
                <span class="cov7" title="28">reqBody = bytes.NewBuffer(jsonBody)</span>
        }

        <span class="cov9" title="74">req, err := http.NewRequest(method, url, reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov9" title="74">req.Header.Set("Authorization", "Bearer "+accessToken)
        req.Header.Set("Content-Type", "application/json")
        req.Header.Set("AI-Resource-Group", resourceGroup)

        return s.httpClient.Do(req)</span>
}

// GetDeployments retrieves deployments from AI Core based on user's role
func (s *AICoreService) GetDeployments(c *gin.Context) (*AICoreDeploymentsResponse, error) <span class="cov8" title="39">{
        // Get user email from auth context
        email, exists := auth.GetUserEmail(c)
        if !exists </span><span class="cov0" title="0">{
                return nil, errors.ErrUserEmailNotFound
        }</span>

        // Get user from database
        <span class="cov8" title="39">member, err := s.userRepo.GetByEmail(email)
        if err != nil </span><span class="cov3" title="3">{
                if errors.IsNotFound(err) </span><span class="cov3" title="3">{
                        return nil, errors.ErrUserNotFoundInDB
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user from database: %w", err)</span>
        }

        // Determine user role and get appropriate teams (including metadata-based teams)
        <span class="cov7" title="36">teamNames, err := s.getAllTeamsForUser(member)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        // Aggregate deployments from all teams, grouped by team
        <span class="cov7" title="34">teamDeployments := make([]AICoreTeamDeployments, 0)
        totalCount := 0

        for _, teamName := range teamNames </span><span class="cov8" title="41">{
                // Get credentials for the team
                credentials, err := s.getCredentialsForTeam(teamName)
                if err != nil </span><span class="cov1" title="1">{
                        // Skip teams without credentials instead of failing
                        continue</span>
                }

                // Get access token
                <span class="cov8" title="40">accessToken, err := s.getAccessToken(credentials)
                if err != nil </span><span class="cov2" title="2">{
                        // Skip teams with token issues instead of failing
                        continue</span>
                }

                // Make request to AI Core
                <span class="cov8" title="38">url := fmt.Sprintf("%s/v2/lm/deployments", credentials.APIURL)
                resp, err := s.makeAICoreRequest("GET", url, accessToken, credentials.ResourceGroup, nil)
                if err != nil </span><span class="cov1" title="1">{
                        // Skip teams with API issues instead of failing
                        continue</span>
                }

                // Ensure response body is always closed
                <span class="cov8" title="37">defer resp.Body.Close()

                if resp.StatusCode == http.StatusOK </span><span class="cov7" title="36">{
                        // We need to decode into a temporary structure that matches AI Core's actual response
                        var tempResp struct {
                                Count     int                `json:"count"`
                                Resources []AICoreDeployment `json:"resources"`
                        }
                        if err := json.NewDecoder(resp.Body).Decode(&amp;tempResp); err == nil </span><span class="cov7" title="36">{
                                // Create team deployment entry
                                teamDeployment := AICoreTeamDeployments{
                                        Team:        teamName,
                                        Deployments: tempResp.Resources,
                                }
                                teamDeployments = append(teamDeployments, teamDeployment)
                                totalCount += tempResp.Count
                        }</span>
                }
        }

        // Return aggregated response with new structure
        <span class="cov7" title="34">return &amp;AICoreDeploymentsResponse{
                Count:       totalCount,
                Deployments: teamDeployments,
        }, nil</span>
}

// getTeamsForUser determines which teams a user should see deployments for based on their role
func (s *AICoreService) getTeamsForUser(member *models.User) ([]string, error) <span class="cov7" title="36">{
        var teamNames []string

        // Team member or team manager - get only their team
        if member.TeamID != nil </span><span class="cov7" title="29">{
                team, err := s.teamRepo.GetByID(*member.TeamID)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                return nil, errors.ErrTeamNotFoundInDB
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("failed to get team from database: %w", err)</span>
                }
                <span class="cov7" title="29">teamNames = append(teamNames, team.Name)
                return teamNames, nil</span>
        }

        // User not assigned to any team
        <span class="cov4" title="7">return nil, errors.ErrUserNotAssignedToTeam</span>
}

// getAICoreTeamsFromMetadata extracts team names from the member's metadata.ai_instances field
func (s *AICoreService) getAICoreTeamsFromMetadata(member *models.User) []string <span class="cov7" title="36">{
        var teamNames []string

        if member.Metadata == nil </span><span class="cov7" title="30">{
                return teamNames
        }</span>

        <span class="cov4" title="6">var metadata map[string]interface{}
        if err := json.Unmarshal(member.Metadata, &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return teamNames
        }</span>

        <span class="cov4" title="6">aiInstances, exists := metadata["ai_instances"]
        if !exists </span><span class="cov0" title="0">{
                return teamNames
        }</span>

        // Handle different possible types for ai_instances
        <span class="cov4" title="6">switch v := aiInstances.(type) </span>{
        case []interface{}:<span class="cov4" title="6">
                // Array of team names
                for _, teamNameInterface := range v </span><span class="cov5" title="12">{
                        if teamName, ok := teamNameInterface.(string); ok &amp;&amp; teamName != "" </span><span class="cov5" title="12">{
                                teamNames = append(teamNames, teamName)
                        }</span>
                }
        case []string:<span class="cov0" title="0">
                // Array of strings (direct type)
                for _, teamName := range v </span><span class="cov0" title="0">{
                        if teamName != "" </span><span class="cov0" title="0">{
                                teamNames = append(teamNames, teamName)
                        }</span>
                }
        case string:<span class="cov0" title="0">
                // Single team name as string
                if v != "" </span><span class="cov0" title="0">{
                        teamNames = append(teamNames, v)
                }</span>
        }

        <span class="cov4" title="6">return teamNames</span>
}

// getAllTeamsForUser combines teams from role-based access and metadata-based access
func (s *AICoreService) getAllTeamsForUser(member *models.User) ([]string, error) <span class="cov7" title="36">{
        teamNamesSet := make(map[string]bool) // Use a set to avoid duplicates
        var allTeamNames []string

        // Get teams based on role and team assignment
        roleBasedTeams, err := s.getTeamsForUser(member)
        if err != nil &amp;&amp; err != errors.ErrUserNotAssignedToTeam </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Add role-based teams to the set
        <span class="cov7" title="36">for _, teamName := range roleBasedTeams </span><span class="cov7" title="29">{
                if !teamNamesSet[teamName] </span><span class="cov7" title="29">{
                        allTeamNames = append(allTeamNames, teamName)
                        teamNamesSet[teamName] = true
                }</span>
        }

        // Get additional teams from metadata
        <span class="cov7" title="36">metadataTeams := s.getAICoreTeamsFromMetadata(member)
        for _, teamName := range metadataTeams </span><span class="cov5" title="12">{
                if !teamNamesSet[teamName] </span><span class="cov5" title="12">{
                        allTeamNames = append(allTeamNames, teamName)
                        teamNamesSet[teamName] = true
                }</span>
        }

        // If no teams found at all, return error
        <span class="cov7" title="36">if len(allTeamNames) == 0 </span><span class="cov2" title="2">{
                return nil, errors.ErrUserNotAssignedToTeam
        }</span>

        <span class="cov7" title="34">return allTeamNames, nil</span>
}

// GetMe resolves AI instances for the authenticated user based on role and metadata
func (s *AICoreService) GetMe(c *gin.Context) (*AICoreMeResponse, error) <span class="cov5" title="10">{
        // Get username from auth context
        username, exists := auth.GetUsername(c)
        if !exists || username == "" </span><span class="cov1" title="1">{
                return nil, errors.ErrUserEmailNotFound
        }</span>

        // Look up user by name (maps to 'name' column in users table via BaseModel)
        <span class="cov5" title="9">member, err := s.userRepo.GetByName(username)
        if err != nil </span><span class="cov1" title="1">{
                if errors.IsNotFound(err) </span><span class="cov1" title="1">{
                        return nil, errors.ErrUserNotFoundInDB
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user by name: %w", err)</span>
        }

        // Prepare ai_instances with optional initialization from metadata.ai_instances
        <span class="cov5" title="8">aiInstances := make([]string, 0)
        seen := make(map[string]bool)

        add := func(name string) </span><span class="cov6" title="21">{
                if name == "" </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov6" title="21">if !seen[name] </span><span class="cov6" title="19">{
                        aiInstances = append(aiInstances, name)
                        seen[name] = true
                }</span>
        }

        // Prepare metadata instances (will be added after filtering)
        <span class="cov5" title="8">metaInstances := make([]string, 0)
        // Merge from metadata.ai_instances if present
        if member.Metadata != nil </span><span class="cov3" title="3">{
                var metadata map[string]interface{}
                if err := json.Unmarshal(member.Metadata, &amp;metadata); err == nil </span><span class="cov3" title="3">{
                        if v, ok := metadata["ai_instances"]; ok </span><span class="cov3" title="3">{
                                switch t := v.(type) </span>{
                                case []interface{}:<span class="cov3" title="3">
                                        for _, it := range t </span><span class="cov4" title="6">{
                                                if sname, ok := it.(string); ok &amp;&amp; sname != "" </span><span class="cov4" title="6">{
                                                        metaInstances = append(metaInstances, sname)
                                                }</span>
                                        }
                                case []string:<span class="cov0" title="0">
                                        for _, sname := range t </span><span class="cov0" title="0">{
                                                if sname != "" </span><span class="cov0" title="0">{
                                                        metaInstances = append(metaInstances, sname)
                                                }</span>
                                        }
                                case string:<span class="cov0" title="0">
                                        if t != "" </span><span class="cov0" title="0">{
                                                metaInstances = append(metaInstances, t)
                                        }</span>
                                }
                        }
                }
        }

        // Role-based aggregation
        <span class="cov5" title="8">switch member.TeamRole </span>{
        case models.TeamRoleManager:<span class="cov3" title="3">
                // Find the group where this manager is the owner
                var targetGroup *models.Group

                // Try via user's team -&gt; group, and verify ownership
                if member.TeamID != nil </span><span class="cov3" title="3">{
                        if team, err := s.teamRepo.GetByID(*member.TeamID); err == nil </span><span class="cov3" title="3">{
                                if grp, err := s.groupRepo.GetByID(team.GroupID); err == nil </span><span class="cov3" title="3">{
                                        if grp.Owner == username </span><span class="cov3" title="3">{
                                                targetGroup = grp
                                        }</span> else<span class="cov0" title="0"> {
                                                // Search groups within the same org for ownership match
                                                if groups, _, err := s.groupRepo.GetByOrganizationID(grp.OrgID, s.getTeamLimit(), 0); err == nil </span><span class="cov0" title="0">{
                                                        for i := range groups </span><span class="cov0" title="0">{
                                                                if groups[i].Owner == username </span><span class="cov0" title="0">{
                                                                        g := groups[i]
                                                                        targetGroup = &amp;g
                                                                        break</span>
                                                                }
                                                        }
                                                }
                                        }
                                }
                        }
                }

                // As a fallback, scan all orgs for a group owned by user
                <span class="cov3" title="3">if targetGroup == nil &amp;&amp; s.orgRepo != nil </span><span class="cov0" title="0">{
                        if orgs, _, err := s.orgRepo.GetAll(1000, 0); err == nil </span><span class="cov0" title="0">{
                                for _, org := range orgs </span><span class="cov0" title="0">{
                                        if groups, _, err := s.groupRepo.GetByOrganizationID(org.ID, s.getTeamLimit(), 0); err == nil </span><span class="cov0" title="0">{
                                                for i := range groups </span><span class="cov0" title="0">{
                                                        if groups[i].Owner == username </span><span class="cov0" title="0">{
                                                                g := groups[i]
                                                                targetGroup = &amp;g
                                                                break</span>
                                                        }
                                                }
                                        }
                                        <span class="cov0" title="0">if targetGroup != nil </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                }
                        }
                }

                // Final fallback: use user's current team's group if available
                <span class="cov3" title="3">if targetGroup == nil &amp;&amp; member.TeamID != nil </span><span class="cov0" title="0">{
                        if team, err := s.teamRepo.GetByID(*member.TeamID); err == nil </span><span class="cov0" title="0">{
                                if grp, err := s.groupRepo.GetByID(team.GroupID); err == nil </span><span class="cov0" title="0">{
                                        targetGroup = grp
                                }</span>
                        }
                }

                // Collect all team names in the target group
                <span class="cov3" title="3">if targetGroup != nil </span><span class="cov3" title="3">{
                        if teams, _, err := s.teamRepo.GetByGroupID(targetGroup.ID, s.getTeamLimit(), 0); err == nil </span><span class="cov3" title="3">{
                                for _, t := range teams </span><span class="cov5" title="8">{
                                        add(t.Name)
                                }</span>
                        }
                }
        case models.TeamRoleMMM:<span class="cov1" title="1">
                // Find the organization where this MMM is the owner
                var targetOrg *models.Organization

                // Try via user's team -&gt; group -&gt; org
                if member.TeamID != nil </span><span class="cov1" title="1">{
                        if team, err := s.teamRepo.GetByID(*member.TeamID); err == nil </span><span class="cov1" title="1">{
                                if grp, err := s.groupRepo.GetByID(team.GroupID); err == nil </span><span class="cov1" title="1">{
                                        if org, err := s.orgRepo.GetByID(grp.OrgID); err == nil </span><span class="cov1" title="1">{
                                                if org.Owner == username </span><span class="cov1" title="1">{
                                                        targetOrg = org
                                                }</span>
                                        }
                                }
                        }
                }

                // Fallback: scan all organizations for ownership match
                <span class="cov1" title="1">if targetOrg == nil &amp;&amp; s.orgRepo != nil </span><span class="cov0" title="0">{
                        if orgs, _, err := s.orgRepo.GetAll(1000, 0); err == nil </span><span class="cov0" title="0">{
                                for i := range orgs </span><span class="cov0" title="0">{
                                        if orgs[i].Owner == username </span><span class="cov0" title="0">{
                                                o := orgs[i]
                                                targetOrg = &amp;o
                                                break</span>
                                        }
                                }
                        }
                }

                // Collect all team names across all groups in the target org
                <span class="cov1" title="1">if targetOrg != nil </span><span class="cov1" title="1">{
                        if groups, _, err := s.groupRepo.GetByOrganizationID(targetOrg.ID, s.getTeamLimit(), 0); err == nil </span><span class="cov1" title="1">{
                                for _, g := range groups </span><span class="cov2" title="2">{
                                        if teams, _, err := s.teamRepo.GetByGroupID(g.ID, s.getTeamLimit(), 0); err == nil </span><span class="cov2" title="2">{
                                                for _, t := range teams </span><span class="cov3" title="4">{
                                                        add(t.Name)
                                                }</span>
                                        }
                                }
                        }
                }
        default:<span class="cov3" title="4">
                // Neither manager nor mmm: use user's assigned team name (if any)
                if member.TeamID != nil </span><span class="cov3" title="3">{
                        if team, err := s.teamRepo.GetByID(*member.TeamID); err == nil </span><span class="cov3" title="3">{
                                add(team.Name)
                        }</span>
                }
        }

        // Log discovered instances (before filtering)
        <span class="cov5" title="8">{
                log := logger.New().WithField("username", username)
                log.WithField("ai_instances", aiInstances).Info("AI Core: initial discovered ai_instances")
        }</span>

        // Filter discovered instances by teams present in AI_CORE_CREDENTIALS
        <span class="cov5" title="8">filtered := make([]string, 0)
        envTeams := make(map[string]bool)

        if err := s.loadCredentials(); err == nil </span><span class="cov4" title="7">{
                // Build env team set from credentials cache
                s.credentialsMux.RLock()
                for teamName := range s.credentials </span><span class="cov6" title="18">{
                        envTeams[teamName] = true
                }</span>
                <span class="cov4" title="7">s.credentialsMux.RUnlock()

                for _, name := range aiInstances </span><span class="cov6" title="15">{
                        if envTeams[name] </span><span class="cov6" title="14">{
                                filtered = append(filtered, name)
                        }</span>
                }
        } else<span class="cov1" title="1"> {
                // If credentials are not configured, skip filtering
                filtered = aiInstances
        }</span>

        // Log filtered instances
        <span class="cov5" title="8">{
                log := logger.New().WithField("username", username)
                log.WithField("ai_instances", filtered).Info("AI Core: filtered ai_instances (by environment)")
        }</span>

        // Reset aiInstances to filtered values and reinitialize set
        <span class="cov5" title="8">aiInstances = make([]string, 0)
        seen = make(map[string]bool)
        for _, name := range filtered </span><span class="cov6" title="14">{
                if !seen[name] </span><span class="cov6" title="14">{
                        aiInstances = append(aiInstances, name)
                        seen[name] = true
                }</span>
        }

        // Add metadata instances (union after filtering)
        <span class="cov5" title="8">for _, name := range metaInstances </span><span class="cov4" title="6">{
                add(name)
        }</span>

        <span class="cov5" title="8">return &amp;AICoreMeResponse{
                User:        username,
                AIInstances: aiInstances,
        }, nil</span>
}

// GetModels retrieves models from AI for the user's team
func (s *AICoreService) GetModels(c *gin.Context, scenarioID string) (*AICoreModelsResponse, error) <span class="cov3" title="3">{
        // Get user email for logging context
        email, _ := auth.GetUserEmail(c)
        log := logger.New().WithFields(map[string]interface{}{
                "user_email":  email,
                "scenario_id": scenarioID,
        })

        // Get user's team
        teamName, err := s.getUserTeam(c)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Get credentials for the team
        <span class="cov2" title="2">credentials, err := s.getCredentialsForTeam(teamName)
        if err != nil </span><span class="cov0" title="0">{
                log.WithField("team_name", teamName).Errorf("AI Core: Failed to get credentials: %v", err)
                return nil, err
        }</span>

        // Get access token
        <span class="cov2" title="2">accessToken, err := s.getAccessToken(credentials)
        if err != nil </span><span class="cov0" title="0">{
                log.WithField("team_name", teamName).Errorf("AI Core: Failed to get access token: %v", err)
                return nil, err
        }</span>

        // Make request to AI Core
        <span class="cov2" title="2">url := fmt.Sprintf("%s/v2/lm/scenarios/%s/models", credentials.APIURL, scenarioID)
        resp, err := s.makeAICoreRequest("GET", url, accessToken, credentials.ResourceGroup, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.WithField("team_name", teamName).Errorf("AI Core: API request failed: %v", err)
                return nil, err
        }</span>
        <span class="cov2" title="2">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                body, _ := io.ReadAll(resp.Body)
                log.WithFields(map[string]interface{}{
                        "team_name":   teamName,
                        "status_code": resp.StatusCode,
                        "response":    string(body),
                }).Error("AI Core: AI Core API returned error")
                return nil, fmt.Errorf("%w with status %d: %s", errors.ErrAICoreAPIRequestFailed, resp.StatusCode, string(body))
        }</span>

        <span class="cov1" title="1">var modelsResp AICoreModelsResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;modelsResp); err != nil </span><span class="cov0" title="0">{
                log.WithField("team_name", teamName).Errorf("AI Core: Failed to decode response: %v", err)
                return nil, fmt.Errorf("failed to decode models response: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;modelsResp, nil</span>
}

// GetConfigurations retrieves configurations from AI Core for the user's team
func (s *AICoreService) GetConfigurations(c *gin.Context) (*AICoreConfigurationsResponse, error) <span class="cov3" title="3">{
        // Get user's team
        teamName, err := s.getUserTeam(c)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Get credentials for the team
        <span class="cov2" title="2">credentials, err := s.getCredentialsForTeam(teamName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get access token
        <span class="cov2" title="2">accessToken, err := s.getAccessToken(credentials)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Make request to AI Core
        <span class="cov2" title="2">url := fmt.Sprintf("%s/v2/lm/configurations", credentials.APIURL)
        resp, err := s.makeAICoreRequest("GET", url, accessToken, credentials.ResourceGroup, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="2">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("%w with status %d: %s", errors.ErrAICoreAPIRequestFailed, resp.StatusCode, string(body))
        }</span>

        <span class="cov1" title="1">var configurationsResp AICoreConfigurationsResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;configurationsResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode configurations response: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;configurationsResp, nil</span>
}

// CreateConfiguration creates a new configuration in AI Core
func (s *AICoreService) CreateConfiguration(c *gin.Context, req *AICoreConfigurationRequest) (*AICoreConfigurationResponse, error) <span class="cov4" title="5">{
        // Get user's team
        teamName, err := s.getUserTeam(c)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Get credentials for the team
        <span class="cov3" title="4">credentials, err := s.getCredentialsForTeam(teamName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get access token
        <span class="cov3" title="4">accessToken, err := s.getAccessToken(credentials)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Make request to AI Core
        <span class="cov3" title="4">url := fmt.Sprintf("%s/v2/lm/configurations", credentials.APIURL)
        resp, err := s.makeAICoreRequest("POST", url, accessToken, credentials.ResourceGroup, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="4">defer resp.Body.Close()

        if resp.StatusCode != http.StatusCreated </span><span class="cov2" title="2">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("%w with status %d: %s", errors.ErrAICoreAPIRequestFailed, resp.StatusCode, string(body))
        }</span>

        <span class="cov2" title="2">var configResp AICoreConfigurationResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;configResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode configuration response: %w", err)
        }</span>

        <span class="cov2" title="2">return &amp;configResp, nil</span>
}

// CreateDeployment creates a new deployment in AI Core
// Supports two scenarios:
// 1. Direct deployment with configurationId
// 2. Create configuration first, then deploy with the created configurationId
func (s *AICoreService) CreateDeployment(c *gin.Context, req *AICoreDeploymentRequest) (*AICoreDeploymentResponse, error) <span class="cov4" title="5">{
        // Validate that either configurationId or configurationRequest is provided, but not both
        if req.ConfigurationID == nil &amp;&amp; req.ConfigurationRequest == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("either configurationId or configurationRequest must be provided")
        }</span>
        <span class="cov3" title="4">if req.ConfigurationID != nil &amp;&amp; req.ConfigurationRequest != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("configurationId and configurationRequest cannot both be provided")
        }</span>

        <span class="cov3" title="3">var configurationID string

        // Scenario 1: Direct deployment with existing configurationId
        if req.ConfigurationID != nil </span><span class="cov1" title="1">{
                configurationID = *req.ConfigurationID
        }</span> else<span class="cov2" title="2"> {
                // Scenario 2: Create configuration first, then deploy
                configResp, err := s.CreateConfiguration(c, req.ConfigurationRequest)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to create configuration: %w", err)
                }</span>
                <span class="cov1" title="1">configurationID = configResp.ID</span>
        }

        // Get user's team
        <span class="cov2" title="2">teamName, err := s.getUserTeam(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get credentials for the team
        <span class="cov2" title="2">credentials, err := s.getCredentialsForTeam(teamName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get access token
        <span class="cov2" title="2">accessToken, err := s.getAccessToken(credentials)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create the deployment request for AI Core API
        <span class="cov2" title="2">deploymentReq := struct {
                ConfigurationID string `json:"configurationId"`
                TTL             string `json:"ttl,omitempty"`
        }{
                ConfigurationID: configurationID,
                TTL:             req.TTL,
        }

        // Make request to AI Core
        url := fmt.Sprintf("%s/v2/lm/deployments", credentials.APIURL)
        resp, err := s.makeAICoreRequest("POST", url, accessToken, credentials.ResourceGroup, deploymentReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="2">defer resp.Body.Close()

        if resp.StatusCode != http.StatusAccepted </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("%w with status %d: %s", errors.ErrAICoreAPIRequestFailed, resp.StatusCode, string(body))
        }</span>

        <span class="cov2" title="2">var deploymentResp AICoreDeploymentResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;deploymentResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode deployment response: %w", err)
        }</span>

        <span class="cov2" title="2">return &amp;deploymentResp, nil</span>
}

// UpdateDeployment updates a deployment in AI Core
func (s *AICoreService) UpdateDeployment(c *gin.Context, deploymentID string, req *AICoreDeploymentModificationRequest) (*AICoreDeploymentModificationResponse, error) <span class="cov3" title="3">{
        // Get user's team
        teamName, err := s.getUserTeam(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get credentials for the team
        <span class="cov3" title="3">credentials, err := s.getCredentialsForTeam(teamName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get access token
        <span class="cov3" title="3">accessToken, err := s.getAccessToken(credentials)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Make request to AI Core
        <span class="cov3" title="3">url := fmt.Sprintf("%s/v2/lm/deployments/%s", credentials.APIURL, deploymentID)
        resp, err := s.makeAICoreRequest("PATCH", url, accessToken, credentials.ResourceGroup, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="3">defer resp.Body.Close()

        if resp.StatusCode == http.StatusNotFound </span><span class="cov1" title="1">{
                return nil, errors.ErrAICoreDeploymentNotFound
        }</span>

        <span class="cov2" title="2">if resp.StatusCode != http.StatusAccepted </span><span class="cov1" title="1">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("%w with status %d: %s", errors.ErrAICoreAPIRequestFailed, resp.StatusCode, string(body))
        }</span>

        <span class="cov1" title="1">var modificationResp AICoreDeploymentModificationResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;modificationResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode deployment modification response: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;modificationResp, nil</span>
}

// DeleteDeployment deletes a deployment in AI Core
func (s *AICoreService) DeleteDeployment(c *gin.Context, deploymentID string) (*AICoreDeploymentDeletionResponse, error) <span class="cov2" title="2">{
        // Get user's team
        teamName, err := s.getUserTeam(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get credentials for the team
        <span class="cov2" title="2">credentials, err := s.getCredentialsForTeam(teamName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get access token
        <span class="cov2" title="2">accessToken, err := s.getAccessToken(credentials)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Make request to AI Core
        <span class="cov2" title="2">url := fmt.Sprintf("%s/v2/lm/deployments/%s", credentials.APIURL, deploymentID)
        resp, err := s.makeAICoreRequest("DELETE", url, accessToken, credentials.ResourceGroup, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="2">defer resp.Body.Close()

        if resp.StatusCode == http.StatusNotFound </span><span class="cov1" title="1">{
                return nil, errors.ErrAICoreDeploymentNotFound
        }</span>

        <span class="cov1" title="1">if resp.StatusCode != http.StatusAccepted </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("%w with status %d: %s", errors.ErrAICoreAPIRequestFailed, resp.StatusCode, string(body))
        }</span>

        <span class="cov1" title="1">var deletionResp AICoreDeploymentDeletionResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;deletionResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode deployment deletion response: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;deletionResp, nil</span>
}

// GetDeploymentDetails retrieves detailed information about a specific deployment from AI Core
func (s *AICoreService) GetDeploymentDetails(c *gin.Context, deploymentID string) (*AICoreDeploymentDetailsResponse, error) <span class="cov2" title="2">{
        // Get user's team
        teamName, err := s.getUserTeam(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get credentials for the team
        <span class="cov2" title="2">credentials, err := s.getCredentialsForTeam(teamName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get access token
        <span class="cov2" title="2">accessToken, err := s.getAccessToken(credentials)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Make request to AI Core
        <span class="cov2" title="2">url := fmt.Sprintf("%s/v2/lm/deployments/%s", credentials.APIURL, deploymentID)
        resp, err := s.makeAICoreRequest("GET", url, accessToken, credentials.ResourceGroup, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="2">defer resp.Body.Close()

        if resp.StatusCode == http.StatusNotFound </span><span class="cov1" title="1">{
                return nil, errors.ErrAICoreDeploymentNotFound
        }</span>

        <span class="cov1" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("%w with status %d: %s", errors.ErrAICoreAPIRequestFailed, resp.StatusCode, string(body))
        }</span>

        <span class="cov1" title="1">var deploymentDetails AICoreDeploymentDetailsResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;deploymentDetails); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode deployment details response: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;deploymentDetails, nil</span>
}

// AICoreInferenceRequest represents a chat inference request
type AICoreInferenceRequest struct {
        DeploymentID string                   `json:"deploymentId" validate:"required"`
        Messages     []AICoreInferenceMessage `json:"messages" validate:"required,min=1"`
        MaxTokens    int                      `json:"max_tokens,omitempty"`
        Temperature  float64                  `json:"temperature,omitempty"`
        TopP         float64                  `json:"top_p,omitempty"`
        Stream       bool                     `json:"stream,omitempty"`
}

// AICoreInferenceMessage represents a single message in the chat
// Content can be either a string or an array of content parts (for multimodal messages)
type AICoreInferenceMessage struct {
        Role    string      `json:"role" validate:"required,oneof=system user assistant"`
        Content interface{} `json:"content" validate:"required"` // string or []AICoreMessageContent
}

// AICoreMessageContent represents a part of a multimodal message (text or image)
type AICoreMessageContent struct {
        Type     string                 `json:"type"`                // "text" or "image_url"
        Text     string                 `json:"text,omitempty"`      // for type="text"
        ImageURL *AICoreMessageImageURL `json:"image_url,omitempty"` // for type="image_url"
        FileData *AICoreMessageFileData `json:"fileData,omitempty"`  // for Gemini
}

// AICoreMessageImageURL represents an image URL in a message (GPT format)
type AICoreMessageImageURL struct {
        URL string `json:"url"`
}

// AICoreMessageFileData represents file data in a message (Gemini format)
type AICoreMessageFileData struct {
        MimeType string `json:"mimeType"`
        FileURI  string `json:"fileUri"`
}

// AICoreInferenceResponse represents the response from AI Core inference
type AICoreInferenceResponse struct {
        ID                string                  `json:"id"`
        Object            string                  `json:"object"`
        Created           int64                   `json:"created"`
        Model             string                  `json:"model"`
        Choices           []AICoreInferenceChoice `json:"choices"`
        Usage             AICoreInferenceUsage    `json:"usage"`
        SystemFingerprint string                  `json:"system_fingerprint,omitempty"`
}

// AICoreInferenceChoice represents a single choice in the inference response
type AICoreInferenceChoice struct {
        Index        int                    `json:"index"`
        Message      AICoreInferenceMessage `json:"message"`
        FinishReason string                 `json:"finish_reason"`
}

// AICoreInferenceUsage represents token usage information
type AICoreInferenceUsage struct {
        PromptTokens     int `json:"prompt_tokens"`
        CompletionTokens int `json:"completion_tokens"`
        TotalTokens      int `json:"total_tokens"`
}

// ChatInference performs a chat inference request to a deployed model
func (s *AICoreService) ChatInference(c *gin.Context, req *AICoreInferenceRequest) (*AICoreInferenceResponse, error) <span class="cov5" title="11">{
        // Get all deployments accessible to the user (reuses the same logic as Deployments tab)
        deploymentsResp, err := s.GetDeployments(c)
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("failed to get deployments: %w", err)
        }</span>

        // Find the deployment by ID across all teams
        <span class="cov5" title="9">var targetDeployment *AICoreDeployment
        var targetTeamName string

        for _, teamDeployments := range deploymentsResp.Deployments </span><span class="cov5" title="9">{
                for _, deployment := range teamDeployments.Deployments </span><span class="cov5" title="8">{
                        if deployment.ID == req.DeploymentID </span><span class="cov5" title="8">{
                                targetDeployment = &amp;deployment
                                targetTeamName = teamDeployments.Team
                                break</span>
                        }
                }
                <span class="cov5" title="9">if targetDeployment != nil </span><span class="cov5" title="8">{
                        break</span>
                }
        }

        <span class="cov5" title="9">if targetDeployment == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("deployment %s not found or user does not have access to it", req.DeploymentID)
        }</span>

        <span class="cov5" title="8">if targetDeployment.DeploymentURL == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("deployment URL not available for deployment %s", req.DeploymentID)
        }</span>

        // Get credentials and token for the team that owns this deployment
        <span class="cov4" title="7">credentials, err := s.getCredentialsForTeam(targetTeamName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get credentials for team %s: %w", targetTeamName, err)
        }</span>

        <span class="cov4" title="7">accessToken, err := s.getAccessToken(credentials)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get access token: %w", err)
        }</span>

        // Determine model type from deployment details
        // SAP AI Core has different inference formats for different model types:
        // 1. Anthropic (Claude): Uses /invoke endpoint with Anthropic format
        // 2. GPT/OpenAI: Uses /chat/completions endpoint with OpenAI format (various api-versions)
        // 3. Gemini: Uses /models/&lt;model&gt;:generateContent endpoint
        // 4. Orchestration: Uses orchestration-specific endpoints (not foundation-models scenario)

        <span class="cov4" title="7">isOrchestration := false
        isGPTModel := false
        isGeminiModel := false
        modelName := ""

        // Check if this is orchestration based on scenario ID only
        // Orchestration deployments have a different scenario ID (not foundation-models)
        if strings.Contains(strings.ToLower(targetDeployment.ScenarioID), "orchestration") </span><span class="cov2" title="2">{
                isOrchestration = true
        }</span>

        // Extract model name and check model type
        <span class="cov4" title="7">if extractedName := extractModelNameFromDetails(targetDeployment.Details); extractedName != "" </span><span class="cov4" title="5">{
                modelName = extractedName
                lowerName := strings.ToLower(extractedName)
                if strings.Contains(lowerName, "gpt") || strings.Contains(lowerName, "o1") ||
                        strings.Contains(lowerName, "o3") || strings.Contains(lowerName, "openai") </span><span class="cov1" title="1">{
                        isGPTModel = true
                }</span> else<span class="cov3" title="4"> if strings.Contains(lowerName, "gemini") </span><span class="cov3" title="3">{
                        isGeminiModel = true
                }</span>
        }

        // Trim messages to fit within model context limits
        // This prevents "context too large" errors
        <span class="cov4" title="7">contextLimit := getModelContextLimit(modelName)
        req.Messages = trimMessagesToContextLimit(req.Messages, contextLimit)

        var inferencePayload map[string]interface{}
        var inferenceURL string

        // Helper function to extract text content from message
        getMessageText := func(msg AICoreInferenceMessage) string </span><span class="cov3" title="4">{
                if str, ok := msg.Content.(string); ok </span><span class="cov3" title="4">{
                        return str
                }</span>
                // If content is array, find the first text part
                <span class="cov0" title="0">if contentArr, ok := msg.Content.([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, part := range contentArr </span><span class="cov0" title="0">{
                                if partMap, ok := part.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if partMap["type"] == "text" </span><span class="cov0" title="0">{
                                                if text, ok := partMap["text"].(string); ok </span><span class="cov0" title="0">{
                                                        return text
                                                }</span>
                                        }
                                }
                        }
                }
                <span class="cov0" title="0">return ""</span>
        }

        <span class="cov4" title="7">if isGeminiModel </span><span class="cov3" title="3">{
                // Gemini models use /models/&lt;model&gt;:generateContent endpoint
                // Format: https://...deployments/{id}/models/gemini-1.5-flash:generateContent

                // Build Gemini contents structure
                var parts []map[string]interface{}

                for _, msg := range req.Messages </span><span class="cov3" title="3">{
                        if msg.Role == "system" </span><span class="cov0" title="0">{
                                // Gemini doesn't have system role, prepend as user message
                                parts = append(parts, map[string]interface{}{
                                        "text": fmt.Sprintf("[System]: %s", getMessageText(msg)),
                                })
                                continue</span>
                        }

                        // Handle multimodal content (text + images)
                        <span class="cov3" title="3">if contentArr, ok := msg.Content.([]interface{}); ok </span><span class="cov1" title="1">{
                                for _, part := range contentArr </span><span class="cov2" title="2">{
                                        if partMap, ok := part.(map[string]interface{}); ok </span><span class="cov2" title="2">{
                                                partType := partMap["type"].(string)
                                                if partType == "text" </span><span class="cov1" title="1">{
                                                        parts = append(parts, map[string]interface{}{
                                                                "text": partMap["text"],
                                                        })
                                                }</span> else<span class="cov1" title="1"> if partType == "image_url" </span><span class="cov1" title="1">{
                                                        // Convert image_url to fileData format for Gemini
                                                        if imageURL, ok := partMap["image_url"].(map[string]interface{}); ok </span><span class="cov1" title="1">{
                                                                parts = append(parts, map[string]interface{}{
                                                                        "fileData": map[string]interface{}{
                                                                                "mimeType": "image/png", // Default, can be detected from URL
                                                                                "fileUri":  imageURL["url"],
                                                                        },
                                                                })
                                                        }</span>
                                                }
                                        }
                                }
                        } else<span class="cov2" title="2"> {
                                // Simple text content
                                parts = append(parts, map[string]interface{}{
                                        "text": getMessageText(msg),
                                })
                        }</span>
                }

                <span class="cov3" title="3">inferencePayload = map[string]interface{}{
                        "contents": map[string]interface{}{
                                "role":  "user",
                                "parts": parts,
                        },
                }

                // Add generation config if parameters provided
                if req.MaxTokens &gt; 0 || req.Temperature &gt; 0 </span><span class="cov1" title="1">{
                        generationConfig := make(map[string]interface{})
                        if req.MaxTokens &gt; 0 </span><span class="cov1" title="1">{
                                generationConfig["maxOutputTokens"] = req.MaxTokens
                        }</span>
                        <span class="cov1" title="1">if req.Temperature &gt; 0 </span><span class="cov1" title="1">{
                                generationConfig["temperature"] = req.Temperature
                        }</span>
                        <span class="cov1" title="1">inferencePayload["generation_config"] = generationConfig</span>
                }

                // Gemini endpoint format: /models/&lt;model&gt;:generateContent or streamGenerateContent for streaming
                <span class="cov3" title="3">if req.Stream </span><span class="cov0" title="0">{
                        inferenceURL = fmt.Sprintf("%s/models/%s:streamGenerateContent", targetDeployment.DeploymentURL, modelName)
                }</span> else<span class="cov3" title="3"> {
                        inferenceURL = fmt.Sprintf("%s/models/%s:generateContent", targetDeployment.DeploymentURL, modelName)
                }</span>
        } else<span class="cov3" title="4"> if isOrchestration </span><span class="cov2" title="2">{
                // Extract model name from deployment details
                modelName := extractModelNameFromDetails(targetDeployment.Details)
                if modelName == "" </span><span class="cov2" title="2">{
                        modelName = "gpt-4o-mini" // default fallback
                }</span>

                // Build template messages for orchestration
                <span class="cov2" title="2">templateMessages := make([]map[string]interface{}, 0)
                for _, msg := range req.Messages </span><span class="cov2" title="2">{
                        templateMessages = append(templateMessages, map[string]interface{}{
                                "role":    msg.Role,
                                "content": msg.Content,
                        })
                }</span>

                // Prepare orchestration request payload
                // SAP AI Core orchestration uses a specific format with orchestration_config
                <span class="cov2" title="2">modelParams := map[string]interface{}{
                        "frequency_penalty": 0,
                        "presence_penalty":  0,
                }

                if req.MaxTokens &gt; 0 </span><span class="cov1" title="1">{
                        modelParams["max_tokens"] = req.MaxTokens
                }</span> else<span class="cov1" title="1"> {
                        modelParams["max_tokens"] = 1000
                }</span>

                <span class="cov2" title="2">if req.Temperature &gt; 0 </span><span class="cov1" title="1">{
                        modelParams["temperature"] = req.Temperature
                }</span> else<span class="cov1" title="1"> {
                        modelParams["temperature"] = 0.7
                }</span>

                <span class="cov2" title="2">inferencePayload = map[string]interface{}{
                        "orchestration_config": map[string]interface{}{
                                "module_configurations": map[string]interface{}{
                                        "templating_module_config": map[string]interface{}{
                                                "template": templateMessages,
                                        },
                                        "llm_module_config": map[string]interface{}{
                                                "model_name":    modelName,
                                                "model_params":  modelParams,
                                                "model_version": "latest",
                                        },
                                },
                        },
                        "input_params": map[string]interface{}{},
                }

                // Use orchestration /completion endpoint
                inferenceURL = fmt.Sprintf("%s/completion", targetDeployment.DeploymentURL)</span>
        } else<span class="cov2" title="2"> if isGPTModel </span><span class="cov1" title="1">{
                // GPT/OpenAI foundation models use /chat/completions endpoint with OpenAI-compatible format
                // Build messages array - handle both simple strings and multimodal content
                messages := make([]map[string]interface{}, 0)
                for _, msg := range req.Messages </span><span class="cov1" title="1">{
                        message := map[string]interface{}{
                                "role": msg.Role,
                        }

                        // Check if content is multimodal (array) or simple text (string)
                        if contentArr, ok := msg.Content.([]interface{}); ok </span><span class="cov0" title="0">{
                                // Multimodal content (text + images for GPT-4o, GPT-4-Turbo, GPT-4o Mini)
                                message["content"] = contentArr
                        }</span> else<span class="cov1" title="1"> {
                                // Simple text content
                                message["content"] = msg.Content
                        }</span>

                        <span class="cov1" title="1">messages = append(messages, message)</span>
                }

                // Build OpenAI-compatible payload
                <span class="cov1" title="1">inferencePayload = map[string]interface{}{
                        "messages": messages,
                }

                // Determine API version based on model
                apiVersion := getGPTAPIVersion(modelName)

                // Add optional parameters (o1, o3-mini, and gpt-5 don't support these parameters)
                isReasoningModel := strings.Contains(strings.ToLower(modelName), "o1") ||
                        strings.Contains(strings.ToLower(modelName), "o3-mini") ||
                        strings.Contains(strings.ToLower(modelName), "gpt-5")

                if !isReasoningModel </span><span class="cov1" title="1">{
                        if req.MaxTokens &gt; 0 </span><span class="cov1" title="1">{
                                inferencePayload["max_tokens"] = req.MaxTokens
                        }</span> else<span class="cov0" title="0"> {
                                inferencePayload["max_tokens"] = 1000
                        }</span>
                        <span class="cov1" title="1">if req.Temperature &gt; 0 </span><span class="cov1" title="1">{
                                inferencePayload["temperature"] = req.Temperature
                        }</span> else<span class="cov0" title="0"> {
                                inferencePayload["temperature"] = 0.7
                        }</span>
                        <span class="cov1" title="1">if req.TopP &gt; 0 </span><span class="cov0" title="0">{
                                inferencePayload["top_p"] = req.TopP
                        }</span>
                }

                // Add stream parameter for GPT models
                <span class="cov1" title="1">if req.Stream </span><span class="cov0" title="0">{
                        inferencePayload["stream"] = true
                }</span>

                // GPT foundation models use /chat/completions endpoint with api-version query parameter
                <span class="cov1" title="1">inferenceURL = fmt.Sprintf("%s/chat/completions?api-version=%s", targetDeployment.DeploymentURL, apiVersion)</span>
        } else<span class="cov1" title="1"> {
                // Anthropic Claude foundation models use /invoke endpoint with Anthropic format
                // Convert messages to Anthropic Claude API format
                var systemPrompt string
                var userMessages []map[string]string

                for _, msg := range req.Messages </span><span class="cov2" title="2">{
                        if msg.Role == "system" </span><span class="cov1" title="1">{
                                systemPrompt = getMessageText(msg)
                        }</span> else<span class="cov1" title="1"> {
                                userMessages = append(userMessages, map[string]string{
                                        "role":    msg.Role,
                                        "content": getMessageText(msg),
                                })
                        }</span>
                }

                // Build Anthropic-compatible payload
                <span class="cov1" title="1">inferencePayload = map[string]interface{}{
                        "anthropic_version": "bedrock-2023-05-31",
                        "messages":          userMessages,
                }

                // Add system prompt if present
                if systemPrompt != "" </span><span class="cov1" title="1">{
                        inferencePayload["system"] = systemPrompt
                }</span>

                // Add optional parameters using Anthropic naming
                <span class="cov1" title="1">if req.MaxTokens &gt; 0 </span><span class="cov1" title="1">{
                        inferencePayload["max_tokens"] = req.MaxTokens
                }</span> else<span class="cov0" title="0"> {
                        inferencePayload["max_tokens"] = 1000
                }</span>
                <span class="cov1" title="1">if req.Temperature &gt; 0 </span><span class="cov1" title="1">{
                        inferencePayload["temperature"] = req.Temperature
                }</span> else<span class="cov0" title="0"> {
                        inferencePayload["temperature"] = 0.7
                }</span>
                <span class="cov1" title="1">if req.TopP &gt; 0 </span><span class="cov0" title="0">{
                        inferencePayload["top_p"] = req.TopP
                }</span>

                // Add stream parameter for Anthropic models
                <span class="cov1" title="1">if req.Stream </span><span class="cov0" title="0">{
                        inferencePayload["stream"] = true
                }</span>

                // Anthropic foundation models use /invoke endpoint
                <span class="cov1" title="1">inferenceURL = fmt.Sprintf("%s/invoke", targetDeployment.DeploymentURL)</span>
        }

        <span class="cov4" title="7">resp, err := s.makeAICoreRequest("POST", inferenceURL, accessToken, credentials.ResourceGroup, inferencePayload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make inference request: %w", err)
        }</span>
        <span class="cov4" title="7">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("inference request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov4" title="7">var inferenceResp *AICoreInferenceResponse

        if isGeminiModel </span><span class="cov3" title="3">{
                // Parse Gemini response and convert to OpenAI-compatible format
                var geminiResp struct {
                        Candidates []struct {
                                Content struct {
                                        Parts []struct {
                                                Text string `json:"text"`
                                        } `json:"parts"`
                                        Role string `json:"role"`
                                } `json:"content"`
                                FinishReason string `json:"finishReason"`
                        } `json:"candidates"`
                        UsageMetadata struct {
                                PromptTokenCount     int `json:"promptTokenCount"`
                                CandidatesTokenCount int `json:"candidatesTokenCount"`
                                TotalTokenCount      int `json:"totalTokenCount"`
                        } `json:"usageMetadata"`
                }

                if err := json.NewDecoder(resp.Body).Decode(&amp;geminiResp); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to decode Gemini response: %w", err)
                }</span>

                // Convert to OpenAI format
                <span class="cov3" title="3">inferenceResp = &amp;AICoreInferenceResponse{
                        ID:      fmt.Sprintf("gemini-%d", time.Now().Unix()),
                        Object:  "chat.completion",
                        Created: time.Now().Unix(),
                        Model:   modelName,
                        Choices: []AICoreInferenceChoice{},
                        Usage: AICoreInferenceUsage{
                                PromptTokens:     geminiResp.UsageMetadata.PromptTokenCount,
                                CompletionTokens: geminiResp.UsageMetadata.CandidatesTokenCount,
                                TotalTokens:      geminiResp.UsageMetadata.TotalTokenCount,
                        },
                }

                // Extract text from candidates
                for i, candidate := range geminiResp.Candidates </span><span class="cov3" title="3">{
                        var text string
                        for _, part := range candidate.Content.Parts </span><span class="cov3" title="3">{
                                text += part.Text
                        }</span>

                        <span class="cov3" title="3">inferenceResp.Choices = append(inferenceResp.Choices, AICoreInferenceChoice{
                                Index: i,
                                Message: AICoreInferenceMessage{
                                        Role:    "assistant",
                                        Content: text,
                                },
                                FinishReason: strings.ToLower(candidate.FinishReason),
                        })</span>
                }
        } else<span class="cov3" title="4"> if isOrchestration </span><span class="cov2" title="2">{
                // Parse orchestration response
                // Orchestration returns: {orchestration_result: {choices: [{message: {content: "..."}}]}}
                var orchResp struct {
                        OrchestrationResult struct {
                                Choices []struct {
                                        Message struct {
                                                Content string `json:"content"`
                                                Role    string `json:"role"`
                                        } `json:"message"`
                                        FinishReason string `json:"finish_reason"`
                                        Index        int    `json:"index"`
                                } `json:"choices"`
                        } `json:"orchestration_result"`
                        ModuleResults struct {
                                Templating []interface{} `json:"templating"`
                                LLM        []struct {
                                        Message struct {
                                                Content string `json:"content"`
                                                Role    string `json:"role"`
                                        } `json:"message"`
                                } `json:"llm"`
                        } `json:"module_results"`
                }

                if err := json.NewDecoder(resp.Body).Decode(&amp;orchResp); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to decode orchestration response: %w", err)
                }</span>

                // Convert to OpenAI format
                <span class="cov2" title="2">inferenceResp = &amp;AICoreInferenceResponse{
                        ID:      fmt.Sprintf("orch-%d", time.Now().Unix()),
                        Object:  "chat.completion",
                        Created: time.Now().Unix(),
                        Model:   modelName,
                        Choices: []AICoreInferenceChoice{},
                        Usage: AICoreInferenceUsage{
                                PromptTokens:     0, // Orchestration doesn't return token counts
                                CompletionTokens: 0,
                                TotalTokens:      0,
                        },
                }

                // Extract choices from orchestration result
                for _, choice := range orchResp.OrchestrationResult.Choices </span><span class="cov2" title="2">{
                        inferenceResp.Choices = append(inferenceResp.Choices, AICoreInferenceChoice{
                                Index: choice.Index,
                                Message: AICoreInferenceMessage{
                                        Role:    "assistant",
                                        Content: choice.Message.Content,
                                },
                                FinishReason: choice.FinishReason,
                        })
                }</span>
        } else<span class="cov2" title="2"> if isGPTModel </span><span class="cov1" title="1">{
                // Parse GPT/OpenAI response
                // SAP AI Core returns OpenAI-compatible format for GPT models
                inferenceResp = &amp;AICoreInferenceResponse{}
                if err := json.NewDecoder(resp.Body).Decode(inferenceResp); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to decode GPT response: %w", err)
                }</span>
        } else<span class="cov1" title="1"> {
                // Parse direct model response - Anthropic format from /invoke endpoint
                // Response structure: {"content":[{"text":"...","type":"text"}],"role":"assistant",...}
                var anthropicResp struct {
                        ID      string `json:"id"`
                        Type    string `json:"type"`
                        Role    string `json:"role"`
                        Content []struct {
                                Type string `json:"type"`
                                Text string `json:"text"`
                        } `json:"content"`
                        Model      string `json:"model"`
                        StopReason string `json:"stop_reason"`
                        Usage      struct {
                                InputTokens  int `json:"input_tokens"`
                                OutputTokens int `json:"output_tokens"`
                        } `json:"usage"`
                }

                if err := json.NewDecoder(resp.Body).Decode(&amp;anthropicResp); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to decode Anthropic response: %w", err)
                }</span>

                // Extract text from content array
                <span class="cov1" title="1">var generatedText string
                if len(anthropicResp.Content) &gt; 0 </span><span class="cov1" title="1">{
                        generatedText = anthropicResp.Content[0].Text
                }</span>

                // Convert Anthropic format to OpenAI-compatible format for frontend
                <span class="cov1" title="1">inferenceResp = &amp;AICoreInferenceResponse{
                        ID:      anthropicResp.ID,
                        Object:  "chat.completion",
                        Created: time.Now().Unix(),
                        Model:   anthropicResp.Model,
                        Choices: []AICoreInferenceChoice{
                                {
                                        Index: 0,
                                        Message: AICoreInferenceMessage{
                                                Role:    "assistant",
                                                Content: generatedText,
                                        },
                                        FinishReason: anthropicResp.StopReason,
                                },
                        },
                        Usage: AICoreInferenceUsage{
                                PromptTokens:     anthropicResp.Usage.InputTokens,
                                CompletionTokens: anthropicResp.Usage.OutputTokens,
                                TotalTokens:      anthropicResp.Usage.InputTokens + anthropicResp.Usage.OutputTokens,
                        },
                }</span>
        }

        <span class="cov4" title="7">return inferenceResp, nil</span>
}

// UploadAttachment processes uploaded files for AI inference
// Converts files to base64 data URLs for use in multimodal requests
// Supports images, text files (txt, json, html, csv, etc.), and documents
func (s *AICoreService) UploadAttachment(c *gin.Context, file multipart.File, header *multipart.FileHeader) (map[string]interface{}, error) <span class="cov6" title="16">{
        // Read file content
        fileBytes, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read file: %w", err)
        }</span>

        // Detect MIME type from content
        <span class="cov6" title="16">mimeType := http.DetectContentType(fileBytes)

        // For text files, http.DetectContentType may return generic types
        // Use file extension to get more accurate MIME type
        filename := strings.ToLower(header.Filename)
        switch </span>{
        case strings.HasSuffix(filename, ".json"):<span class="cov2" title="2">
                mimeType = "application/json"</span>
        case strings.HasSuffix(filename, ".txt"):<span class="cov3" title="3">
                mimeType = "text/plain"</span>
        case strings.HasSuffix(filename, ".html") || strings.HasSuffix(filename, ".htm"):<span class="cov2" title="2">
                mimeType = "text/html"</span>
        case strings.HasSuffix(filename, ".csv"):<span class="cov1" title="1">
                mimeType = "text/csv"</span>
        case strings.HasSuffix(filename, ".xml"):<span class="cov1" title="1">
                mimeType = "application/xml"</span>
        case strings.HasSuffix(filename, ".yaml") || strings.HasSuffix(filename, ".yml"):<span class="cov2" title="2">
                mimeType = "application/x-yaml"</span>
        case strings.HasSuffix(filename, ".md"):<span class="cov1" title="1">
                mimeType = "text/markdown"</span>
        case strings.HasSuffix(filename, ".pdf"):<span class="cov1" title="1">
                mimeType = "application/pdf"</span>
        }

        // Convert to base64 data URL
        <span class="cov6" title="16">base64Data := base64.StdEncoding.EncodeToString(fileBytes)
        dataURL := fmt.Sprintf("data:%s;base64,%s", mimeType, base64Data)

        return map[string]interface{}{
                "url":      dataURL,
                "mimeType": mimeType,
                "filename": header.Filename,
                "size":     header.Size,
        }, nil</span>
}

// extractModelNameFromDetails extracts the model name from deployment details
// Checks both backend_details and backendDetails (camelCase) field names
// Returns empty string if model name cannot be extracted
func extractModelNameFromDetails(details map[string]interface{}) string <span class="cov6" title="21">{
        if details == nil </span><span class="cov3" title="4">{
                return ""
        }</span>

        <span class="cov6" title="17">resources, ok := details["resources"].(map[string]interface{})
        if !ok </span><span class="cov2" title="2">{
                return ""
        }</span>

        // Try backend_details first (snake_case)
        <span class="cov6" title="15">if backendDetails, ok := resources["backend_details"].(map[string]interface{}); ok </span><span class="cov6" title="15">{
                if model, ok := backendDetails["model"].(map[string]interface{}); ok </span><span class="cov6" title="15">{
                        if name, ok := model["name"].(string); ok &amp;&amp; name != "" </span><span class="cov6" title="15">{
                                return name
                        }</span>
                }
        }

        // Try backendDetails (camelCase)
        <span class="cov0" title="0">if backendDetails, ok := resources["backendDetails"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if model, ok := backendDetails["model"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if name, ok := model["name"].(string); ok &amp;&amp; name != "" </span><span class="cov0" title="0">{
                                return name
                        }</span>
                }
        }

        <span class="cov0" title="0">return ""</span>
}

// getModelContextLimit returns the maximum number of messages to send based on model type
// This prevents "context too large" errors by limiting conversation history
func getModelContextLimit(modelName string) int <span class="cov6" title="19">{
        lowerName := strings.ToLower(modelName)

        // Different models have different context windows
        // We limit by message count rather than tokens for simplicity
        switch </span>{
        case strings.Contains(lowerName, "gpt-5"):<span class="cov0" title="0">
                return 50</span> // GPT-5 has very large context window
        case strings.Contains(lowerName, "gpt-4-32k"):<span class="cov0" title="0">
                return 40</span> // Larger context window
        case strings.Contains(lowerName, "gpt-4"):<span class="cov4" title="7">
                return 30</span> // Standard GPT-4
        case strings.Contains(lowerName, "gpt-3.5"):<span class="cov0" title="0">
                return 25</span> // GPT-3.5
        case strings.Contains(lowerName, "o1") || strings.Contains(lowerName, "o3"):<span class="cov1" title="1">
                return 20</span> // Reasoning models
        case strings.Contains(lowerName, "claude"):<span class="cov2" title="2">
                return 35</span> // Claude has good context
        case strings.Contains(lowerName, "gemini-1.5"):<span class="cov4" title="5">
                return 40</span> // Gemini 1.5 has large context
        case strings.Contains(lowerName, "gemini"):<span class="cov0" title="0">
                return 30</span> // Other Gemini models
        default:<span class="cov3" title="4">
                return 20</span> // Conservative default
        }
}

// trimMessagesToContextLimit trims messages to fit within model context limits
// Keeps system messages and the most recent user/assistant messages
func trimMessagesToContextLimit(messages []AICoreInferenceMessage, limit int) []AICoreInferenceMessage <span class="cov6" title="19">{
        if len(messages) &lt;= limit </span><span class="cov6" title="18">{
                return messages
        }</span>

        // Separate system messages from conversation messages
        <span class="cov1" title="1">var systemMessages []AICoreInferenceMessage
        var conversationMessages []AICoreInferenceMessage

        for _, msg := range messages </span><span class="cov10" title="101">{
                if msg.Role == "system" </span><span class="cov1" title="1">{
                        systemMessages = append(systemMessages, msg)
                }</span> else<span class="cov9" title="100"> {
                        conversationMessages = append(conversationMessages, msg)
                }</span>
        }

        // Calculate how many conversation messages we can keep
        <span class="cov1" title="1">availableSlots := limit - len(systemMessages)
        if availableSlots &lt; 1 </span><span class="cov0" title="0">{
                availableSlots = 1 // Always keep at least one message
        }</span>

        // Keep the most recent conversation messages
        <span class="cov1" title="1">var trimmedConversation []AICoreInferenceMessage
        if len(conversationMessages) &gt; availableSlots </span><span class="cov1" title="1">{
                // Take the last N messages
                trimmedConversation = conversationMessages[len(conversationMessages)-availableSlots:]
        }</span> else<span class="cov0" title="0"> {
                trimmedConversation = conversationMessages
        }</span>

        // Combine system messages with trimmed conversation
        <span class="cov1" title="1">result := make([]AICoreInferenceMessage, 0, len(systemMessages)+len(trimmedConversation))
        result = append(result, systemMessages...)
        result = append(result, trimmedConversation...)

        return result</span>
}

// getGPTAPIVersion determines GPT API version based on model name
func getGPTAPIVersion(modelName string) string <span class="cov4" title="7">{
        lowerName := strings.ToLower(modelName)
        // o1, o3-mini, and gpt-5 use newer API version
        if strings.Contains(lowerName, "o1") || strings.Contains(lowerName, "o3-mini") || strings.Contains(lowerName, "gpt-5") </span><span class="cov1" title="1">{
                return "2024-12-01-preview"
        }</span>
        // All other GPT models use the standard API version
        <span class="cov4" title="6">return "2023-05-15"</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package service

import (
        "bufio"
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        "developer-portal-backend/internal/logger"

        "github.com/gin-gonic/gin"
)

// ChatInferenceStream handles streaming chat inference using Server-Sent Events
func (s *AICoreService) ChatInferenceStream(c *gin.Context, req *AICoreInferenceRequest, writer gin.ResponseWriter) error <span class="cov7" title="17">{
        // Get all deployments accessible to the user
        deploymentsResp, err := s.GetDeployments(c)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get deployments: %w", err)
        }</span>

        // Find the deployment by ID across all teams
        <span class="cov7" title="16">var targetDeployment *AICoreDeployment
        var targetTeamName string

        for _, teamDeployments := range deploymentsResp.Deployments </span><span class="cov7" title="13">{
                for _, deployment := range teamDeployments.Deployments </span><span class="cov7" title="13">{
                        if deployment.ID == req.DeploymentID </span><span class="cov7" title="13">{
                                targetDeployment = &amp;deployment
                                targetTeamName = teamDeployments.Team
                                break</span>
                        }
                }
                <span class="cov7" title="13">if targetDeployment != nil </span><span class="cov7" title="13">{
                        break</span>
                }
        }

        <span class="cov7" title="16">if targetDeployment == nil </span><span class="cov3" title="3">{
                return fmt.Errorf("deployment %s not found or user does not have access to it", req.DeploymentID)
        }</span>

        <span class="cov7" title="13">if targetDeployment.DeploymentURL == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("deployment URL not available for deployment %s", req.DeploymentID)
        }</span>

        // Get credentials and token for the team that owns this deployment
        <span class="cov7" title="12">credentials, err := s.getCredentialsForTeam(targetTeamName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get credentials for team %s: %w", targetTeamName, err)
        }</span>

        <span class="cov7" title="12">accessToken, err := s.getAccessToken(credentials)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get access token: %w", err)
        }</span>

        // Determine model type (same logic as ChatInference)
        <span class="cov7" title="12">isOrchestration := false
        isGPTModel := false
        isGeminiModel := false
        modelName := ""

        // Check if this is orchestration based on scenario ID
        if strings.Contains(strings.ToLower(targetDeployment.ScenarioID), "orchestration") </span><span class="cov1" title="1">{
                isOrchestration = true
        }</span>

        // Extract model name and check model type
        <span class="cov7" title="12">if extractedName := extractModelNameFromDetails(targetDeployment.Details); extractedName != "" </span><span class="cov6" title="10">{
                modelName = extractedName
                lowerName := strings.ToLower(extractedName)
                if strings.Contains(lowerName, "gpt") || strings.Contains(lowerName, "o1") ||
                        strings.Contains(lowerName, "o3") || strings.Contains(lowerName, "openai") </span><span class="cov5" title="7">{
                        isGPTModel = true
                }</span> else<span class="cov3" title="3"> if strings.Contains(lowerName, "gemini") </span><span class="cov2" title="2">{
                        isGeminiModel = true
                }</span>
        }

        // Trim messages to fit within model context limits
        <span class="cov7" title="12">contextLimit := getModelContextLimit(modelName)
        req.Messages = trimMessagesToContextLimit(req.Messages, contextLimit)

        // Build inference payload (reuse logic from ChatInference)
        var inferencePayload map[string]interface{}
        var inferenceURL string

        // Helper function to extract text content from message
        getMessageText := func(msg AICoreInferenceMessage) string </span><span class="cov6" title="8">{
                if str, ok := msg.Content.(string); ok </span><span class="cov6" title="8">{
                        return str
                }</span>
                <span class="cov0" title="0">if contentArr, ok := msg.Content.([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, part := range contentArr </span><span class="cov0" title="0">{
                                if partMap, ok := part.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if partMap["type"] == "text" </span><span class="cov0" title="0">{
                                                if text, ok := partMap["text"].(string); ok </span><span class="cov0" title="0">{
                                                        return text
                                                }</span>
                                        }
                                }
                        }
                }
                <span class="cov0" title="0">return ""</span>
        }

        <span class="cov7" title="12">if isGeminiModel </span><span class="cov2" title="2">{
                // Gemini models use /models/&lt;model&gt;:streamGenerateContent endpoint
                var parts []map[string]interface{}

                for _, msg := range req.Messages </span><span class="cov3" title="3">{
                        if msg.Role == "system" </span><span class="cov1" title="1">{
                                parts = append(parts, map[string]interface{}{
                                        "text": fmt.Sprintf("[System]: %s", getMessageText(msg)),
                                })
                                continue</span>
                        }

                        // Handle multimodal content (text + images)
                        <span class="cov2" title="2">if contentArr, ok := msg.Content.([]interface{}); ok </span><span class="cov1" title="1">{
                                for _, part := range contentArr </span><span class="cov2" title="2">{
                                        if partMap, ok := part.(map[string]interface{}); ok </span><span class="cov2" title="2">{
                                                partType := partMap["type"].(string)
                                                if partType == "text" </span><span class="cov1" title="1">{
                                                        parts = append(parts, map[string]interface{}{
                                                                "text": partMap["text"],
                                                        })
                                                }</span> else<span class="cov1" title="1"> if partType == "image_url" </span><span class="cov1" title="1">{
                                                        if imageURL, ok := partMap["image_url"].(map[string]interface{}); ok </span><span class="cov1" title="1">{
                                                                parts = append(parts, map[string]interface{}{
                                                                        "fileData": map[string]interface{}{
                                                                                "mimeType": "image/png",
                                                                                "fileUri":  imageURL["url"],
                                                                        },
                                                                })
                                                        }</span>
                                                }
                                        }
                                }
                        } else<span class="cov1" title="1"> {
                                parts = append(parts, map[string]interface{}{
                                        "text": getMessageText(msg),
                                })
                        }</span>
                }

                <span class="cov2" title="2">inferencePayload = map[string]interface{}{
                        "contents": map[string]interface{}{
                                "role":  "user",
                                "parts": parts,
                        },
                }

                if req.MaxTokens &gt; 0 || req.Temperature &gt; 0 </span><span class="cov1" title="1">{
                        generationConfig := make(map[string]interface{})
                        if req.MaxTokens &gt; 0 </span><span class="cov1" title="1">{
                                generationConfig["maxOutputTokens"] = req.MaxTokens
                        }</span>
                        <span class="cov1" title="1">if req.Temperature &gt; 0 </span><span class="cov1" title="1">{
                                generationConfig["temperature"] = req.Temperature
                        }</span>
                        <span class="cov1" title="1">inferencePayload["generation_config"] = generationConfig</span>
                }

                <span class="cov2" title="2">inferenceURL = fmt.Sprintf("%s/models/%s:streamGenerateContent", targetDeployment.DeploymentURL, modelName)</span>
        } else<span class="cov6" title="10"> if isOrchestration </span><span class="cov1" title="1">{
                // Orchestration models use orchestration config
                if modelName == "" </span><span class="cov0" title="0">{
                        modelName = "gpt-4o-mini"
                }</span>

                <span class="cov1" title="1">templateMessages := make([]map[string]interface{}, 0)
                for _, msg := range req.Messages </span><span class="cov1" title="1">{
                        templateMessages = append(templateMessages, map[string]interface{}{
                                "role":    msg.Role,
                                "content": msg.Content,
                        })
                }</span>

                <span class="cov1" title="1">modelParams := map[string]interface{}{
                        "frequency_penalty": 0,
                        "presence_penalty":  0,
                }

                if req.MaxTokens &gt; 0 </span><span class="cov1" title="1">{
                        modelParams["max_tokens"] = req.MaxTokens
                }</span> else<span class="cov0" title="0"> {
                        modelParams["max_tokens"] = 1000
                }</span>

                <span class="cov1" title="1">if req.Temperature &gt; 0 </span><span class="cov1" title="1">{
                        modelParams["temperature"] = req.Temperature
                }</span> else<span class="cov0" title="0"> {
                        modelParams["temperature"] = 0.7
                }</span>

                <span class="cov1" title="1">inferencePayload = map[string]interface{}{
                        "orchestration_config": map[string]interface{}{
                                "module_configurations": map[string]interface{}{
                                        "templating_module_config": map[string]interface{}{
                                                "template": templateMessages,
                                        },
                                        "llm_module_config": map[string]interface{}{
                                                "model_name":    modelName,
                                                "model_params":  modelParams,
                                                "model_version": "latest",
                                        },
                                },
                        },
                        "input_params": map[string]interface{}{},
                        "stream":       true, // Enable streaming
                }

                inferenceURL = fmt.Sprintf("%s/completion", targetDeployment.DeploymentURL)</span>
        } else<span class="cov6" title="9"> if isGPTModel </span><span class="cov5" title="6">{
                // Build messages array
                messages := make([]map[string]interface{}, 0)
                for _, msg := range req.Messages </span><span class="cov9" title="36">{
                        message := map[string]interface{}{
                                "role": msg.Role,
                        }

                        if contentArr, ok := msg.Content.([]interface{}); ok </span><span class="cov1" title="1">{
                                message["content"] = contentArr
                        }</span> else<span class="cov9" title="35"> {
                                message["content"] = msg.Content
                        }</span>

                        <span class="cov9" title="36">messages = append(messages, message)</span>
                }

                <span class="cov5" title="6">inferencePayload = map[string]interface{}{
                        "messages": messages,
                        "stream":   true, // Enable streaming
                }

                apiVersion := getGPTAPIVersion(modelName)
                isReasoningModel := strings.Contains(strings.ToLower(modelName), "o1") ||
                        strings.Contains(strings.ToLower(modelName), "o3-mini") ||
                        strings.Contains(strings.ToLower(modelName), "gpt-5")

                if !isReasoningModel </span><span class="cov4" title="5">{
                        if req.MaxTokens &gt; 0 </span><span class="cov1" title="1">{
                                inferencePayload["max_tokens"] = req.MaxTokens
                        }</span> else<span class="cov4" title="4"> {
                                inferencePayload["max_tokens"] = 1000
                        }</span>
                        <span class="cov4" title="5">if req.Temperature &gt; 0 </span><span class="cov1" title="1">{
                                inferencePayload["temperature"] = req.Temperature
                        }</span> else<span class="cov4" title="4"> {
                                inferencePayload["temperature"] = 0.7
                        }</span>
                        <span class="cov4" title="5">if req.TopP &gt; 0 </span><span class="cov1" title="1">{
                                inferencePayload["top_p"] = req.TopP
                        }</span>
                }

                <span class="cov5" title="6">inferenceURL = fmt.Sprintf("%s/chat/completions?api-version=%s", targetDeployment.DeploymentURL, apiVersion)</span>
        } else<span class="cov3" title="3"> {
                // Anthropic Claude models (default if not GPT, Gemini, or Orchestration)
                var systemPrompt string
                var userMessages []map[string]string

                for _, msg := range req.Messages </span><span class="cov5" title="6">{
                        if msg.Role == "system" </span><span class="cov1" title="1">{
                                systemPrompt = getMessageText(msg)
                        }</span> else<span class="cov4" title="5"> {
                                userMessages = append(userMessages, map[string]string{
                                        "role":    msg.Role,
                                        "content": getMessageText(msg),
                                })
                        }</span>
                }

                <span class="cov3" title="3">inferencePayload = map[string]interface{}{
                        "anthropic_version": "bedrock-2023-05-31",
                        "messages":          userMessages,
                }

                if systemPrompt != "" </span><span class="cov1" title="1">{
                        inferencePayload["system"] = systemPrompt
                }</span>

                <span class="cov3" title="3">if req.MaxTokens &gt; 0 </span><span class="cov1" title="1">{
                        inferencePayload["max_tokens"] = req.MaxTokens
                }</span> else<span class="cov2" title="2"> {
                        inferencePayload["max_tokens"] = 1000
                }</span>
                <span class="cov3" title="3">if req.Temperature &gt; 0 </span><span class="cov1" title="1">{
                        inferencePayload["temperature"] = req.Temperature
                }</span> else<span class="cov2" title="2"> {
                        inferencePayload["temperature"] = 0.7
                }</span>
                <span class="cov3" title="3">if req.TopP &gt; 0 </span><span class="cov1" title="1">{
                        inferencePayload["top_p"] = req.TopP
                }</span>

                // SAP AI Core Claude streaming uses invoke-with-response-stream endpoint
                <span class="cov3" title="3">inferenceURL = fmt.Sprintf("%s/invoke-with-response-stream", targetDeployment.DeploymentURL)</span>
        }

        // Make the streaming request
        <span class="cov7" title="12">resp, err := s.makeAICoreRequest("POST", inferenceURL, accessToken, credentials.ResourceGroup, inferencePayload)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to make inference request: %w", err)
        }</span>
        <span class="cov6" title="11">defer resp.Body.Close()

        if resp.StatusCode != 200 </span><span class="cov1" title="1">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("inference request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        // Stream the response using SSE
        <span class="cov6" title="10">flusher, ok := writer.(http.Flusher)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("streaming not supported")
        }</span>

        <span class="cov6" title="10">log := logger.FromGinContext(c)

        // Read the streaming response line by line
        reader := bufio.NewReader(resp.Body)
        for </span><span class="cov10" title="41">{
                line, err := reader.ReadBytes('\n')
                if err != nil </span><span class="cov1" title="1">{
                        if err == io.EOF </span><span class="cov1" title="1">{
                                // Send a final [DONE] message
                                writer.Write([]byte("data: [DONE]\n\n"))
                                flusher.Flush()
                                break</span>
                        }
                        <span class="cov0" title="0">log.Errorf("Error reading stream: %v", err)
                        return fmt.Errorf("error reading stream: %w", err)</span>
                }

                <span class="cov9" title="40">line = bytes.TrimSpace(line)
                if len(line) == 0 </span><span class="cov7" title="14">{
                        continue</span>
                }

                // SSE format: "data: {...}"
                <span class="cov8" title="26">if bytes.HasPrefix(line, []byte("data: ")) </span><span class="cov8" title="23">{
                        data := bytes.TrimPrefix(line, []byte("data: "))

                        // Check for [DONE] marker
                        if bytes.Equal(data, []byte("[DONE]")) </span><span class="cov6" title="9">{
                                writer.Write([]byte("data: [DONE]\n\n"))
                                flusher.Flush()
                                break</span>
                        }

                        // Parse the chunk
                        <span class="cov7" title="14">var chunk map[string]interface{}
                        if err := json.Unmarshal(data, &amp;chunk); err != nil </span><span class="cov0" title="0">{
                                log.Warnf("Failed to parse chunk: %v", err)
                                continue</span>
                        }

                        // Convert Gemini format to OpenAI format if needed
                        <span class="cov7" title="14">if isGeminiModel </span><span class="cov2" title="2">{
                                // Gemini streaming response format:
                                // {"candidates": [{"content": {"parts": [{"text": "..."}]}}]}
                                if candidates, ok := chunk["candidates"].([]interface{}); ok &amp;&amp; len(candidates) &gt; 0 </span><span class="cov2" title="2">{
                                        if candidate, ok := candidates[0].(map[string]interface{}); ok </span><span class="cov2" title="2">{
                                                if content, ok := candidate["content"].(map[string]interface{}); ok </span><span class="cov2" title="2">{
                                                        if parts, ok := content["parts"].([]interface{}); ok &amp;&amp; len(parts) &gt; 0 </span><span class="cov2" title="2">{
                                                                if part, ok := parts[0].(map[string]interface{}); ok </span><span class="cov2" title="2">{
                                                                        if text, ok := part["text"].(string); ok </span><span class="cov2" title="2">{
                                                                                // Convert to OpenAI streaming format
                                                                                openAIChunk := map[string]interface{}{
                                                                                        "id":      fmt.Sprintf("gemini-%d", time.Now().UnixNano()),
                                                                                        "object":  "chat.completion.chunk",
                                                                                        "created": time.Now().Unix(),
                                                                                        "model":   modelName,
                                                                                        "choices": []map[string]interface{}{
                                                                                                {
                                                                                                        "index": 0,
                                                                                                        "delta": map[string]interface{}{
                                                                                                                "content": text,
                                                                                                        },
                                                                                                        "finish_reason": nil,
                                                                                                },
                                                                                        },
                                                                                }

                                                                                // Check for finish reason
                                                                                if finishReason, ok := candidate["finishReason"].(string); ok &amp;&amp; finishReason != "" </span><span class="cov0" title="0">{
                                                                                        openAIChunk["choices"].([]map[string]interface{})[0]["finish_reason"] = strings.ToLower(finishReason)
                                                                                }</span>

                                                                                <span class="cov2" title="2">convertedData, _ := json.Marshal(openAIChunk)
                                                                                writer.Write([]byte(fmt.Sprintf("data: %s\n\n", convertedData)))
                                                                                flusher.Flush()
                                                                                continue</span>
                                                                        }
                                                                }
                                                        }
                                                }
                                        }
                                }
                        }

                        // Forward the chunk as-is (OpenAI/Anthropic/Orchestration format)
                        <span class="cov7" title="12">writer.Write([]byte(fmt.Sprintf("data: %s\n\n", data)))
                        flusher.Flush()</span>
                }
        }

        <span class="cov6" title="10">return nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package service

import (
        "developer-portal-backend/internal/client"
        apperrors "developer-portal-backend/internal/errors"
)

// AlertHistoryService wraps the alert history API client
type AlertHistoryService struct {
        client *client.AlertHistoryClient
}

// NewAlertHistoryService creates a new alert history service
func NewAlertHistoryService(client *client.AlertHistoryClient) *AlertHistoryService <span class="cov0" title="0">{
        return &amp;AlertHistoryService{
                client: client,
        }
}</span>

// GetAvailableProjects retrieves all available projects
func (s *AlertHistoryService) GetAvailableProjects() (*client.ProjectsResponse, error) <span class="cov0" title="0">{
        return s.client.GetAvailableProjects()
}</span>

// GetAlertsByProject retrieves alerts for a specific project with filters
func (s *AlertHistoryService) GetAlertsByProject(project string, filters map[string]string) (*client.AlertHistoryPaginatedResponse, error) <span class="cov0" title="0">{
        if project == "" </span><span class="cov0" title="0">{
                return nil, apperrors.ErrMissingProject
        }</span>

        <span class="cov0" title="0">return s.client.GetAlertsByProject(project, filters)</span>
}

// GetAlertByFingerprint retrieves a specific alert by fingerprint
func (s *AlertHistoryService) GetAlertByFingerprint(project, fingerprint string) (*client.AlertHistoryResponse, error) <span class="cov0" title="0">{
        if project == "" </span><span class="cov0" title="0">{
                return nil, apperrors.ErrMissingProject
        }</span>
        <span class="cov0" title="0">if fingerprint == "" </span><span class="cov0" title="0">{
                return nil, apperrors.ErrMissingFingerprint
        }</span>

        <span class="cov0" title="0">return s.client.GetAlertByFingerprint(project, fingerprint)</span>
}

// UpdateAlertLabel updates or adds a label to an alert
func (s *AlertHistoryService) UpdateAlertLabel(project, fingerprint, key, value string) (*client.UpdateLabelResponse, error) <span class="cov0" title="0">{
        if project == "" </span><span class="cov0" title="0">{
                return nil, apperrors.ErrMissingProject
        }</span>
        <span class="cov0" title="0">if fingerprint == "" </span><span class="cov0" title="0">{
                return nil, apperrors.ErrMissingFingerprint
        }</span>
        <span class="cov0" title="0">if key == "" </span><span class="cov0" title="0">{
                return nil, apperrors.ErrMissingLabelKey
        }</span>

        <span class="cov0" title="0">request := client.UpdateLabelRequest{
                Key:   key,
                Value: value,
        }

        return s.client.UpdateAlertLabel(project, fingerprint, request)</span>
}

// GetAlertFilters retrieves available filter values for alerts in a specific project
func (s *AlertHistoryService) GetAlertFilters(project string, filters map[string]string) (*client.AlertFiltersResponse, error) <span class="cov0" title="0">{
        if project == "" </span><span class="cov0" title="0">{
                return nil, apperrors.ErrMissingProject
        }</span>

        <span class="cov0" title="0">return s.client.GetAlertFilters(project, filters)</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package service

import (
        "context"
        apperrors "developer-portal-backend/internal/errors"
        "developer-portal-backend/internal/repository"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "regexp"
        "strings"
        "time"

        "gopkg.in/yaml.v3"
)

type AlertsService struct {
        projectRepo repository.ProjectRepositoryInterface
        authService GitHubAuthService
}

func NewAlertsService(projectRepo repository.ProjectRepositoryInterface, authService GitHubAuthService) *AlertsService <span class="cov0" title="0">{
        return &amp;AlertsService{
                projectRepo: projectRepo,
                authService: authService,
        }
}</span>

type AlertFile struct {
        Name     string                   `json:"name"`
        Path     string                   `json:"path"`
        Content  string                   `json:"content"`
        Category string                   `json:"category"`
        Alerts   []map[string]interface{} `json:"alerts"`
}

type AlertsResponse struct {
        Files []AlertFile `json:"files"`
}

// GetProjectAlerts fetches alerts from the project's GitHub alerts repository
func (s *AlertsService) GetProjectAlerts(ctx context.Context, projectIDStr, userUUID, provider string) (*AlertsResponse, error) <span class="cov0" title="0">{

        // Get GitHub access token from claims
        accessToken, err := s.authService.GetGitHubAccessToken(userUUID, provider)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get GitHub access token: %w", err)
        }</span>

        // Get project by name (projectIDStr is actually the project name like "cis20")
        <span class="cov0" title="0">project, err := s.projectRepo.GetByName(projectIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrProjectNotFound
        }</span>

        // Parse metadata to get alerts-repo URL
        <span class="cov0" title="0">var metadata map[string]interface{}
        if err := json.Unmarshal(project.Metadata, &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse project metadata")
        }</span>

        <span class="cov0" title="0">alertsRepo := ""
        if repo, ok := metadata["alerts"].(string); ok &amp;&amp; repo != "" </span><span class="cov0" title="0">{
                alertsRepo = repo
        }</span>

        <span class="cov0" title="0">if alertsRepo == "" </span><span class="cov0" title="0">{
                return nil, apperrors.ErrAlertsRepositoryNotConfigured
        }</span>

        // Parse GitHub URL
        // Example: https://github.tools.sap/btp-monitoring/monitoring-configs/tree/main/charts/monitoring-configs/templates/alerts
        <span class="cov0" title="0">repoInfo, err := parseAlertsGitHubURL(alertsRepo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid alerts repository URL: %w", err)
        }</span>

        // Fetch files from GitHub API
        <span class="cov0" title="0">files, err := fetchAlertFiles(repoInfo, accessToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch alert files: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;AlertsResponse{
                Files: files,
        }, nil</span>
}

// CreateAlertPR creates a pull request with alert changes
func (s *AlertsService) CreateAlertPR(ctx context.Context, projectIDStr, userUUID, provider string, fileName, content, message, description string) (string, error) <span class="cov0" title="0">{
        // Get GitHub access token from claims
        accessToken, err := s.authService.GetGitHubAccessToken(userUUID, provider)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get GitHub access token: %w", err)
        }</span>

        // Get project by name (projectIDStr is actually the project name like "cis20")
        <span class="cov0" title="0">project, err := s.projectRepo.GetByName(projectIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return "", apperrors.ErrProjectNotFound
        }</span>

        // Parse metadata to get alerts-repo URL
        <span class="cov0" title="0">var metadata map[string]interface{}
        if err := json.Unmarshal(project.Metadata, &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return "", errors.New("failed to parse project metadata")
        }</span>

        <span class="cov0" title="0">alertsRepo, ok := metadata["alerts"].(string)
        if !ok || alertsRepo == "" </span><span class="cov0" title="0">{
                return "", apperrors.ErrAlertsRepositoryNotConfigured
        }</span>

        // Parse GitHub URL
        <span class="cov0" title="0">repoInfo, err := parseAlertsGitHubURL(alertsRepo)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid alerts repository URL: %w", err)
        }</span>

        // Create PR via GitHub API
        <span class="cov0" title="0">prURL, err := createGitHubPR(repoInfo, fileName, content, message, description, accessToken)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create pull request: %w", err)
        }</span>

        <span class="cov0" title="0">return prURL, nil</span>
}

// Helper types and functions

type GitHubRepoInfo struct {
        BaseURL string
        Owner   string
        Repo    string
        Branch  string
        Path    string
}

func parseAlertsGitHubURL(url string) (*GitHubRepoInfo, error) <span class="cov0" title="0">{
        // Match pattern: https://github.tools.sap/owner/repo/tree/branch/path
        re := regexp.MustCompile(`https://([^/]+)/([^/]+)/([^/]+)/tree/([^/]+)/(.+)`)
        matches := re.FindStringSubmatch(url)
        if len(matches) != 6 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid GitHub URL format")
        }</span>

        <span class="cov0" title="0">return &amp;GitHubRepoInfo{
                BaseURL: fmt.Sprintf("https://%s", matches[1]),
                Owner:   matches[2],
                Repo:    matches[3],
                Branch:  matches[4],
                Path:    matches[5],
        }, nil</span>
}

func fetchAlertFiles(repoInfo *GitHubRepoInfo, token string) ([]AlertFile, error) <span class="cov0" title="0">{

        // GitHub API URL to list directory contents
        apiURL := fmt.Sprintf("%s/api/v3/repos/%s/%s/contents/%s?ref=%s",
                repoInfo.BaseURL, repoInfo.Owner, repoInfo.Repo, repoInfo.Path, repoInfo.Branch)

        // Log the API URL for debugging

        req, err := http.NewRequest("GET", apiURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if token != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", fmt.Sprintf("token %s", token))
        }</span>
        <span class="cov0" title="0">req.Header.Set("Accept", "application/vnd.github.v3+json")

        client := &amp;http.Client{Timeout: 30 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("GitHub API returned status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var githubFiles []struct {
                Name        string `json:"name"`
                Path        string `json:"path"`
                Type        string `json:"type"`
                DownloadURL string `json:"download_url"`
                Content     string `json:"content"`
                Encoding    string `json:"encoding"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;githubFiles); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var alertFiles []AlertFile
        for _, file := range githubFiles </span><span class="cov0" title="0">{

                // Only process YAML files
                if file.Type != "file" || (!strings.HasSuffix(file.Name, ".yaml") &amp;&amp; !strings.HasSuffix(file.Name, ".yml")) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Fetch file content
                <span class="cov0" title="0">var content string
                if file.Content != "" &amp;&amp; file.Encoding == "base64" </span><span class="cov0" title="0">{
                        decoded, err := base64.StdEncoding.DecodeString(file.Content)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">content = string(decoded)</span>
                } else<span class="cov0" title="0"> if file.DownloadURL != "" </span><span class="cov0" title="0">{
                        fetchedContent, err := fetchFileContent(file.DownloadURL, token)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">content = fetchedContent</span>
                } else<span class="cov0" title="0"> {
                        continue</span>
                }

                // Extract category from filename (e.g., "cis-db-alerts.yaml" -&gt; "DB")
                <span class="cov0" title="0">category := extractCategory(file.Name)

                // Try to parse YAML to extract alerts, but if it fails (e.g., Helm templates),
                // try text-based extraction for displaying purposes
                var alerts []map[string]interface{}
                var yamlData map[string]interface{}
                if err := yaml.Unmarshal([]byte(content), &amp;yamlData); err != nil </span><span class="cov0" title="0">{
                        // Try text-based extraction for Helm templates
                        alerts = extractAlertsFromText(content)
                }</span> else<span class="cov0" title="0"> {
                        // Extract alerts from YAML structure
                        alerts = extractAlerts(yamlData)
                }</span>

                <span class="cov0" title="0">alertFiles = append(alertFiles, AlertFile{
                        Name:     file.Name,
                        Path:     file.Path,
                        Content:  content,
                        Category: category,
                        Alerts:   alerts,
                })</span>
        }

        <span class="cov0" title="0">return alertFiles, nil</span>
}

func fetchFileContent(url, token string) (string, error) <span class="cov0" title="0">{
        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if token != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", fmt.Sprintf("token %s", token))
        }</span>

        <span class="cov0" title="0">client := &amp;http.Client{Timeout: 30 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return string(body), nil</span>
}

func extractCategory(filename string) string <span class="cov0" title="0">{
        // Remove extension
        name := strings.TrimSuffix(filename, ".yaml")
        name = strings.TrimSuffix(name, ".yml")

        // Extract category from pattern like "cis-db-alerts" -&gt; "DB"
        parts := strings.Split(name, "-")
        if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                // Return the middle part capitalized
                category := strings.ToUpper(parts[1])
                return category
        }</span>

        <span class="cov0" title="0">return "General"</span>
}

func extractAlerts(yamlData map[string]interface{}) []map[string]interface{} <span class="cov0" title="0">{
        var alerts []map[string]interface{}

        // Navigate through common Prometheus/Kubernetes alert structures
        // Try different paths: spec.groups[].rules[], groups[].rules[], rules[]
        if spec, ok := yamlData["spec"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if groups, ok := spec["groups"].([]interface{}); ok </span><span class="cov0" title="0">{
                        alerts = extractFromGroups(groups)
                }</span>
        } else<span class="cov0" title="0"> if groups, ok := yamlData["groups"].([]interface{}); ok </span><span class="cov0" title="0">{
                alerts = extractFromGroups(groups)
        }</span> else<span class="cov0" title="0"> if rules, ok := yamlData["rules"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, rule := range rules </span><span class="cov0" title="0">{
                        if ruleMap, ok := rule.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                alerts = append(alerts, ruleMap)
                        }</span>
                }
        }

        <span class="cov0" title="0">return alerts</span>
}

func extractFromGroups(groups []interface{}) []map[string]interface{} <span class="cov0" title="0">{
        var alerts []map[string]interface{}
        for _, group := range groups </span><span class="cov0" title="0">{
                if groupMap, ok := group.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if rules, ok := groupMap["rules"].([]interface{}); ok </span><span class="cov0" title="0">{
                                for _, rule := range rules </span><span class="cov0" title="0">{
                                        if ruleMap, ok := rule.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                // Add group name to alert for context
                                                if groupName, ok := groupMap["name"].(string); ok </span><span class="cov0" title="0">{
                                                        ruleMap["_group"] = groupName
                                                }</span>
                                                <span class="cov0" title="0">alerts = append(alerts, ruleMap)</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov0" title="0">return alerts</span>
}

func createGitHubPR(repoInfo *GitHubRepoInfo, fileName, content, message, description, token string) (string, error) <span class="cov0" title="0">{
        client := &amp;http.Client{Timeout: 30 * time.Second}

        // Generate unique branch name
        branchName := fmt.Sprintf("alert-update-%d", time.Now().Unix())
        filePath := fmt.Sprintf("%s/%s", repoInfo.Path, fileName)

        // Step 1: Get the base branch ref (SHA of the latest commit on main/master)
        refURL := fmt.Sprintf("%s/api/v3/repos/%s/%s/git/ref/heads/%s",
                repoInfo.BaseURL, repoInfo.Owner, repoInfo.Repo, repoInfo.Branch)

        req, err := http.NewRequest("GET", refURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create ref request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", fmt.Sprintf("token %s", token))
        req.Header.Set("Accept", "application/vnd.github.v3+json")

        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get base ref: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return "", fmt.Errorf("failed to get base ref, status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var refData struct {
                Object struct {
                        SHA string `json:"sha"`
                } `json:"object"`
        }
        if err := json.NewDecoder(resp.Body).Decode(&amp;refData); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode ref response: %w", err)
        }</span>

        <span class="cov0" title="0">baseSHA := refData.Object.SHA

        // Step 2: Create a new branch from the base
        createBranchURL := fmt.Sprintf("%s/api/v3/repos/%s/%s/git/refs",
                repoInfo.BaseURL, repoInfo.Owner, repoInfo.Repo)

        branchPayload := map[string]string{
                "ref": fmt.Sprintf("refs/heads/%s", branchName),
                "sha": baseSHA,
        }
        branchBody, _ := json.Marshal(branchPayload)

        req, err = http.NewRequest("POST", createBranchURL, strings.NewReader(string(branchBody)))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create branch request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", fmt.Sprintf("token %s", token))
        req.Header.Set("Accept", "application/vnd.github.v3+json")
        req.Header.Set("Content-Type", "application/json")

        resp, err = client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create branch: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return "", fmt.Errorf("failed to create branch, status %d: %s", resp.StatusCode, string(body))
        }</span>

        // Step 3: Get the current file to get its SHA
        <span class="cov0" title="0">getFileURL := fmt.Sprintf("%s/api/v3/repos/%s/%s/contents/%s?ref=%s",
                repoInfo.BaseURL, repoInfo.Owner, repoInfo.Repo, filePath, repoInfo.Branch)

        req, err = http.NewRequest("GET", getFileURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create get file request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", fmt.Sprintf("token %s", token))
        req.Header.Set("Accept", "application/vnd.github.v3+json")

        resp, err = client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get file: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return "", fmt.Errorf("failed to get file, status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var fileData struct {
                SHA string `json:"sha"`
        }
        if err := json.NewDecoder(resp.Body).Decode(&amp;fileData); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode file response: %w", err)
        }</span>

        <span class="cov0" title="0">fileSHA := fileData.SHA

        // Step 4: Update the file on the new branch
        updateFileURL := fmt.Sprintf("%s/api/v3/repos/%s/%s/contents/%s",
                repoInfo.BaseURL, repoInfo.Owner, repoInfo.Repo, filePath)

        // Base64 encode the content
        encodedContent := base64.StdEncoding.EncodeToString([]byte(content))

        updatePayload := map[string]interface{}{
                "message": message,
                "content": encodedContent,
                "sha":     fileSHA,
                "branch":  branchName,
        }
        updateBody, _ := json.Marshal(updatePayload)

        req, err = http.NewRequest("PUT", updateFileURL, strings.NewReader(string(updateBody)))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create update file request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", fmt.Sprintf("token %s", token))
        req.Header.Set("Accept", "application/vnd.github.v3+json")
        req.Header.Set("Content-Type", "application/json")

        resp, err = client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to update file: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return "", fmt.Errorf("failed to update file, status %d: %s", resp.StatusCode, string(body))
        }</span>

        // Step 5: Create pull request
        <span class="cov0" title="0">createPRURL := fmt.Sprintf("%s/api/v3/repos/%s/%s/pulls",
                repoInfo.BaseURL, repoInfo.Owner, repoInfo.Repo)

        prPayload := map[string]interface{}{
                "title": message,
                "body":  description,
                "head":  branchName,
                "base":  repoInfo.Branch,
        }
        prBody, _ := json.Marshal(prPayload)

        req, err = http.NewRequest("POST", createPRURL, strings.NewReader(string(prBody)))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create PR request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", fmt.Sprintf("token %s", token))
        req.Header.Set("Accept", "application/vnd.github.v3+json")
        req.Header.Set("Content-Type", "application/json")

        resp, err = client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create PR: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return "", fmt.Errorf("failed to create PR, status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var prData struct {
                HTMLURL string `json:"html_url"`
                Number  int    `json:"number"`
        }
        if err := json.NewDecoder(resp.Body).Decode(&amp;prData); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode PR response: %w", err)
        }</span>

        <span class="cov0" title="0">return prData.HTMLURL, nil</span>
}

// extractAlertsFromText extracts alert definitions from text content (for Helm templates)
// This is a simple regex-based parser that can handle templated YAML
func extractAlertsFromText(content string) []map[string]interface{} <span class="cov0" title="0">{
        var alerts []map[string]interface{}

        // Use regex to find alert definitions
        // Look for "- alert:" followed by the alert name
        alertPattern := regexp.MustCompile(`(?m)^\s*-\s*alert:\s*(.+?)$`)
        forPattern := regexp.MustCompile(`(?m)^\s*for:\s*(.+?)$`)

        matches := alertPattern.FindAllStringSubmatchIndex(content, -1)

        for i, match := range matches </span><span class="cov0" title="0">{
                alertStart := match[0]
                alertEnd := len(content)
                if i+1 &lt; len(matches) </span><span class="cov0" title="0">{
                        alertEnd = matches[i+1][0]
                }</span>

                <span class="cov0" title="0">alertSection := content[alertStart:alertEnd]
                alertName := strings.TrimSpace(content[match[2]:match[3]])

                alert := map[string]interface{}{
                        "alert": alertName,
                }

                // Extract expr - handle both single-line and multi-line (| or &gt;)
                expr := extractExpression(alertSection)
                if expr != "" </span><span class="cov0" title="0">{
                        alert["expr"] = expr
                }</span>

                // Extract 'for' duration
                <span class="cov0" title="0">if forMatch := forPattern.FindStringSubmatch(alertSection); len(forMatch) &gt; 1 </span><span class="cov0" title="0">{
                        alert["for"] = strings.TrimSpace(forMatch[1])
                }</span>

                // Extract ALL labels (not just severity)
                <span class="cov0" title="0">labels := extractLabelsFromSection(alertSection)
                if len(labels) &gt; 0 </span><span class="cov0" title="0">{
                        alert["labels"] = labels
                }</span>

                // Extract ALL annotations (not just summary)
                <span class="cov0" title="0">annotations := extractAnnotationsFromSection(alertSection)
                if len(annotations) &gt; 0 </span><span class="cov0" title="0">{
                        alert["annotations"] = annotations
                }</span>

                <span class="cov0" title="0">alerts = append(alerts, alert)</span>
        }

        <span class="cov0" title="0">return alerts</span>
}

// extractExpression extracts the expression from an alert section, handling multi-line YAML
func extractExpression(alertSection string) string <span class="cov0" title="0">{
        // First, try to find "expr:" line
        exprLinePattern := regexp.MustCompile(`(?m)^\s*expr:\s*(.*)$`)
        exprMatch := exprLinePattern.FindStringSubmatch(alertSection)

        if len(exprMatch) &lt; 2 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">exprLine := strings.TrimSpace(exprMatch[1])

        // If it's a multi-line block scalar (| or &gt;), we need to capture the indented lines that follow
        if exprLine == "|" || exprLine == "&gt;" || strings.HasPrefix(exprLine, "|-") || strings.HasPrefix(exprLine, "&gt;-") </span><span class="cov0" title="0">{
                // Find the position of "expr:" in the original section
                exprIndex := strings.Index(alertSection, exprMatch[0])
                if exprIndex == -1 </span><span class="cov0" title="0">{
                        return exprLine
                }</span>

                // Get everything after the "expr: |" line
                <span class="cov0" title="0">afterExpr := alertSection[exprIndex+len(exprMatch[0]):]

                // Extract indented lines that belong to the expression
                var exprLines []string
                lines := strings.Split(afterExpr, "\n")

                // Determine the base indentation (from the first non-empty line)
                var baseIndent int
                foundBase := false

                for _, line := range lines </span><span class="cov0" title="0">{
                        // Skip empty lines
                        if strings.TrimSpace(line) == "" </span><span class="cov0" title="0">{
                                if len(exprLines) &gt; 0 </span><span class="cov0" title="0">{
                                        // Add empty lines if we've already started collecting
                                        exprLines = append(exprLines, "")
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        // Count leading spaces
                        <span class="cov0" title="0">indent := len(line) - len(strings.TrimLeft(line, " \t"))

                        if !foundBase </span><span class="cov0" title="0">{
                                // This is the first line - set base indentation
                                baseIndent = indent
                                foundBase = true
                                exprLines = append(exprLines, strings.TrimSpace(line))
                        }</span> else<span class="cov0" title="0"> if indent &gt;= baseIndent </span><span class="cov0" title="0">{
                                // This line is part of the expression (same or more indentation)
                                exprLines = append(exprLines, strings.TrimSpace(line))
                        }</span> else<span class="cov0" title="0"> {
                                // Less indentation - we've reached the next field
                                break</span>
                        }
                }

                <span class="cov0" title="0">return strings.Join(exprLines, " ")</span>
        }

        // Single-line expression
        <span class="cov0" title="0">return exprLine</span>
}

// extractLabelsFromSection extracts all labels from an alert section
func extractLabelsFromSection(alertSection string) map[string]interface{} <span class="cov0" title="0">{
        labels := make(map[string]interface{})

        // Find the labels: section
        labelsPattern := regexp.MustCompile(`(?m)^\s*labels:\s*$`)
        labelsMatch := labelsPattern.FindStringIndex(alertSection)
        if labelsMatch == nil </span><span class="cov0" title="0">{
                return labels
        }</span>

        // Get everything after "labels:" until we hit another top-level field
        <span class="cov0" title="0">afterLabels := alertSection[labelsMatch[1]:]
        lines := strings.Split(afterLabels, "\n")

        // Extract individual label key-value pairs (indented under labels:)
        labelPattern := regexp.MustCompile(`^\s{4,}(\w+):\s*(.+?)\s*$`)

        for _, line := range lines </span><span class="cov0" title="0">{
                trimmedLine := strings.TrimSpace(line)

                // Stop at Helm directives or annotations section
                if strings.HasPrefix(trimmedLine, "{{-") || strings.HasPrefix(trimmedLine, "{{") || trimmedLine == "annotations:" </span><span class="cov0" title="0">{
                        break</span>
                }

                // Stop at next non-indented line (next section)
                <span class="cov0" title="0">if trimmedLine != "" &amp;&amp; !strings.HasPrefix(line, "    ") &amp;&amp; !strings.HasPrefix(line, "\t") </span><span class="cov0" title="0">{
                        break</span>
                }

                // Skip empty lines
                <span class="cov0" title="0">if trimmedLine == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">labelMatch := labelPattern.FindStringSubmatch(line)
                if len(labelMatch) &gt; 2 </span><span class="cov0" title="0">{
                        key := strings.TrimSpace(labelMatch[1])
                        value := strings.TrimSpace(labelMatch[2])
                        labels[key] = value
                }</span>
        }

        <span class="cov0" title="0">return labels</span>
}

// extractAnnotationsFromSection extracts all annotations from an alert section
func extractAnnotationsFromSection(alertSection string) map[string]interface{} <span class="cov0" title="0">{
        annotations := make(map[string]interface{})

        // Find the annotations: section
        annotationsPattern := regexp.MustCompile(`(?m)^\s*annotations:\s*$`)
        annotationsMatch := annotationsPattern.FindStringIndex(alertSection)
        if annotationsMatch == nil </span><span class="cov0" title="0">{
                return annotations
        }</span>

        // Get everything after "annotations:" until we hit another top-level field
        <span class="cov0" title="0">afterAnnotations := alertSection[annotationsMatch[1]:]
        lines := strings.Split(afterAnnotations, "\n")

        // Pattern to match annotation key with opening quote
        keyPattern := regexp.MustCompile(`^\s{4,}(\w+):\s*"(.*)`)

        i := 0
        for i &lt; len(lines) </span><span class="cov0" title="0">{
                line := lines[i]
                trimmedLine := strings.TrimSpace(line)

                // Stop at Helm directives or non-indented lines (next section)
                if strings.HasPrefix(trimmedLine, "{{-") || strings.HasPrefix(trimmedLine, "{{") </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if trimmedLine != "" &amp;&amp; !strings.HasPrefix(line, "    ") &amp;&amp; !strings.HasPrefix(line, "\t") </span><span class="cov0" title="0">{
                        break</span>
                }

                // Skip empty lines
                <span class="cov0" title="0">if trimmedLine == "" </span><span class="cov0" title="0">{
                        i++
                        continue</span>
                }

                // Try to match annotation key with quoted value
                <span class="cov0" title="0">keyMatch := keyPattern.FindStringSubmatch(line)
                if len(keyMatch) &gt; 2 </span><span class="cov0" title="0">{
                        key := strings.TrimSpace(keyMatch[1])
                        value := keyMatch[2]

                        // Check if the value ends with a closing quote on the same line
                        if strings.HasSuffix(value, "\"") </span><span class="cov0" title="0">{
                                // Single-line quoted value
                                value = strings.TrimSuffix(value, "\"")
                                annotations[key] = value
                                i++
                        }</span> else<span class="cov0" title="0"> {
                                // Multi-line quoted value - collect lines until closing quote
                                valueLines := []string{value}
                                i++

                                for i &lt; len(lines) </span><span class="cov0" title="0">{
                                        nextLine := lines[i]
                                        // Check if this line ends the quoted string
                                        if strings.Contains(nextLine, "\"") </span><span class="cov0" title="0">{
                                                // Find the closing quote
                                                quoteIndex := strings.Index(nextLine, "\"")
                                                valueLines = append(valueLines, strings.TrimSpace(nextLine[:quoteIndex]))
                                                i++
                                                break</span>
                                        }
                                        // Add this line to the value (it's part of the multi-line string)
                                        <span class="cov0" title="0">valueLines = append(valueLines, strings.TrimSpace(nextLine))
                                        i++</span>
                                }

                                // Join all lines with space (or newline if you want to preserve formatting)
                                <span class="cov0" title="0">annotations[key] = strings.Join(valueLines, " ")</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Try unquoted value pattern
                        unquotedPattern := regexp.MustCompile(`^\s{4,}(\w+):\s*(.+?)\s*$`)
                        unquotedMatch := unquotedPattern.FindStringSubmatch(line)
                        if len(unquotedMatch) &gt; 2 </span><span class="cov0" title="0">{
                                key := strings.TrimSpace(unquotedMatch[1])
                                value := strings.TrimSpace(unquotedMatch[2])
                                annotations[key] = value
                        }</span>
                        <span class="cov0" title="0">i++</span>
                }
        }

        <span class="cov0" title="0">return annotations</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package service

import (
        "fmt"

        "developer-portal-backend/internal/database/models"
        "developer-portal-backend/internal/repository"

        "github.com/go-playground/validator/v10"
        "github.com/google/uuid"
)

// CategoryService provides category-related business logic
type CategoryService struct {
        repo      repository.CategoryRepositoryInterface
        validator *validator.Validate
}

// Ensure CategoryService implements CategoryServiceInterface
var _ CategoryServiceInterface = (*CategoryService)(nil)

// NewCategoryService creates a new CategoryService
func NewCategoryService(repo repository.CategoryRepositoryInterface, validator *validator.Validate) *CategoryService <span class="cov10" title="4">{
        return &amp;CategoryService{
                repo:      repo,
                validator: validator,
        }
}</span>

// CategoryResponse represents a single category in API responses
type CategoryResponse struct {
        ID          uuid.UUID `json:"id"`
        Name        string    `json:"name"`
        Title       string    `json:"title"`
        Description string    `json:"description"`
        Icon        string    `json:"icon"`
        Color       string    `json:"color"`
}

// CategoryListResponse represents a paginated list of categories
type CategoryListResponse struct {
        Categories []CategoryResponse `json:"categories"`
        Total      int64              `json:"total"`
        Page       int                `json:"page"`
        PageSize   int                `json:"page_size"`
}

// GetAll retrieves categories with pagination
func (s *CategoryService) GetAll(page, pageSize int) (*CategoryListResponse, error) <span class="cov10" title="4">{
        if page &lt; 1 </span><span class="cov8" title="3">{
                page = 1
        }</span>
        <span class="cov10" title="4">if pageSize &lt; 1 || pageSize &gt; 1000 </span><span class="cov8" title="3">{
                // allow larger default to better match "return all categories" use-case
                pageSize = 1000
        }</span>

        <span class="cov10" title="4">offset := (page - 1) * pageSize
        cats, total, err := s.repo.GetAll(pageSize, offset)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get categories: %w", err)
        }</span>

        <span class="cov8" title="3">responses := make([]CategoryResponse, len(cats))
        for i, c := range cats </span><span class="cov8" title="3">{
                responses[i] = s.toResponse(&amp;c)
        }</span>

        <span class="cov8" title="3">return &amp;CategoryListResponse{
                Categories: responses,
                Total:      total,
                Page:       page,
                PageSize:   pageSize,
        }, nil</span>
}

// toResponse converts a Category model to API response
func (s *CategoryService) toResponse(cat *models.Category) CategoryResponse <span class="cov8" title="3">{
        return CategoryResponse{
                ID:          cat.ID,
                Name:        cat.Name,
                Title:       cat.Title,
                Description: cat.Description,
                Icon:        cat.Icon,
                Color:       cat.Color,
        }
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package service

import (
        "encoding/json"
        "errors"
        "fmt"

        "developer-portal-backend/internal/database/models"
        apperrors "developer-portal-backend/internal/errors"
        "developer-portal-backend/internal/repository"

        "github.com/go-playground/validator/v10"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

// ComponentService handles business logic for components
type ComponentService struct {
        repo             repository.ComponentRepositoryInterface
        organizationRepo repository.OrganizationRepositoryInterface
        projectRepo      repository.ProjectRepositoryInterface
        validator        *validator.Validate
}

// NewComponentService creates a new component service
func NewComponentService(repo repository.ComponentRepositoryInterface, orgRepo repository.OrganizationRepositoryInterface, projRepo repository.ProjectRepositoryInterface, validator *validator.Validate) *ComponentService <span class="cov0" title="0">{
        return &amp;ComponentService{
                repo:             repo,
                organizationRepo: orgRepo,
                projectRepo:      projRepo,
                validator:        validator,
        }
}</span>

// ComponentProjectView is a minimal view for /components?project-name=&lt;name&gt;
type ComponentProjectView struct {
        ID             uuid.UUID `json:"id"`
        OwnerID        uuid.UUID `json:"owner_id"`
        Name           string    `json:"name"`
        Title          string    `json:"title"`
        Description    string    `json:"description"`
        QOS            string    `json:"qos,omitempty"`
        Sonar          string    `json:"sonar,omitempty"`
        GitHub         string    `json:"github,omitempty"`
        CentralService *bool     `json:"central-service,omitempty"`
        IsLibrary      *bool     `json:"is-library,omitempty"`
        Health         *bool     `json:"health,omitempty"`
}

// GetByProjectNameAllView returns ALL components for a project (unpaginated) with a minimal view:
// - Omits project_id, created_at, updated_at, metadata
// - Adds fields: qos (metadata.ci.qos), sonar (metadata.sonar.project_id), github (metadata.github.url), central-service (metadata["central-service"]), is-library (metadata["isLibrary"])
func (s *ComponentService) GetByProjectNameAllView(projectName string) ([]ComponentProjectView, error) <span class="cov0" title="0">{
        if projectName == "" </span><span class="cov0" title="0">{
                return []ComponentProjectView{}, nil
        }</span>
        <span class="cov0" title="0">project, err := s.projectRepo.GetByName(projectName)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, apperrors.ErrProjectNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to resolve project by name: %w", err)</span>
        }

        <span class="cov0" title="0">components, _, err := s.repo.GetComponentsByProjectID(project.ID, 1000000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get components by project: %w", err)
        }</span>

        <span class="cov0" title="0">views := make([]ComponentProjectView, len(components))
        for i, c := range components </span><span class="cov0" title="0">{
                views[i] = ComponentProjectView{
                        ID:          c.ID,
                        OwnerID:     c.OwnerID,
                        Name:        c.Name,
                        Title:       c.Title,
                        Description: c.Description,
                }

                // Extract qos, sonar, github, central-service, is-library, health from metadata if present
                if len(c.Metadata) &gt; 0 </span><span class="cov0" title="0">{
                        var meta map[string]interface{}
                        if err := json.Unmarshal(c.Metadata, &amp;meta); err == nil </span><span class="cov0" title="0">{
                                // qos from metadata.ci.qos
                                if ciRaw, ok := meta["ci"]; ok </span><span class="cov0" title="0">{
                                        if ciMap, ok := ciRaw.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                if qosRaw, ok := ciMap["qos"]; ok </span><span class="cov0" title="0">{
                                                        if qosStr, ok := qosRaw.(string); ok </span><span class="cov0" title="0">{
                                                                views[i].QOS = qosStr
                                                        }</span>
                                                }
                                        }
                                }
                                // sonar from metadata.sonar.project_id
                                <span class="cov0" title="0">if sonarRaw, ok := meta["sonar"]; ok </span><span class="cov0" title="0">{
                                        if sonarMap, ok := sonarRaw.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                if pidRaw, ok := sonarMap["project_id"]; ok </span><span class="cov0" title="0">{
                                                        if pidStr, ok := pidRaw.(string); ok </span><span class="cov0" title="0">{
                                                                views[i].Sonar = "https://sonar.tools.sap/dashboard?id=" + pidStr
                                                        }</span>
                                                }
                                        }
                                }
                                // github from metadata.github.url
                                <span class="cov0" title="0">if ghRaw, ok := meta["github"]; ok </span><span class="cov0" title="0">{
                                        if ghMap, ok := ghRaw.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                if urlRaw, ok := ghMap["url"]; ok </span><span class="cov0" title="0">{
                                                        if urlStr, ok := urlRaw.(string); ok </span><span class="cov0" title="0">{
                                                                views[i].GitHub = urlStr
                                                        }</span>
                                                }
                                        }
                                }
                                // central-service from metadata["central-service"]
                                <span class="cov0" title="0">if csRaw, ok := meta["central-service"]; ok </span><span class="cov0" title="0">{
                                        if csBool, ok := csRaw.(bool); ok </span><span class="cov0" title="0">{
                                                b := csBool
                                                views[i].CentralService = &amp;b
                                        }</span>
                                }
                                // is-library from metadata["isLibrary"] (mapped to is-library)
                                <span class="cov0" title="0">if ilRaw, ok := meta["isLibrary"]; ok </span><span class="cov0" title="0">{
                                        if ilBool, ok := ilRaw.(bool); ok </span><span class="cov0" title="0">{
                                                b := ilBool
                                                views[i].IsLibrary = &amp;b
                                        }</span>
                                }
                                // health from metadata["health"] (boolean)
                                <span class="cov0" title="0">if hRaw, ok := meta["health"]; ok </span><span class="cov0" title="0">{
                                        if hBool, ok := hRaw.(bool); ok </span><span class="cov0" title="0">{
                                                b := hBool
                                                views[i].Health = &amp;b
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return views, nil</span>
}

// GetProjectTitleByID returns the project's title by ID
func (s *ComponentService) GetProjectTitleByID(id uuid.UUID) (string, error) <span class="cov0" title="0">{
        project, err := s.projectRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return "", apperrors.ErrProjectNotFound
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("failed to get project: %w", err)</span>
        }
        <span class="cov0" title="0">return project.Title, nil</span>
}

// GetByID returns a component by its ID
func (s *ComponentService) GetByID(id uuid.UUID) (*models.Component, error) <span class="cov0" title="0">{
        component, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, apperrors.ErrComponentNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get component: %w", err)</span>
        }
        <span class="cov0" title="0">return component, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package service

import (
        "fmt"
        "net/url"
        "strings"

        "developer-portal-backend/internal/database/models"
        "developer-portal-backend/internal/repository"

        "github.com/go-playground/validator/v10"
        "github.com/google/uuid"
)

// DocumentationService provides documentation-related business logic
type DocumentationService struct {
        docRepo   repository.DocumentationRepositoryInterface
        teamRepo  repository.TeamRepositoryInterface
        validator *validator.Validate
}

// Ensure DocumentationService implements DocumentationServiceInterface
var _ DocumentationServiceInterface = (*DocumentationService)(nil)

// NewDocumentationService creates a new DocumentationService
func NewDocumentationService(
        docRepo repository.DocumentationRepositoryInterface,
        teamRepo repository.TeamRepositoryInterface,
        validator *validator.Validate,
) *DocumentationService <span class="cov10" title="42">{
        return &amp;DocumentationService{
                docRepo:   docRepo,
                teamRepo:  teamRepo,
                validator: validator,
        }
}</span>

// DocumentationResponse represents a documentation in API responses
type DocumentationResponse struct {
        ID          string `json:"id"`
        TeamID      string `json:"team_id"`
        Owner       string `json:"owner"`
        Repo        string `json:"repo"`
        Branch      string `json:"branch"`
        DocsPath    string `json:"docs_path"`
        Title       string `json:"title"`
        Description string `json:"description"`
        CreatedAt   string `json:"created_at"`
        CreatedBy   string `json:"created_by"`
        UpdatedAt   string `json:"updated_at"`
        UpdatedBy   string `json:"updated_by"`
}

// CreateDocumentationRequest represents the payload for creating a documentation
type CreateDocumentationRequest struct {
        TeamID      string `json:"team_id" validate:"required,uuid4"`
        URL         string `json:"url" validate:"required,url,max=1000"` // Full GitHub URL
        Title       string `json:"title" validate:"required,min=1,max=100"`
        Description string `json:"description" validate:"max=200"`
        CreatedBy   string `json:"-"` // derived from bearer token
}

// UpdateDocumentationRequest represents the payload for updating a documentation
type UpdateDocumentationRequest struct {
        URL         *string `json:"url" validate:"omitempty,url,max=1000"`
        Title       *string `json:"title" validate:"omitempty,min=1,max=100"`
        Description *string `json:"description" validate:"omitempty,max=200"`
        UpdatedBy   string  `json:"-"` // derived from bearer token
}

// CreateDocumentation validates and creates a new documentation
func (s *DocumentationService) CreateDocumentation(req *CreateDocumentationRequest) (*DocumentationResponse, error) <span class="cov8" title="23">{
        if err := s.validator.Struct(req); err != nil </span><span class="cov6" title="9">{
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov7" title="14">if strings.TrimSpace(req.CreatedBy) == "" </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("created_by is required")
        }</span>

        <span class="cov6" title="12">teamID, err := uuid.Parse(req.TeamID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid team_id UUID: %w", err)
        }</span>

        // Validate team exists
        <span class="cov6" title="12">team, err := s.teamRepo.GetByID(teamID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("team not found: %w", err)
        }</span>

        // Parse and validate GitHub URL
        <span class="cov6" title="11">owner, repo, branch, docsPath, err := parseGitHubURL(req.URL)
        if err != nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("invalid GitHub URL: %w", err)
        }</span>

        <span class="cov6" title="8">doc := &amp;models.Documentation{
                TeamID:      team.ID,
                Owner:       owner,
                Repo:        repo,
                Branch:      branch,
                DocsPath:    docsPath,
                Title:       req.Title,
                Description: req.Description,
                CreatedBy:   req.CreatedBy,
        }

        if err := s.docRepo.Create(doc); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to create documentation: %w", err)
        }</span>

        <span class="cov5" title="7">return toDocumentationResponse(doc), nil</span>
}

// GetDocumentationByID retrieves a documentation by ID
func (s *DocumentationService) GetDocumentationByID(id uuid.UUID) (*DocumentationResponse, error) <span class="cov3" title="3">{
        doc, err := s.docRepo.GetByID(id)
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("documentation not found: %w", err)
        }</span>
        <span class="cov1" title="1">return toDocumentationResponse(doc), nil</span>
}

// GetDocumentationsByTeamID retrieves all documentations for a team
func (s *DocumentationService) GetDocumentationsByTeamID(teamID uuid.UUID) ([]DocumentationResponse, error) <span class="cov4" title="4">{
        // Validate team exists
        if _, err := s.teamRepo.GetByID(teamID); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("team not found: %w", err)
        }</span>

        <span class="cov3" title="3">docs, err := s.docRepo.GetByTeamID(teamID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get documentations: %w", err)
        }</span>

        <span class="cov2" title="2">responses := make([]DocumentationResponse, 0, len(docs))
        for i := range docs </span><span class="cov2" title="2">{
                responses = append(responses, *toDocumentationResponse(&amp;docs[i]))
        }</span>

        <span class="cov2" title="2">return responses, nil</span>
}

// UpdateDocumentation updates an existing documentation
func (s *DocumentationService) UpdateDocumentation(id uuid.UUID, req *UpdateDocumentationRequest) (*DocumentationResponse, error) <span class="cov7" title="13">{
        if err := s.validator.Struct(req); err != nil </span><span class="cov4" title="5">{
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov6" title="8">if strings.TrimSpace(req.UpdatedBy) == "" </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("updated_by is required")
        }</span>

        // Get existing documentation
        <span class="cov5" title="6">doc, err := s.docRepo.GetByID(id)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("documentation not found: %w", err)
        }</span>

        // Update fields if provided
        <span class="cov4" title="5">if req.URL != nil &amp;&amp; *req.URL != "" </span><span class="cov3" title="3">{
                owner, repo, branch, docsPath, err := parseGitHubURL(*req.URL)
                if err != nil </span><span class="cov2" title="2">{
                        return nil, fmt.Errorf("invalid GitHub URL: %w", err)
                }</span>
                <span class="cov1" title="1">doc.Owner = owner
                doc.Repo = repo
                doc.Branch = branch
                doc.DocsPath = docsPath</span>
        }

        <span class="cov3" title="3">if req.Title != nil </span><span class="cov3" title="3">{
                doc.Title = *req.Title
        }</span>

        <span class="cov3" title="3">if req.Description != nil </span><span class="cov1" title="1">{
                doc.Description = *req.Description
        }</span>

        <span class="cov3" title="3">doc.UpdatedBy = req.UpdatedBy

        if err := s.docRepo.Update(doc); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to update documentation: %w", err)
        }</span>

        <span class="cov2" title="2">return toDocumentationResponse(doc), nil</span>
}

// DeleteDocumentation deletes a documentation by ID
func (s *DocumentationService) DeleteDocumentation(id uuid.UUID) error <span class="cov3" title="3">{
        // Check if documentation exists
        if _, err := s.docRepo.GetByID(id); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("documentation not found: %w", err)
        }</span>

        <span class="cov2" title="2">if err := s.docRepo.Delete(id); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to delete documentation: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// parseGitHubURL parses a GitHub URL and extracts owner, repo, branch, and docs path
// Supports two formats:
// 1. Full path: https://github.tools.sap/{owner}/{repo}/tree/{branch}/{path}
// 2. Repository root: https://github.tools.sap/{owner}/{repo} (defaults to main branch and root path)
// Example: https://github.tools.sap/cfs-platform-engineering/cfs-platform-docs/tree/main/docs/coe
// Example: https://github.tools.sap/cfs-platform-engineering/developer-portal-frontend
func parseGitHubURL(urlStr string) (owner, repo, branch, docsPath string, err error) <span class="cov7" title="14">{
        // Parse URL
        u, err := url.Parse(urlStr)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", "", "", fmt.Errorf("invalid URL format: %w", err)
        }</span>

        // Validate host (support both github.tools.sap and github.com)
        <span class="cov7" title="14">if u.Host != "github.tools.sap" &amp;&amp; u.Host != "github.com" </span><span class="cov2" title="2">{
                return "", "", "", "", fmt.Errorf("invalid GitHub host: %s (expected github.tools.sap or github.com)", u.Host)
        }</span>

        // Parse path
        <span class="cov6" title="12">parts := strings.Split(strings.Trim(u.Path, "/"), "/")
        if len(parts) &lt; 2 </span><span class="cov1" title="1">{
                return "", "", "", "", fmt.Errorf("invalid GitHub URL format: expected at least /{owner}/{repo}")
        }</span>

        <span class="cov6" title="11">owner = parts[0]
        repo = parts[1]

        // Check if this is a repository root URL (just /{owner}/{repo})
        if len(parts) == 2 </span><span class="cov4" title="4">{
                // Default to main branch and root path for repository root URLs
                branch = "main"
                docsPath = "/"
        }</span> else<span class="cov5" title="7"> if len(parts) &gt;= 5 </span><span class="cov5" title="6">{
                // Full path format: /{owner}/{repo}/tree/{branch}/{docs_path}
                if parts[2] != "tree" &amp;&amp; parts[2] != "blob" </span><span class="cov1" title="1">{
                        return "", "", "", "", fmt.Errorf("invalid GitHub URL format: expected /tree/ or /blob/ in URL")
                }</span>
                <span class="cov4" title="5">branch = parts[3]
                docsPath = strings.Join(parts[4:], "/")</span>
        } else<span class="cov1" title="1"> {
                return "", "", "", "", fmt.Errorf("invalid GitHub URL format: expected /{owner}/{repo} or /{owner}/{repo}/tree/{branch}/{path}")
        }</span>

        <span class="cov6" title="9">if owner == "" || repo == "" || branch == "" </span><span class="cov0" title="0">{
                return "", "", "", "", fmt.Errorf("incomplete GitHub URL: missing owner, repo, or branch")
        }</span>

        <span class="cov6" title="9">return owner, repo, branch, docsPath, nil</span>
}

// toDocumentationResponse converts a Documentation model to DocumentationResponse
func toDocumentationResponse(doc *models.Documentation) *DocumentationResponse <span class="cov6" title="12">{
        return &amp;DocumentationResponse{
                ID:          doc.ID.String(),
                TeamID:      doc.TeamID.String(),
                Owner:       doc.Owner,
                Repo:        doc.Repo,
                Branch:      doc.Branch,
                DocsPath:    doc.DocsPath,
                Title:       doc.Title,
                Description: doc.Description,
                CreatedAt:   doc.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                CreatedBy:   doc.CreatedBy,
                UpdatedAt:   doc.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
                UpdatedBy:   doc.UpdatedBy,
        }
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package service

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "math"
        "net/http"
        "strconv"
        "strings"
        "time"

        "developer-portal-backend/internal/auth"
        apperrors "developer-portal-backend/internal/errors"
        "developer-portal-backend/internal/logger"

        "github.com/google/go-github/v57/github"
        "golang.org/x/oauth2"
)

// GitHubService provides methods to interact with GitHub API
type GitHubService struct {
        authService GitHubAuthService
}

// NewGitHubService creates a new GitHub service
func NewGitHubService(authService *auth.AuthService) *GitHubService <span class="cov4" title="5">{
        return &amp;GitHubService{
                authService: NewAuthServiceAdapter(authService),
        }
}</span>

// NewGitHubServiceWithAdapter creates a new GitHub service with a custom auth service adapter
// This constructor is primarily for testing with mock auth services
func NewGitHubServiceWithAdapter(authService GitHubAuthService) *GitHubService <span class="cov10" title="97">{
        return &amp;GitHubService{
                authService: authService,
        }
}</span>

// PullRequest represents a GitHub pull request
type PullRequest struct {
        ID        int64      `json:"id" example:"1234567890"`
        Number    int        `json:"number" example:"42"`
        Title     string     `json:"title" example:"Add new feature"`
        State     string     `json:"state" example:"open"`
        CreatedAt time.Time  `json:"created_at" example:"2025-01-01T12:00:00Z"`
        UpdatedAt time.Time  `json:"updated_at" example:"2025-01-02T12:00:00Z"`
        HTMLURL   string     `json:"html_url" example:"https://github.com/owner/repo/pull/42"`
        User      GitHubUser `json:"user"`
        Repo      Repository `json:"repository"`
        Draft     bool       `json:"draft" example:"false"`
}

// GitHubUser represents a GitHub user
type GitHubUser struct {
        Login     string `json:"login" example:"johndoe"`
        ID        int64  `json:"id" example:"12345"`
        AvatarURL string `json:"avatar_url" example:"https://avatars.githubusercontent.com/u/12345"`
}

// Repository represents a GitHub repository
type Repository struct {
        Name     string `json:"name" example:"my-repo"`
        FullName string `json:"full_name" example:"owner/my-repo"`
        Owner    string `json:"owner" example:"owner"`
        Private  bool   `json:"private" example:"false"`
}

// PullRequestsResponse represents the response for pull requests
type PullRequestsResponse struct {
        PullRequests []PullRequest `json:"pull_requests"`
        Total        int           `json:"total"`
}

// TotalContributions Response represents the response for user contributions
type TotalContributionsResponse struct {
        TotalContributions int    `json:"total_contributions" example:"1234"`
        Period             string `json:"period" example:"365d"`
        From               string `json:"from" example:"2024-10-16T00:00:00Z"`
        To                 string `json:"to" example:"2025-10-16T23:59:59Z"`
}

// PRReviewCommentsResponse represents the response for PR review comments count
type PRReviewCommentsResponse struct {
        TotalComments int    `json:"total_comments" example:"42"`
        Period        string `json:"period" example:"30d"`
        From          string `json:"from" example:"2024-10-16T00:00:00Z"`
        To            string `json:"to" example:"2024-11-16T23:59:59Z"`
}

// ContributionDay represents contributions for a single day
type ContributionDay struct {
        Date              string `json:"date" example:"2025-01-15"`
        ContributionCount int    `json:"contribution_count" example:"5"`
        ContributionLevel string `json:"contribution_level" example:"SECOND_QUARTILE"`
        Color             string `json:"color" example:"#40c463"`
}

// ContributionWeek represents a week of contributions
type ContributionWeek struct {
        FirstDay         string            `json:"first_day" example:"2025-01-12"`
        ContributionDays []ContributionDay `json:"contribution_days"`
}

// ContributionsHeatmapResponse represents the response for contribution heatmap
type ContributionsHeatmapResponse struct {
        TotalContributions int                `json:"total_contributions" example:"1234"`
        Weeks              []ContributionWeek `json:"weeks"`
        From               string             `json:"from" example:"2024-10-16T00:00:00Z"`
        To                 string             `json:"to" example:"2025-10-16T23:59:59Z"`
}

// PRMergeTimeDataPoint represents a single data point for PR merge time metrics (weekly)
type PRMergeTimeDataPoint struct {
        WeekStart    string  `json:"week_start" example:"2024-10-15"`
        WeekEnd      string  `json:"week_end" example:"2024-10-21"`
        AverageHours float64 `json:"average_hours" example:"18.5"`
        PRCount      int     `json:"pr_count" example:"3"`
}

// AveragePRMergeTimeResponse represents the response for average PR merge time
type AveragePRMergeTimeResponse struct {
        AveragePRMergeTimeHours float64                `json:"average_pr_merge_time_hours" example:"24.5"`
        PRCount                 int                    `json:"pr_count" example:"15"`
        Period                  string                 `json:"period" example:"30d"`
        From                    string                 `json:"from" example:"2024-10-03T00:00:00Z"`
        To                      string                 `json:"to" example:"2024-11-02T23:59:59Z"`
        TimeSeries              []PRMergeTimeDataPoint `json:"time_series"`
}

// parseRepositoryFromURL extracts repository information from a GitHub URL
// Handles URLs like: https://github.com/owner/repo/pull/123
// or https://github.enterprise.com/owner/repo/pull/123
func parseRepositoryFromURL(urlStr string) (owner, repoName, fullName string) <span class="cov4" title="5">{
        if urlStr == "" </span><span class="cov1" title="1">{
                return "", "", ""
        }</span>

        // Remove protocol and split by /
        <span class="cov3" title="4">urlStr = strings.TrimPrefix(urlStr, "https://")
        urlStr = strings.TrimPrefix(urlStr, "http://")
        parts := strings.Split(urlStr, "/")

        // We need at least: domain/owner/repo/...
        if len(parts) &lt; 3 </span><span class="cov1" title="1">{
                return "", "", ""
        }</span>

        // parts[0] is the domain (github.com or github.enterprise.com)
        // parts[1] is the owner
        // parts[2] is the repo name
        <span class="cov3" title="3">owner = parts[1]
        repoName = parts[2]
        fullName = owner + "/" + repoName

        return owner, repoName, fullName</span>
}

// GetUserOpenPullRequests retrieves all open pull requests for the authenticated user
func (s *GitHubService) GetUserOpenPullRequests(ctx context.Context, userUUID, provider, state, sort, direction string, perPage, page int) (*PullRequestsResponse, error) <span class="cov5" title="11">{
        if userUUID == "" || provider == "" </span><span class="cov1" title="1">{
                return nil, apperrors.ErrMissingUserUUIDAndProvider
        }</span>

        // Get GitHub access token using validated JWT claims
        <span class="cov5" title="10">accessToken, err := s.authService.GetGitHubAccessToken(userUUID, provider)
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("failed to get GitHub access token: %w", err)
        }</span>

        // Get GitHub client configuration for the user's provider
        <span class="cov5" title="8">githubClientConfig, err := s.authService.GetGitHubClient(provider)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get GitHub client: %w", err)
        }</span>

        // Create OAuth2 client with access token
        <span class="cov4" title="7">ts := oauth2.StaticTokenSource(
                &amp;oauth2.Token{AccessToken: accessToken},
        )
        tc := oauth2.NewClient(ctx, ts)

        // Create authenticated GitHub client
        var client *github.Client
        if githubClientConfig != nil &amp;&amp; githubClientConfig.GetEnterpriseBaseURL() != "" </span><span class="cov4" title="7">{
                client, err = github.NewEnterpriseClient(githubClientConfig.GetEnterpriseBaseURL(), githubClientConfig.GetEnterpriseBaseURL(), tc)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create GitHub Enterprise client: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                client = github.NewClient(tc)
        }</span>

        // Set default values
        <span class="cov4" title="7">if state == "" </span><span class="cov1" title="1">{
                state = "open"
        }</span>
        <span class="cov4" title="7">if sort == "" </span><span class="cov1" title="1">{
                sort = "created"
        }</span>
        <span class="cov4" title="7">if direction == "" </span><span class="cov1" title="1">{
                direction = "desc"
        }</span>
        <span class="cov4" title="7">if perPage &lt;= 0 || perPage &gt; 100 </span><span class="cov1" title="1">{
                perPage = 30
        }</span>
        <span class="cov4" title="7">if page &lt;= 0 </span><span class="cov1" title="1">{
                page = 1
        }</span>

        // Search for pull requests created by the authenticated user
        // Using search API for better filtering capabilities
        // Note: GitHub Search API doesn't support state:all - omit state qualifier to get all PRs
        <span class="cov4" title="7">var query string
        if state == "all" </span><span class="cov0" title="0">{
                query = "is:pr author:@me"
        }</span> else<span class="cov4" title="7"> {
                query = fmt.Sprintf("is:pr author:@me state:%s", state)
        }</span>

        <span class="cov4" title="7">searchOpts := &amp;github.SearchOptions{
                Sort:  sort,
                Order: direction,
                ListOptions: github.ListOptions{
                        PerPage: perPage,
                        Page:    page,
                },
        }

        result, resp, err := client.Search.Issues(ctx, query, searchOpts)
        if err != nil </span><span class="cov1" title="1">{
                // Check if it's a rate limit error
                if resp != nil &amp;&amp; resp.StatusCode == 403 </span><span class="cov1" title="1">{
                        return nil, apperrors.ErrGitHubAPIRateLimitExceeded
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to search pull requests: %w", err)</span>
        }

        // Convert GitHub issues (PRs are issues in GitHub API) to our PR structure
        <span class="cov4" title="6">pullRequests := make([]PullRequest, 0, len(result.Issues))
        for _, issue := range result.Issues </span><span class="cov3" title="4">{
                if issue.PullRequestLinks == nil </span><span class="cov0" title="0">{
                        continue</span> // Skip if it's not actually a PR
                }

                <span class="cov3" title="4">pr := PullRequest{
                        ID:        issue.GetID(),
                        Number:    issue.GetNumber(),
                        Title:     issue.GetTitle(),
                        State:     issue.GetState(),
                        CreatedAt: issue.GetCreatedAt().Time,
                        UpdatedAt: issue.GetUpdatedAt().Time,
                        HTMLURL:   issue.GetHTMLURL(),
                        Draft:     issue.GetDraft(),
                        User: GitHubUser{
                                Login:     issue.GetUser().GetLogin(),
                                ID:        issue.GetUser().GetID(),
                                AvatarURL: issue.GetUser().GetAvatarURL(),
                        },
                }

                // Parse repository info from the issue
                if issue.Repository != nil </span><span class="cov3" title="4">{
                        pr.Repo = Repository{
                                Name:     issue.Repository.GetName(),
                                FullName: issue.Repository.GetFullName(),
                                Private:  issue.Repository.GetPrivate(),
                        }
                        if issue.Repository.Owner != nil </span><span class="cov3" title="4">{
                                pr.Repo.Owner = issue.Repository.Owner.GetLogin()
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Fallback: parse repository info from the HTML URL
                        // GitHub Search API often doesn't include the Repository field
                        owner, repoName, fullName := parseRepositoryFromURL(issue.GetHTMLURL())
                        if owner != "" &amp;&amp; repoName != "" </span><span class="cov0" title="0">{
                                pr.Repo = Repository{
                                        Name:     repoName,
                                        FullName: fullName,
                                        Owner:    owner,
                                        // Note: We can't determine if the repo is private from the URL alone
                                        // Default to false, but this could be enhanced with an additional API call if needed
                                        Private: false,
                                }
                        }</span>
                }

                <span class="cov3" title="4">pullRequests = append(pullRequests, pr)</span>
        }

        <span class="cov4" title="6">response := &amp;PullRequestsResponse{
                PullRequests: pullRequests,
                Total:        result.GetTotal(),
        }

        return response, nil</span>
}

// GetUserTotalContributions retrieves the total contributions for the authenticated user over a specified period
func (s *GitHubService) GetUserTotalContributions(ctx context.Context, userUUID, provider, period string) (*TotalContributionsResponse, error) <span class="cov4" title="5">{
        if userUUID == "" || provider == "" </span><span class="cov1" title="1">{
                return nil, apperrors.ErrMissingUserUUIDAndProvider
        }</span>

        // Validate period format early (before making any API calls)
        <span class="cov3" title="4">var from, to time.Time
        var parsedPeriod string
        var query string

        if period == "" </span><span class="cov0" title="0">{
                // No period specified - use GitHub's default behavior
                parsedPeriod = "github_default"
                query = `{
                        viewer {
                                contributionsCollection {
                                        startedAt
                                        endedAt
                                        contributionCalendar {
                                                totalContributions
                                        }
                                }
                        }
                }`
        }</span> else<span class="cov3" title="4"> {
                // Validate period format before parsing
                if len(period) &lt; 2 || period[len(period)-1] != 'd' </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: period must be in format '&lt;number&gt;d' (e.g., '30d', '90d', '365d')", apperrors.ErrInvalidPeriodFormat)
                }</span>

                // Parse custom period and calculate date range
                <span class="cov3" title="4">var err error
                from, to, parsedPeriod, err = parsePeriod(period)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: %w", apperrors.ErrInvalidPeriodFormat, err)
                }</span>

                <span class="cov3" title="4">query = fmt.Sprintf(`{
                        viewer {
                                contributionsCollection(from: "%s", to: "%s") {
                                        startedAt
                                        endedAt
                                        contributionCalendar {
                                                totalContributions
                                        }
                                }
                        }
                }`, from.Format(time.RFC3339), to.Format(time.RFC3339))</span>
        }

        // Get GitHub access token using validated JWT claims
        <span class="cov3" title="4">accessToken, err := s.authService.GetGitHubAccessToken(userUUID, provider)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get GitHub access token: %w", err)
        }</span>

        // Get GitHub client configuration for the user's provider
        <span class="cov3" title="3">githubClientConfig, err := s.authService.GetGitHubClient(provider)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get GitHub client: %w", err)
        }</span>

        // Execute GraphQL query
        <span class="cov3" title="3">var result struct {
                Viewer struct {
                        ContributionsCollection struct {
                                StartedAt            string `json:"startedAt"`
                                EndedAt              string `json:"endedAt"`
                                ContributionCalendar struct {
                                        TotalContributions int `json:"totalContributions"`
                                } `json:"contributionCalendar"`
                        } `json:"contributionsCollection"`
                } `json:"viewer"`
        }

        reqBody := struct {
                Query string `json:"query"`
        }{
                Query: query,
        }

        // Determine the correct GraphQL endpoint
        var graphqlURL string
        if githubClientConfig != nil &amp;&amp; githubClientConfig.GetEnterpriseBaseURL() != "" </span><span class="cov3" title="3">{
                // GitHub Enterprise: Use /api/graphql (NOT /api/v3/graphql)
                graphqlURL = strings.TrimSuffix(githubClientConfig.GetEnterpriseBaseURL(), "/") + "/api/graphql"
        }</span> else<span class="cov0" title="0"> {
                // GitHub.com: Use standard GraphQL endpoint
                graphqlURL = "https://api.github.com/graphql"
        }</span>

        // Create HTTP request manually for GraphQL
        <span class="cov3" title="3">jsonBody, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal GraphQL query: %w", err)
        }</span>

        <span class="cov3" title="3">ghReq, err := http.NewRequestWithContext(ctx, "POST", graphqlURL, bytes.NewBuffer(jsonBody))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GraphQL request: %w", err)
        }</span>

        // Set headers
        <span class="cov3" title="3">ghReq.Header.Set("Authorization", "Bearer "+accessToken)
        ghReq.Header.Set("Content-Type", "application/json")
        ghReq.Header.Set("Accept", "application/json")

        // Execute request - respect context deadline if available
        httpClient := &amp;http.Client{}
        if deadline, ok := ctx.Deadline(); ok </span><span class="cov1" title="1">{
                timeout := time.Until(deadline)
                if timeout &gt; 0 </span><span class="cov1" title="1">{
                        httpClient.Timeout = timeout
                }</span> else<span class="cov0" title="0"> {
                        httpClient.Timeout = time.Second // Minimal timeout for expired contexts
                }</span>
        } else<span class="cov2" title="2"> {
                httpClient.Timeout = 30 * time.Second
        }</span>
        <span class="cov3" title="3">resp, err := httpClient.Do(ghReq)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to execute GraphQL query: %w", err)
        }</span>
        <span class="cov2" title="2">defer resp.Body.Close()

        // Check for rate limit
        if resp.StatusCode == 403 </span><span class="cov1" title="1">{
                return nil, apperrors.ErrGitHubAPIRateLimitExceeded
        }</span>

        // Check for other HTTP errors
        <span class="cov1" title="1">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                bodyBytes, readErr := io.ReadAll(resp.Body)
                if readErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("GraphQL query failed with status %d and failed to read response body: %w", resp.StatusCode, readErr)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("GraphQL query failed with status %d: %s", resp.StatusCode, string(bodyBytes))</span>
        }

        // Parse response - GitHub GraphQL returns data in a wrapper
        <span class="cov1" title="1">var graphQLResponse struct {
                Data   json.RawMessage `json:"data"`
                Errors []struct {
                        Message string   `json:"message"`
                        Path    []string `json:"path,omitempty"`
                } `json:"errors,omitempty"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;graphQLResponse); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode GraphQL response: %w", err)
        }</span>

        // Check for GraphQL errors
        <span class="cov1" title="1">if len(graphQLResponse.Errors) &gt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GraphQL error: %s", graphQLResponse.Errors[0].Message)
        }</span>

        // Parse the actual data
        <span class="cov1" title="1">if err := json.Unmarshal(graphQLResponse.Data, &amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal result: %w", err)
        }</span>

        // Use GitHub's actual date range from the response
        // This ensures we return what GitHub actually used, not just what we calculated
        <span class="cov1" title="1">fromStr := result.Viewer.ContributionsCollection.StartedAt
        toStr := result.Viewer.ContributionsCollection.EndedAt

        // If GitHub didn't return dates (shouldn't happen), fall back to calculated dates
        if fromStr == "" &amp;&amp; !from.IsZero() </span><span class="cov0" title="0">{
                fromStr = from.Format(time.RFC3339)
        }</span>
        <span class="cov1" title="1">if toStr == "" &amp;&amp; !to.IsZero() </span><span class="cov0" title="0">{
                toStr = to.Format(time.RFC3339)
        }</span>

        <span class="cov1" title="1">response := &amp;TotalContributionsResponse{
                TotalContributions: result.Viewer.ContributionsCollection.ContributionCalendar.TotalContributions,
                Period:             parsedPeriod,
                From:               fromStr,
                To:                 toStr,
        }

        return response, nil</span>
}

// GetContributionsHeatmap retrieves the contribution heatmap for the authenticated user
func (s *GitHubService) GetContributionsHeatmap(ctx context.Context, userUUID, provider, period string) (*ContributionsHeatmapResponse, error) <span class="cov7" title="26">{
        if userUUID == "" || provider == "" </span><span class="cov1" title="1">{
                return nil, apperrors.ErrMissingUserUUIDAndProvider
        }</span>

        <span class="cov7" title="25">log := logger.WithContext(ctx).WithFields(map[string]interface{}{
                "provider": provider,
                "period":   period,
        })

        log.Info("Fetching GitHub contribution heatmap")

        // Validate that the provider exists in configuration
        if _, err := s.authService.GetGitHubClient(provider); err != nil </span><span class="cov1" title="1">{
                log.Errorf("Provider '%s' not configured in auth.yaml", provider)
                return nil, fmt.Errorf("%w: provider '%s'. Please check available providers in auth.yaml", apperrors.ErrProviderNotConfigured, provider)
        }</span>

        // Validate period format early (before making any API calls)
        <span class="cov7" title="24">var from, to time.Time
        var query string

        if period == "" </span><span class="cov3" title="3">{
                log.Debug("Using GitHub's default period for contribution heatmap")
                // No period specified - use GitHub's default behavior
                query = `{
                        viewer {
                                contributionsCollection {
                                        startedAt
                                        endedAt
                                        contributionCalendar {
                                                totalContributions
                                                weeks {
                                                        firstDay
                                                        contributionDays {
                                                                date
                                                                contributionCount
                                                                contributionLevel
                                                                color
                                                        }
                                                }
                                        }
                                }
                        }
                }`
        }</span> else<span class="cov6" title="21"> {
                // Validate period format before parsing
                if len(period) &lt; 2 || period[len(period)-1] != 'd' </span><span class="cov1" title="1">{
                        log.Errorf("Invalid period format: %s", period)
                        return nil, fmt.Errorf("%w: period must be in format '&lt;number&gt;d' (e.g., '30d', '90d', '365d')", apperrors.ErrInvalidPeriodFormat)
                }</span>

                // Parse custom period and calculate date range
                <span class="cov6" title="20">var err error
                var parsedPeriod string
                from, to, parsedPeriod, err = parsePeriod(period)
                if err != nil </span><span class="cov4" title="5">{
                        log.Errorf("Failed to parse period '%s': %v", period, err)
                        return nil, fmt.Errorf("%w: %w", apperrors.ErrInvalidPeriodFormat, err)
                }</span>
                <span class="cov6" title="15">_ = parsedPeriod // Used for validation, not needed in this response

                log.Debugf("Using custom period: from %s to %s", from.Format(time.RFC3339), to.Format(time.RFC3339))

                query = fmt.Sprintf(`{
                        viewer {
                                contributionsCollection(from: "%s", to: "%s") {
                                        startedAt
                                        endedAt
                                        contributionCalendar {
                                                totalContributions
                                                weeks {
                                                        firstDay
                                                        contributionDays {
                                                                date
                                                                contributionCount
                                                                contributionLevel
                                                                color
                                                        }
                                                }
                                        }
                                }
                        }
                }`, from.Format(time.RFC3339), to.Format(time.RFC3339))</span>
        }

        // Get GitHub access token using validated JWT claims
        <span class="cov6" title="18">accessToken, err := s.authService.GetGitHubAccessToken(userUUID, provider)
        if err != nil </span><span class="cov1" title="1">{
                log.Errorf("Failed to get GitHub access token: %v", err)
                return nil, fmt.Errorf("failed to get GitHub access token: %w", err)
        }</span>

        // Get GitHub client configuration for the user's provider
        <span class="cov6" title="17">githubClientConfig, err := s.authService.GetGitHubClient(provider)
        if err != nil </span><span class="cov1" title="1">{
                log.Errorf("Failed to get GitHub client for provider '%s': %v", provider, err)
                return nil, fmt.Errorf("failed to get GitHub client: %w", err)
        }</span>

        // Execute GraphQL query
        <span class="cov6" title="16">var result struct {
                Viewer struct {
                        ContributionsCollection struct {
                                StartedAt            string `json:"startedAt"`
                                EndedAt              string `json:"endedAt"`
                                ContributionCalendar struct {
                                        TotalContributions int `json:"totalContributions"`
                                        Weeks              []struct {
                                                FirstDay         string `json:"firstDay"`
                                                ContributionDays []struct {
                                                        Date              string `json:"date"`
                                                        ContributionCount int    `json:"contributionCount"`
                                                        ContributionLevel string `json:"contributionLevel"`
                                                        Color             string `json:"color"`
                                                } `json:"contributionDays"`
                                        } `json:"weeks"`
                                } `json:"contributionCalendar"`
                        } `json:"contributionsCollection"`
                } `json:"viewer"`
        }

        reqBody := struct {
                Query string `json:"query"`
        }{
                Query: query,
        }

        // Determine the correct GraphQL endpoint
        var graphqlURL string
        if githubClientConfig != nil &amp;&amp; githubClientConfig.GetEnterpriseBaseURL() != "" </span><span class="cov5" title="10">{
                // GitHub Enterprise: Use /api/graphql (NOT /api/v3/graphql)
                graphqlURL = strings.TrimSuffix(githubClientConfig.GetEnterpriseBaseURL(), "/") + "/api/graphql"
                log.Debugf("Using GitHub Enterprise GraphQL endpoint: %s", graphqlURL)
        }</span> else<span class="cov4" title="6"> {
                // GitHub.com: Use standard GraphQL endpoint
                graphqlURL = "https://api.github.com/graphql"
                log.Debug("Using GitHub.com GraphQL endpoint")
        }</span>

        // Create HTTP request manually for GraphQL
        <span class="cov6" title="16">jsonBody, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to marshal GraphQL query: %v", err)
                return nil, fmt.Errorf("failed to marshal GraphQL query: %w", err)
        }</span>

        <span class="cov6" title="16">log.Infof("Executing GraphQL query to %s", graphqlURL)

        ghReq, err := http.NewRequestWithContext(ctx, "POST", graphqlURL, bytes.NewBuffer(jsonBody))
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to create GraphQL request: %v", err)
                return nil, fmt.Errorf("failed to create GraphQL request: %w", err)
        }</span>

        // Set headers
        <span class="cov6" title="16">ghReq.Header.Set("Authorization", "Bearer "+accessToken)
        ghReq.Header.Set("Content-Type", "application/json")
        ghReq.Header.Set("Accept", "application/json")

        // Execute request - respect context deadline if available
        httpClient := &amp;http.Client{}
        if deadline, ok := ctx.Deadline(); ok </span><span class="cov0" title="0">{
                timeout := time.Until(deadline)
                if timeout &gt; 0 </span><span class="cov0" title="0">{
                        httpClient.Timeout = timeout
                }</span> else<span class="cov0" title="0"> {
                        httpClient.Timeout = time.Second // Minimal timeout for expired contexts
                }</span>
        } else<span class="cov6" title="16"> {
                httpClient.Timeout = 30 * time.Second
        }</span>
        <span class="cov6" title="16">resp, err := httpClient.Do(ghReq)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to execute GraphQL query: %v", err)
                return nil, fmt.Errorf("failed to execute GraphQL query: %w", err)
        }</span>
        <span class="cov6" title="16">defer resp.Body.Close()

        log.Debugf("GitHub API response status: %d", resp.StatusCode)

        // Check for rate limit
        if resp.StatusCode == 403 </span><span class="cov1" title="1">{
                log.Warn("GitHub API rate limit exceeded")
                return nil, apperrors.ErrGitHubAPIRateLimitExceeded
        }</span>

        // Check for other HTTP errors
        <span class="cov6" title="15">if resp.StatusCode != 200 </span><span class="cov5" title="9">{
                bodyBytes, readErr := io.ReadAll(resp.Body)
                if readErr != nil </span><span class="cov0" title="0">{
                        log.Errorf("GraphQL query failed with status %d and failed to read response body", resp.StatusCode)
                        return nil, fmt.Errorf("GraphQL query failed with status %d and failed to read response body: %w", resp.StatusCode, readErr)
                }</span>
                <span class="cov5" title="9">log.Errorf("GraphQL query failed with status %d: %s", resp.StatusCode, string(bodyBytes))
                return nil, fmt.Errorf("GraphQL query failed with status %d: %s", resp.StatusCode, string(bodyBytes))</span>
        }

        // Parse response - GitHub GraphQL returns data in a wrapper
        <span class="cov4" title="6">var graphQLResponse struct {
                Data   json.RawMessage `json:"data"`
                Errors []struct {
                        Message string   `json:"message"`
                        Path    []string `json:"path,omitempty"`
                } `json:"errors,omitempty"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;graphQLResponse); err != nil </span><span class="cov1" title="1">{
                log.Errorf("Failed to decode GraphQL response: %v", err)
                return nil, fmt.Errorf("failed to decode GraphQL response: %w", err)
        }</span>

        // Check for GraphQL errors
        <span class="cov4" title="5">if len(graphQLResponse.Errors) &gt; 0 </span><span class="cov1" title="1">{
                log.Errorf("GraphQL error: %s", graphQLResponse.Errors[0].Message)
                return nil, fmt.Errorf("GraphQL error: %s", graphQLResponse.Errors[0].Message)
        }</span>

        // Parse the actual data
        <span class="cov3" title="4">if err := json.Unmarshal(graphQLResponse.Data, &amp;result); err != nil </span><span class="cov1" title="1">{
                log.Errorf("Failed to unmarshal GraphQL result: %v", err)
                return nil, fmt.Errorf("failed to unmarshal result: %w", err)
        }</span>

        <span class="cov3" title="3">log.Debugf("Successfully retrieved contribution heatmap with %d weeks", len(result.Viewer.ContributionsCollection.ContributionCalendar.Weeks))

        // Convert the result to our response format
        weeks := make([]ContributionWeek, 0, len(result.Viewer.ContributionsCollection.ContributionCalendar.Weeks))
        for _, week := range result.Viewer.ContributionsCollection.ContributionCalendar.Weeks </span><span class="cov2" title="2">{
                days := make([]ContributionDay, 0, len(week.ContributionDays))
                for _, day := range week.ContributionDays </span><span class="cov3" title="4">{
                        days = append(days, ContributionDay{
                                Date:              day.Date,
                                ContributionCount: day.ContributionCount,
                                ContributionLevel: day.ContributionLevel,
                                Color:             day.Color,
                        })
                }</span>
                <span class="cov2" title="2">weeks = append(weeks, ContributionWeek{
                        FirstDay:         week.FirstDay,
                        ContributionDays: days,
                })</span>
        }

        <span class="cov3" title="3">response := &amp;ContributionsHeatmapResponse{
                TotalContributions: result.Viewer.ContributionsCollection.ContributionCalendar.TotalContributions,
                Weeks:              weeks,
                From:               result.Viewer.ContributionsCollection.StartedAt,
                To:                 result.Viewer.ContributionsCollection.EndedAt,
        }

        log.Infof("Successfully fetched contribution heatmap: %d total contributions from %s to %s",
                response.TotalContributions, response.From, response.To)

        return response, nil</span>
}

// GetAveragePRMergeTime retrieves the average time to merge PRs for the authenticated user
func (s *GitHubService) GetAveragePRMergeTime(ctx context.Context, userUUID, provider, period string) (*AveragePRMergeTimeResponse, error) <span class="cov7" title="23">{
        if userUUID == "" || provider == "" </span><span class="cov1" title="1">{
                return nil, apperrors.ErrMissingUserUUIDAndProvider
        }</span>

        <span class="cov7" title="22">log := logger.WithContext(ctx).WithFields(map[string]interface{}{
                "provider": provider,
                "period":   period,
        })

        log.Info("Fetching average PR merge time")

        // Parse and validate period
        var from, to time.Time
        var parsedPeriod string
        var err error

        if period == "" </span><span class="cov0" title="0">{
                period = "30d"
        }</span>

        <span class="cov7" title="22">from, to, parsedPeriod, err = parsePeriod(period)
        if err != nil </span><span class="cov3" title="4">{
                log.Errorf("Invalid period format: %s", period)
                return nil, fmt.Errorf("%w: %w", apperrors.ErrInvalidPeriodFormat, err)
        }</span>

        <span class="cov6" title="18">log.Debugf("Querying merged PRs from %s to %s", from.Format(time.RFC3339), to.Format(time.RFC3339))

        // Get GitHub access token
        accessToken, err := s.authService.GetGitHubAccessToken(userUUID, provider)
        if err != nil </span><span class="cov1" title="1">{
                log.Errorf("Failed to get GitHub access token: %v", err)
                return nil, fmt.Errorf("failed to get GitHub access token: %w", err)
        }</span>

        // Get GitHub client configuration
        <span class="cov6" title="17">githubClientConfig, err := s.authService.GetGitHubClient(provider)
        if err != nil </span><span class="cov1" title="1">{
                log.Errorf("Failed to get GitHub client for provider '%s': %v", provider, err)
                return nil, fmt.Errorf("failed to get GitHub client: %w", err)
        }</span>

        // Determine GraphQL endpoint
        <span class="cov6" title="16">var graphqlURL string
        if githubClientConfig != nil &amp;&amp; githubClientConfig.GetEnterpriseBaseURL() != "" </span><span class="cov5" title="10">{
                graphqlURL = strings.TrimSuffix(githubClientConfig.GetEnterpriseBaseURL(), "/") + "/api/graphql"
                log.Debugf("Using GitHub Enterprise GraphQL endpoint: %s", graphqlURL)
        }</span> else<span class="cov4" title="6"> {
                graphqlURL = "https://api.github.com/graphql"
                log.Debug("Using GitHub.com GraphQL endpoint")
        }</span>

        // Build search query for merged PRs
        <span class="cov6" title="16">searchQuery := fmt.Sprintf("is:pr author:@me is:merged merged:&gt;=%s", from.Format("2006-01-02"))

        // Collect all PRs with pagination
        type prData struct {
                Number     int
                CreatedAt  string
                MergedAt   string
                Repository struct {
                        Name  string
                        Owner struct {
                                Login string
                        }
                }
        }

        allPRs := []prData{}
        hasNextPage := true
        cursor := ""

        for hasNextPage </span><span class="cov6" title="16">{
                // Build GraphQL query
                query := `query($q: String!, $first: Int!, $after: String) {
                        search(query: $q, type: ISSUE, first: $first, after: $after) {
                                pageInfo {
                                        hasNextPage
                                        endCursor
                                }
                                nodes {
                                        ... on PullRequest {
                                                number
                                                createdAt
                                                mergedAt
                                                repository {
                                                        name
                                                        owner {
                                                                login
                                                        }
                                                }
                                        }
                                }
                        }
                }`

                variables := map[string]interface{}{
                        "q":     searchQuery,
                        "first": 100,
                        "after": nil,
                }
                if cursor != "" </span><span class="cov0" title="0">{
                        variables["after"] = cursor
                }</span>

                <span class="cov6" title="16">reqBody := map[string]interface{}{
                        "query":     query,
                        "variables": variables,
                }

                jsonBody, err := json.Marshal(reqBody)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to marshal GraphQL query: %v", err)
                        return nil, fmt.Errorf("failed to marshal GraphQL query: %w", err)
                }</span>

                <span class="cov6" title="16">ghReq, err := http.NewRequestWithContext(ctx, "POST", graphqlURL, bytes.NewBuffer(jsonBody))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to create GraphQL request: %v", err)
                        return nil, fmt.Errorf("failed to create GraphQL request: %w", err)
                }</span>

                <span class="cov6" title="16">ghReq.Header.Set("Authorization", "Bearer "+accessToken)
                ghReq.Header.Set("Content-Type", "application/json")
                ghReq.Header.Set("Accept", "application/json")

                httpClient := &amp;http.Client{}
                if deadline, ok := ctx.Deadline(); ok </span><span class="cov0" title="0">{
                        timeout := time.Until(deadline)
                        if timeout &gt; 0 </span><span class="cov0" title="0">{
                                httpClient.Timeout = timeout
                        }</span> else<span class="cov0" title="0"> {
                                httpClient.Timeout = time.Second
                        }</span>
                } else<span class="cov6" title="16"> {
                        httpClient.Timeout = 30 * time.Second
                }</span>

                <span class="cov6" title="16">resp, err := httpClient.Do(ghReq)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to execute GraphQL query: %v", err)
                        return nil, fmt.Errorf("failed to execute GraphQL query: %w", err)
                }</span>
                <span class="cov6" title="16">defer resp.Body.Close()

                log.Debugf("GitHub API response status: %d", resp.StatusCode)

                if resp.StatusCode == 403 </span><span class="cov1" title="1">{
                        log.Warn("GitHub API rate limit exceeded")
                        return nil, apperrors.ErrGitHubAPIRateLimitExceeded
                }</span>

                <span class="cov6" title="15">if resp.StatusCode != 200 </span><span class="cov5" title="8">{
                        bodyBytes, readErr := io.ReadAll(resp.Body)
                        if readErr != nil </span><span class="cov0" title="0">{
                                log.Errorf("GraphQL query failed with status %d and failed to read response body", resp.StatusCode)
                                return nil, fmt.Errorf("GraphQL query failed with status %d and failed to read response body: %w", resp.StatusCode, readErr)
                        }</span>
                        <span class="cov5" title="8">log.Errorf("GraphQL query failed with status %d: %s", resp.StatusCode, string(bodyBytes))
                        return nil, fmt.Errorf("GraphQL query failed with status %d: %s", resp.StatusCode, string(bodyBytes))</span>
                }

                <span class="cov4" title="7">var graphQLResponse struct {
                        Data struct {
                                Search struct {
                                        PageInfo struct {
                                                HasNextPage bool   `json:"hasNextPage"`
                                                EndCursor   string `json:"endCursor"`
                                        } `json:"pageInfo"`
                                        Nodes []prData `json:"nodes"`
                                } `json:"search"`
                        } `json:"data"`
                        Errors []struct {
                                Message string   `json:"message"`
                                Path    []string `json:"path,omitempty"`
                        } `json:"errors,omitempty"`
                }

                if err := json.NewDecoder(resp.Body).Decode(&amp;graphQLResponse); err != nil </span><span class="cov1" title="1">{
                        log.Errorf("Failed to decode GraphQL response: %v", err)
                        return nil, fmt.Errorf("failed to decode GraphQL response: %w", err)
                }</span>

                <span class="cov4" title="6">if len(graphQLResponse.Errors) &gt; 0 </span><span class="cov1" title="1">{
                        log.Errorf("GraphQL error: %s", graphQLResponse.Errors[0].Message)
                        return nil, fmt.Errorf("GraphQL error: %s", graphQLResponse.Errors[0].Message)
                }</span>

                <span class="cov4" title="5">allPRs = append(allPRs, graphQLResponse.Data.Search.Nodes...)
                hasNextPage = graphQLResponse.Data.Search.PageInfo.HasNextPage
                cursor = graphQLResponse.Data.Search.PageInfo.EndCursor

                log.Debugf("Fetched %d PRs, hasNextPage: %v", len(graphQLResponse.Data.Search.Nodes), hasNextPage)</span>
        }

        // Calculate merge times and group by week
        <span class="cov4" title="5">type weekData struct {
                totalHours float64
                count      int
                weekStart  time.Time
                weekEnd    time.Time
        }

        // Define 4 weeks going back from today
        now := time.Now().UTC()
        weeks := make([]*weekData, 4)
        for i := 0; i &lt; 4; i++ </span><span class="cov6" title="20">{
                weekEnd := now.AddDate(0, 0, -7*i)
                weekStart := weekEnd.AddDate(0, 0, -7)
                weeks[i] = &amp;weekData{
                        weekStart: weekStart,
                        weekEnd:   weekEnd,
                }
        }</span>

        <span class="cov4" title="5">var totalHours float64
        var validPRCount int

        for _, pr := range allPRs </span><span class="cov4" title="7">{
                if pr.MergedAt == "" || pr.CreatedAt == "" </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov4" title="6">createdAt, err := time.Parse(time.RFC3339, pr.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warnf("Failed to parse createdAt for PR #%d: %v", pr.Number, err)
                        continue</span>
                }

                <span class="cov4" title="6">mergedAt, err := time.Parse(time.RFC3339, pr.MergedAt)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warnf("Failed to parse mergedAt for PR #%d: %v", pr.Number, err)
                        continue</span>
                }

                <span class="cov4" title="6">mergeTimeHours := mergedAt.Sub(createdAt).Hours()
                totalHours += mergeTimeHours
                validPRCount++

                // Assign PR to the appropriate week
                for _, week := range weeks </span><span class="cov7" title="24">{
                        if (mergedAt.Equal(week.weekStart) || mergedAt.After(week.weekStart)) &amp;&amp; mergedAt.Before(week.weekEnd) </span><span class="cov0" title="0">{
                                week.totalHours += mergeTimeHours
                                week.count++
                                break</span>
                        }
                }
        }

        <span class="cov4" title="5">log.Infof("Total merged PRs found: %d, successfully processed: %d", len(allPRs), validPRCount)

        // Calculate overall average and round to 2 decimal places
        var averageHours float64
        if validPRCount &gt; 0 </span><span class="cov3" title="4">{
                averageHours = roundTo2Decimals(totalHours / float64(validPRCount))
        }</span>

        // Build time series (always 4 weeks, newest to oldest)
        <span class="cov4" title="5">timeSeries := make([]PRMergeTimeDataPoint, 4)
        for i := 0; i &lt; 4; i++ </span><span class="cov6" title="20">{
                week := weeks[i]
                var avgForWeek float64
                if week.count &gt; 0 </span><span class="cov0" title="0">{
                        avgForWeek = roundTo2Decimals(week.totalHours / float64(week.count))
                }</span>
                <span class="cov6" title="20">timeSeries[i] = PRMergeTimeDataPoint{
                        WeekStart:    week.weekStart.Format("2006-01-02"),
                        WeekEnd:      week.weekEnd.Format("2006-01-02"),
                        AverageHours: avgForWeek,
                        PRCount:      week.count,
                }</span>
        }

        <span class="cov4" title="5">response := &amp;AveragePRMergeTimeResponse{
                AveragePRMergeTimeHours: averageHours,
                PRCount:                 validPRCount,
                Period:                  parsedPeriod,
                From:                    from.Format(time.RFC3339),
                To:                      to.Format(time.RFC3339),
                TimeSeries:              timeSeries,
        }

        log.Infof("Successfully calculated average PR merge time: %.2f hours across %d PRs", averageHours, validPRCount)

        return response, nil</span>
}

// roundTo2Decimals rounds a float64 to 2 decimal places
func roundTo2Decimals(num float64) float64 <span class="cov3" title="4">{
        return math.Round(num*100) / 100
}</span>

// parsePeriod parses a period string (e.g., "30d", "90d", "365d") and returns the from/to dates
// Default period is 365 days if not specified or invalid
func parsePeriod(period string) (from, to time.Time, parsedPeriod string, err error) <span class="cov9" title="67">{
        to = time.Now().UTC()

        // Default to 365 days if empty or invalid
        days := 365
        parsedPeriod = "365d"

        if period != "" </span><span class="cov9" title="67">{
                // Parse period format like "30d", "90d", "365d"
                if len(period) &lt; 2 || period[len(period)-1] != 'd' </span><span class="cov1" title="1">{
                        return time.Time{}, time.Time{}, "", fmt.Errorf("period must be in format '&lt;number&gt;d' (e.g., '30d', '90d', '365d')")
                }</span>

                <span class="cov9" title="66">var parseErr error
                days, parseErr = strconv.Atoi(period[:len(period)-1])
                if parseErr != nil || days &lt;= 0 </span><span class="cov5" title="9">{
                        return time.Time{}, time.Time{}, "", fmt.Errorf("period must contain a positive number of days")
                }</span>

                // GitHub API supports max 1 year of contributions
                <span class="cov8" title="57">if days &gt; 365 </span><span class="cov0" title="0">{
                        days = 365
                }</span>

                <span class="cov8" title="57">parsedPeriod = period</span>
        }

        <span class="cov8" title="57">from = to.AddDate(0, 0, -days)

        // Set from to start of day and to to end of day
        from = time.Date(from.Year(), from.Month(), from.Day(), 0, 0, 0, 0, time.UTC)
        to = time.Date(to.Year(), to.Month(), to.Day(), 23, 59, 59, 0, time.UTC)

        return from, to, parsedPeriod, nil</span>
}

// GetRepositoryContent fetches repository file or directory content from GitHub
func (s *GitHubService) GetRepositoryContent(ctx context.Context, userUUID, provider, owner, repo, path, ref string) (interface{}, error) <span class="cov6" title="21">{
        // Get access token from auth service
        accessToken, err := s.authService.GetGitHubAccessToken(userUUID, provider)
        if err != nil </span><span class="cov4" title="6">{
                return nil, fmt.Errorf("failed to get access token: %w", err)
        }</span>

        // Get GitHub client configuration
        <span class="cov6" title="15">githubClientConfig, err := s.authService.GetGitHubClient(provider)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Create OAuth2 token source
        <span class="cov6" title="14">ts := oauth2.StaticTokenSource(
                &amp;oauth2.Token{AccessToken: accessToken},
        )
        tc := oauth2.NewClient(ctx, ts)

        // Create authenticated GitHub client
        var client *github.Client
        if githubClientConfig != nil &amp;&amp; githubClientConfig.GetEnterpriseBaseURL() != "" </span><span class="cov3" title="4">{
                client, err = github.NewEnterpriseClient(githubClientConfig.GetEnterpriseBaseURL(), githubClientConfig.GetEnterpriseBaseURL(), tc)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create GitHub Enterprise client: %w", err)
                }</span>
        } else<span class="cov5" title="10"> {
                client = github.NewClient(tc)
        }</span>

        // Set default ref if not provided
        <span class="cov6" title="14">if ref == "" </span><span class="cov1" title="1">{
                ref = "main"
        }</span>

        // Remove leading slash from path if present
        <span class="cov6" title="14">if len(path) &gt; 0 &amp;&amp; path[0] == '/' </span><span class="cov1" title="1">{
                path = path[1:]
        }</span>

        // Fetch repository content
        <span class="cov6" title="14">fileContent, directoryContent, resp, err := client.Repositories.GetContents(
                ctx,
                owner,
                repo,
                path,
                &amp;github.RepositoryContentGetOptions{
                        Ref: ref,
                },
        )

        // Handle errors
        if err != nil </span><span class="cov5" title="10">{
                // Check for rate limit
                if resp != nil &amp;&amp; resp.StatusCode == 403 </span><span class="cov0" title="0">{
                        return nil, apperrors.ErrGitHubAPIRateLimitExceeded
                }</span>
                // Check for not found
                <span class="cov5" title="10">if resp != nil &amp;&amp; resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return nil, apperrors.NewNotFoundError("repository content")
                }</span>
                <span class="cov5" title="10">return nil, fmt.Errorf("failed to fetch repository content: %w", err)</span>
        }

        // Return directory contents (array)
        <span class="cov3" title="4">if directoryContent != nil </span><span class="cov2" title="2">{
                result := make([]map[string]interface{}, len(directoryContent))
                for i, item := range directoryContent </span><span class="cov3" title="4">{
                        result[i] = map[string]interface{}{
                                "name":         item.GetName(),
                                "path":         item.GetPath(),
                                "sha":          item.GetSHA(),
                                "size":         item.GetSize(),
                                "url":          item.GetURL(),
                                "html_url":     item.GetHTMLURL(),
                                "git_url":      item.GetGitURL(),
                                "download_url": item.GetDownloadURL(),
                                "type":         item.GetType(),
                                "_links": map[string]string{
                                        "self": item.GetURL(),
                                        "git":  item.GetGitURL(),
                                        "html": item.GetHTMLURL(),
                                },
                        }
                }</span>
                <span class="cov2" title="2">return result, nil</span>
        }

        // Return file content (object)
        <span class="cov2" title="2">if fileContent != nil </span><span class="cov2" title="2">{
                content, err := fileContent.GetContent()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get file content: %w", err)
                }</span>
                <span class="cov2" title="2">return map[string]interface{}{
                        "name":         fileContent.GetName(),
                        "path":         fileContent.GetPath(),
                        "sha":          fileContent.GetSHA(),
                        "size":         fileContent.GetSize(),
                        "url":          fileContent.GetURL(),
                        "html_url":     fileContent.GetHTMLURL(),
                        "git_url":      fileContent.GetGitURL(),
                        "download_url": fileContent.GetDownloadURL(),
                        "type":         fileContent.GetType(),
                        "content":      content,
                        "encoding":     fileContent.GetEncoding(),
                        "_links": map[string]string{
                                "self": fileContent.GetURL(),
                                "git":  fileContent.GetGitURL(),
                                "html": fileContent.GetHTMLURL(),
                        },
                }, nil</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response from GitHub API")</span>
}

// UpdateRepositoryFile updates a file in a GitHub repository
func (s *GitHubService) UpdateRepositoryFile(ctx context.Context, userUUID, provider, owner, repo, path, message, content, sha, branch string) (interface{}, error) <span class="cov6" title="20">{
        // Get access token from auth service
        accessToken, err := s.authService.GetGitHubAccessToken(userUUID, provider)
        if err != nil </span><span class="cov4" title="6">{
                return nil, fmt.Errorf("failed to get access token: %w", err)
        }</span>

        // Get GitHub client configuration
        <span class="cov6" title="14">githubClientConfig, err := s.authService.GetGitHubClient(provider)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Create OAuth2 token source
        <span class="cov6" title="13">ts := oauth2.StaticTokenSource(
                &amp;oauth2.Token{AccessToken: accessToken},
        )
        tc := oauth2.NewClient(ctx, ts)

        // Create authenticated GitHub client
        var client *github.Client
        if githubClientConfig != nil &amp;&amp; githubClientConfig.GetEnterpriseBaseURL() != "" </span><span class="cov3" title="4">{
                client, err = github.NewEnterpriseClient(githubClientConfig.GetEnterpriseBaseURL(), githubClientConfig.GetEnterpriseBaseURL(), tc)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create GitHub Enterprise client: %w", err)
                }</span>
        } else<span class="cov5" title="9"> {
                client = github.NewClient(tc)
        }</span>

        // Remove leading slash from path if present
        <span class="cov6" title="13">if len(path) &gt; 0 &amp;&amp; path[0] == '/' </span><span class="cov0" title="0">{
                path = path[1:]
        }</span>

        // Set default branch if not provided
        <span class="cov6" title="13">if branch == "" </span><span class="cov2" title="2">{
                branch = "main"
        }</span>

        // Create update options
        <span class="cov6" title="13">opts := &amp;github.RepositoryContentFileOptions{
                Message: github.String(message),
                Content: []byte(content),
                SHA:     github.String(sha),
                Branch:  github.String(branch),
        }

        // Update the file
        result, resp, err := client.Repositories.UpdateFile(ctx, owner, repo, path, opts)
        if err != nil </span><span class="cov5" title="9">{
                // Check for rate limit
                if resp != nil &amp;&amp; resp.StatusCode == 403 </span><span class="cov0" title="0">{
                        return nil, apperrors.ErrGitHubAPIRateLimitExceeded
                }</span>
                // Check for not found
                <span class="cov5" title="9">if resp != nil &amp;&amp; resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return nil, apperrors.NewNotFoundError("repository or file")
                }</span>
                <span class="cov5" title="9">return nil, fmt.Errorf("failed to update repository file: %w", err)</span>
        }

        // Return the result
        <span class="cov3" title="4">return map[string]interface{}{
                "content": map[string]interface{}{
                        "name":         result.Content.GetName(),
                        "path":         result.Content.GetPath(),
                        "sha":          result.Content.GetSHA(),
                        "size":         result.Content.GetSize(),
                        "url":          result.Content.GetURL(),
                        "html_url":     result.Content.GetHTMLURL(),
                        "git_url":      result.Content.GetGitURL(),
                        "download_url": result.Content.GetDownloadURL(),
                        "type":         result.Content.GetType(),
                },
                "commit": map[string]interface{}{
                        "sha":      result.Commit.GetSHA(),
                        "url":      result.Commit.GetURL(),
                        "html_url": result.Commit.GetHTMLURL(),
                        "message":  result.Commit.GetMessage(),
                        "author": map[string]interface{}{
                                "name":  result.Commit.Author.GetName(),
                                "email": result.Commit.Author.GetEmail(),
                                "date":  result.Commit.Author.GetDate(),
                        },
                        "committer": map[string]interface{}{
                                "name":  result.Commit.Committer.GetName(),
                                "email": result.Commit.Committer.GetEmail(),
                                "date":  result.Commit.Committer.GetDate(),
                        },
                },
        }, nil</span>
}

// GetGitHubAsset fetches a GitHub asset (image, file, etc.) with authentication
func (s *GitHubService) GetGitHubAsset(ctx context.Context, userUUID, provider, assetURL string) ([]byte, string, error) <span class="cov5" title="10">{
        log := logger.WithContext(ctx).WithFields(map[string]interface{}{
                "asset_url": assetURL,
                "provider":  provider,
                "user_uuid": userUUID,
        })

        // Get access token from auth service
        accessToken, err := s.authService.GetGitHubAccessToken(userUUID, provider)
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Error("Failed to get access token from claims")
                return nil, "", fmt.Errorf("failed to get access token: %w", err)
        }</span>

        // Create HTTP request
        <span class="cov5" title="10">req, err := http.NewRequestWithContext(ctx, "GET", assetURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Add authorization header
        // GitHub asset URLs may require "token" prefix instead of "Bearer"
        <span class="cov5" title="10">req.Header.Set("Authorization", fmt.Sprintf("token %s", accessToken))
        req.Header.Set("Accept", "*/*")
        req.Header.Set("User-Agent", "Developer-Portal-Backend")

        // Make the request with redirect following
        // GitHub asset URLs redirect to media.github.tools.sap with a temporary token
        client := &amp;http.Client{
                Timeout: 30 * time.Second,
                CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                        // Follow up to 10 redirects (default)
                        if len(via) &gt;= 10 </span><span class="cov0" title="0">{
                                return fmt.Errorf("stopped after 10 redirects")
                        }</span>
                        // Preserve Authorization header only for same host
                        // Don't send OAuth token to media.github.tools.sap (it uses query param token)
                        <span class="cov0" title="0">if req.URL.Host != via[0].URL.Host </span><span class="cov0" title="0">{
                                req.Header.Del("Authorization")
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
        }
        <span class="cov5" title="10">resp, err := client.Do(req)
        if err != nil </span><span class="cov3" title="3">{
                log.WithError(err).Error("Failed to fetch GitHub asset")
                return nil, "", fmt.Errorf("failed to fetch asset: %w", err)
        }</span>
        <span class="cov4" title="7">defer resp.Body.Close()

        // Log response for debugging
        log.WithFields(map[string]interface{}{
                "status_code":    resp.StatusCode,
                "content_type":   resp.Header.Get("Content-Type"),
                "content_length": resp.Header.Get("Content-Length"),
        }).Debug("GitHub asset response received")

        // Check response status
        if resp.StatusCode == 403 </span><span class="cov1" title="1">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                log.WithFields(map[string]interface{}{
                        "response_body": string(bodyBytes),
                }).Warn("GitHub API rate limit exceeded for asset")
                return nil, "", apperrors.ErrGitHubAPIRateLimitExceeded
        }</span>
        <span class="cov4" title="6">if resp.StatusCode == 404 </span><span class="cov3" title="4">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                log.WithFields(map[string]interface{}{
                        "response_body": string(bodyBytes),
                }).Warn("GitHub asset not found")
                return nil, "", fmt.Errorf("GitHub asset not found at URL: %s", assetURL)
        }</span>
        <span class="cov2" title="2">if resp.StatusCode == 401 </span><span class="cov1" title="1">{
                // Read the error body to see what GitHub says
                bodyBytes, _ := io.ReadAll(resp.Body)
                log.WithFields(map[string]interface{}{
                        "response_body": string(bodyBytes),
                }).Error("GitHub authentication failed with 'token' prefix")

                // Try with "Bearer" prefix instead of "token"
                req2, _ := http.NewRequestWithContext(ctx, "GET", assetURL, nil)
                req2.Header.Set("Authorization", fmt.Sprintf("Bearer %s", accessToken))
                req2.Header.Set("Accept", "*/*")
                req2.Header.Set("User-Agent", "Developer-Portal-Backend")

                resp2, err2 := client.Do(req2)
                if err2 != nil </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("failed to fetch asset with Bearer auth: %w", err2)
                }</span>
                <span class="cov1" title="1">defer resp2.Body.Close()

                if resp2.StatusCode != 200 </span><span class="cov0" title="0">{
                        bodyBytes, _ := io.ReadAll(resp2.Body)
                        log.WithFields(map[string]interface{}{
                                "status_code": resp2.StatusCode,
                                "body":        string(bodyBytes),
                        }).Error("Authentication failed with both methods")
                        return nil, "", fmt.Errorf("authentication failed with both token and Bearer: status %d", resp2.StatusCode)
                }</span>

                <span class="cov1" title="1">resp = resp2
                log.Info("Successfully authenticated with 'Bearer' prefix")</span>
        } else<span class="cov1" title="1"> if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                log.WithFields(map[string]interface{}{
                        "status_code": resp.StatusCode,
                        "body":        string(bodyBytes),
                }).Error("Unexpected status code fetching asset")
                return nil, "", fmt.Errorf("unexpected status code: %d", resp.StatusCode)
        }</span>

        // Read response body
        <span class="cov2" title="2">assetData, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to read asset data: %w", err)
        }</span>

        // Get content type from response headers
        <span class="cov2" title="2">contentType := resp.Header.Get("Content-Type")
        if contentType == "" </span><span class="cov0" title="0">{
                contentType = "application/octet-stream"
        }</span>

        <span class="cov2" title="2">log.WithFields(map[string]interface{}{
                "size":         len(assetData),
                "content_type": contentType,
        }).Info("Successfully fetched GitHub asset")
        return assetData, contentType, nil</span>
}

func (s *GitHubService) ClosePullRequest(ctx context.Context, userUUID, provider, owner, repo string, prNumber int, deleteBranch bool) (*PullRequest, error) <span class="cov7" title="22">{
        if (userUUID == "") || (provider == "") </span><span class="cov3" title="4">{
                return nil, apperrors.ErrMissingUserUUIDAndProvider
        }</span>
        <span class="cov6" title="18">if owner == "" || repo == "" </span><span class="cov4" title="5">{
                return nil, apperrors.ErrOwnerAndRepositoryMissing
        }</span>

        // GitHub access token using validated JWT claims
        <span class="cov6" title="13">accessToken, err := s.authService.GetGitHubAccessToken(userUUID, provider)
        if err != nil </span><span class="cov3" title="4">{
                return nil, fmt.Errorf("failed to get GitHub access token: %w", err)
        }</span>

        // Get GitHub client configuration for the user's provider
        <span class="cov5" title="9">githubClientConfig, err := s.authService.GetGitHubClient(provider)
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("failed to get GitHub client: %w", err)
        }</span>

        // Create OAuth2 client with access token
        <span class="cov4" title="7">ts := oauth2.StaticTokenSource(
                &amp;oauth2.Token{AccessToken: accessToken},
        )
        tc := oauth2.NewClient(ctx, ts)

        // Create authenticated GitHub client
        var client *github.Client
        if githubClientConfig != nil &amp;&amp; githubClientConfig.GetEnterpriseBaseURL() != "" </span><span class="cov4" title="7">{
                client, err = github.NewEnterpriseClient(githubClientConfig.GetEnterpriseBaseURL(), githubClientConfig.GetEnterpriseBaseURL(), tc)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create GitHub Enterprise client: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                client = github.NewClient(tc)
        }</span>

        // Fetch PR to ensure it exists and check current state, also get head branch
        <span class="cov4" title="7">pr, resp, err := client.PullRequests.Get(ctx, owner, repo, prNumber)
        if err != nil </span><span class="cov2" title="2">{
                if resp != nil &amp;&amp; resp.StatusCode == 403 </span><span class="cov1" title="1">{
                        return nil, apperrors.ErrGitHubAPIRateLimitExceeded
                }</span>
                <span class="cov1" title="1">if resp != nil &amp;&amp; resp.StatusCode == 404 </span><span class="cov1" title="1">{
                        return nil, apperrors.NewNotFoundError("pull request")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get pull request: %w", err)</span>
        }

        // Only close open PRs
        <span class="cov4" title="5">if strings.EqualFold(pr.GetState(), "closed") </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("%w: pull request is already closed", apperrors.ErrInvalidStatus)
        }</span>

        // Close the PR
        <span class="cov3" title="4">updated, resp, err := client.PullRequests.Edit(ctx, owner, repo, prNumber, &amp;github.PullRequest{
                State: github.String("closed"),
        })
        if err != nil </span><span class="cov0" title="0">{
                if resp != nil &amp;&amp; resp.StatusCode == 403 </span><span class="cov0" title="0">{
                        return nil, apperrors.ErrGitHubAPIRateLimitExceeded
                }</span>
                <span class="cov0" title="0">if resp != nil &amp;&amp; resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return nil, apperrors.NewNotFoundError("pull request")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to close pull request: %w", err)</span>
        }

        // Optionally delete the PR branch
        <span class="cov3" title="4">if deleteBranch </span><span class="cov3" title="3">{
                head := updated.GetHead()
                branch := head.GetRef()
                headRepo := head.GetRepo()
                headRepoName := repo
                headOwner := owner
                if headRepo != nil </span><span class="cov3" title="3">{
                        if headRepo.GetName() != "" </span><span class="cov3" title="3">{
                                headRepoName = headRepo.GetName()
                        }</span>
                        <span class="cov3" title="3">if headRepo.GetOwner() != nil &amp;&amp; headRepo.GetOwner().GetLogin() != "" </span><span class="cov3" title="3">{
                                headOwner = headRepo.GetOwner().GetLogin()
                        }</span>
                }
                <span class="cov3" title="3">if branch != "" &amp;&amp; headRepoName != "" &amp;&amp; headOwner != "" </span><span class="cov3" title="3">{
                        ref := fmt.Sprintf("heads/%s", branch)
                        delResp, delErr := client.Git.DeleteRef(ctx, headOwner, headRepoName, ref)
                        if delErr != nil </span><span class="cov1" title="1">{
                                if delResp != nil &amp;&amp; delResp.StatusCode == 403 </span><span class="cov0" title="0">{
                                        return nil, apperrors.ErrGitHubAPIRateLimitExceeded
                                }</span>
                                // Ignore 404 (branch already deleted or not found)
                                <span class="cov1" title="1">if delResp == nil || delResp.StatusCode != 404 </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to delete branch '%s' in %s/%s: %w", branch, headOwner, headRepoName, delErr)
                                }</span>
                        }
                }
        }

        // Convert to our PullRequest structure
        <span class="cov3" title="4">result := PullRequest{
                ID:        updated.GetID(),
                Number:    updated.GetNumber(),
                Title:     updated.GetTitle(),
                State:     updated.GetState(),
                CreatedAt: updated.GetCreatedAt().Time,
                UpdatedAt: updated.GetUpdatedAt().Time,
                HTMLURL:   updated.GetHTMLURL(),
                Draft:     updated.GetDraft(),
                User: GitHubUser{
                        Login:     updated.GetUser().GetLogin(),
                        ID:        updated.GetUser().GetID(),
                        AvatarURL: updated.GetUser().GetAvatarURL(),
                },
                Repo: Repository{
                        Name:     repo,
                        FullName: owner + "/" + repo,
                        Owner:    owner,
                        Private:  false,
                },
        }

        return &amp;result, nil</span>
}

// GetUserPRReviewComments gets the total number of PR review comments made by the authenticated user
func (s *GitHubService) GetUserPRReviewComments(ctx context.Context, userUUID, provider, period string) (*PRReviewCommentsResponse, error) <span class="cov7" title="22">{
        if userUUID == "" || provider == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("userUUID and provider are required")
        }</span>

        // Parse period (default to 30 days)
        <span class="cov6" title="21">var from, to time.Time
        var parsedPeriod string
        var err error

        if period == "" </span><span class="cov2" title="2">{
                period = "30d"
        }</span>

        // Validate period format
        <span class="cov6" title="21">if len(period) &lt; 2 || period[len(period)-1] != 'd' </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: period must be in format '&lt;number&gt;d' (e.g., '30d', '90d', '365d')", apperrors.ErrInvalidPeriodFormat)
        }</span>

        // Parse custom period and calculate date range
        <span class="cov6" title="21">from, to, parsedPeriod, err = parsePeriod(period)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("%w: %w", apperrors.ErrInvalidPeriodFormat, err)
        }</span>

        // Get GitHub access token using validated JWT claims
        <span class="cov6" title="20">accessToken, err := s.authService.GetGitHubAccessToken(userUUID, provider)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get GitHub access token: %w", err)
        }</span>

        // Get GitHub client configuration for the user's provider
        <span class="cov6" title="19">githubClientConfig, err := s.authService.GetGitHubClient(provider)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get GitHub client: %w", err)
        }</span>

        // Create OAuth2 client with access token
        <span class="cov6" title="18">ts := oauth2.StaticTokenSource(
                &amp;oauth2.Token{AccessToken: accessToken},
        )
        tc := oauth2.NewClient(ctx, ts)

        // Create authenticated GitHub client
        var client *github.Client
        if githubClientConfig != nil &amp;&amp; githubClientConfig.GetEnterpriseBaseURL() != "" </span><span class="cov6" title="16">{
                client, err = github.NewEnterpriseClient(githubClientConfig.GetEnterpriseBaseURL(), githubClientConfig.GetEnterpriseBaseURL(), tc)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to create GitHub Enterprise client: %w", err)
                }</span>
        } else<span class="cov2" title="2"> {
                client = github.NewClient(tc)
        }</span>

        // Get the authenticated user
        <span class="cov6" title="17">user, resp, err := client.Users.Get(ctx, "")
        if err != nil </span><span class="cov4" title="5">{
                if resp != nil &amp;&amp; resp.StatusCode == 403 </span><span class="cov1" title="1">{
                        return nil, apperrors.ErrGitHubAPIRateLimitExceeded
                }</span>
                <span class="cov3" title="4">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        <span class="cov5" title="12">username := user.GetLogin()

        // Search for pull request review comments by the user within the time period
        query := fmt.Sprintf("type:pr reviewed-by:%s created:%s..%s",
                username,
                from.Format("2006-01-02"),
                to.Format("2006-01-02"))

        searchOpts := &amp;github.SearchOptions{
                ListOptions: github.ListOptions{
                        PerPage: 100,
                        Page:    1,
                },
        }

        totalComments := 0

        // Paginate through all results
        for </span><span class="cov6" title="14">{
                result, resp, err := client.Search.Issues(ctx, query, searchOpts)
                if err != nil </span><span class="cov1" title="1">{
                        if resp != nil &amp;&amp; resp.StatusCode == 403 </span><span class="cov1" title="1">{
                                return nil, apperrors.ErrGitHubAPIRateLimitExceeded
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("failed to search PR review comments: %w", err)</span>
                }

                <span class="cov6" title="13">totalComments += result.GetTotal()

                // Check if there are more pages
                if resp.NextPage == 0 </span><span class="cov5" title="11">{
                        break</span>
                }
                <span class="cov2" title="2">searchOpts.Page = resp.NextPage</span>
        }

        <span class="cov5" title="11">return &amp;PRReviewCommentsResponse{
                TotalComments: totalComments,
                Period:        parsedPeriod,
                From:          from.Format(time.RFC3339),
                To:            to.Format(time.RFC3339),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package service

import (
        "fmt"

        "developer-portal-backend/internal/auth"
)

//go:generate mockgen -source=github_auth_interface.go -destination=../mocks/github_auth_mocks.go -package=mocks

// GitHubAuthService defines the interface for auth service methods needed by GitHub service
type GitHubAuthService interface {
        GetGitHubClient(provider string) (*auth.GitHubClient, error)
        GetGitHubAccessToken(userUUID, provider string) (string, error)
}

// authServiceAdapter adapts auth.AuthService to implement GitHubAuthService interface
type authServiceAdapter struct {
        authService *auth.AuthService
}

func (a *authServiceAdapter) GetGitHubAccessToken(userUUID, provider string) (string, error) <span class="cov6" title="3">{
        if a.authService == nil </span><span class="cov6" title="3">{
                return "", fmt.Errorf("auth service is not initialized")
        }</span>
        <span class="cov0" title="0">return a.authService.GetGitHubAccessToken(userUUID, provider)</span>
}

// NewAuthServiceAdapter creates an adapter for auth.AuthService
func NewAuthServiceAdapter(authService *auth.AuthService) GitHubAuthService <span class="cov10" title="6">{
        if authService == nil </span><span class="cov10" title="6">{
                return &amp;authServiceAdapter{authService: nil}
        }</span>
        <span class="cov0" title="0">return &amp;authServiceAdapter{authService: authService}</span>
}

func (a *authServiceAdapter) GetGitHubClient(provider string) (*auth.GitHubClient, error) <span class="cov1" title="1">{
        if a.authService == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("auth service is not initialized")
        }</span>
        <span class="cov0" title="0">return a.authService.GetGitHubClient(provider)</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package service

import (
        "context"
        "crypto/tls"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "os"
        "strings"
        "time"

        "developer-portal-backend/internal/config"
        "developer-portal-backend/internal/errors"
        "developer-portal-backend/internal/logger"
)

// JenkinsService provides methods to interact with Jenkins JAAS instances
type JenkinsService struct {
        cfg        *config.Config
        httpClient *http.Client
}

// JenkinsTriggerResult holds the result of triggering a Jenkins job
type JenkinsTriggerResult struct {
        Status      string `json:"status"`      // "queued", "triggered", "failed"
        Message     string `json:"message"`     // Human-readable message
        QueueURL    string `json:"queueUrl"`    // URL to track the queued item (poll this to get build URL when job starts)
        QueueItemID string `json:"queueItemId"` // Queue item ID extracted from URL
        BaseJobURL  string `json:"baseJobUrl"`  // Base URL to the job definition (not specific build)
        JobName     string `json:"jobName"`     // Name of the triggered job
        JaasName    string `json:"jaasName"`    // JAAS instance name
}

// JenkinsQueueStatusResult holds the status of a queued Jenkins job
type JenkinsQueueStatusResult struct {
        Status       string `json:"status"`       // "queued", "running", "complete", "cancelled"
        BuildNumber  *int   `json:"buildNumber"`  // Build number if job has started (nullable)
        BuildURL     string `json:"buildUrl"`     // URL to the build if started
        QueuedReason string `json:"queuedReason"` // Reason item is in queue
        WaitTime     int    `json:"waitTime"`     // Time in seconds the item has been in queue
}

// JenkinsBuildStatusResult holds the status of a Jenkins build
type JenkinsBuildStatusResult struct {
        Status   string `json:"status"`   // "running", "success", "failure", "aborted", "unstable"
        Result   string `json:"result"`   // Jenkins result field (SUCCESS, FAILURE, UNSTABLE, ABORTED, null if still running)
        Building bool   `json:"building"` // Whether build is currently in progress
        Duration int64  `json:"duration"` // Duration in milliseconds (0 if still running)
        BuildURL string `json:"buildUrl"` // Full URL to the build
}

// NewJenkinsService creates a new Jenkins service
func NewJenkinsService(cfg *config.Config) *JenkinsService <span class="cov9" title="31">{
        // If no config provided, create empty config
        if cfg == nil </span><span class="cov2" title="2">{
                cfg = &amp;config.Config{}
        }</span>

        // Set default Jenkins base URL if not provided
        <span class="cov9" title="31">if cfg.JenkinsBaseURL == "" </span><span class="cov2" title="2">{
                cfg.JenkinsBaseURL = "https://{jaasName}.jaas-gcp.cloud.sap.corp"
        }</span>

        // Configure HTTP client with TLS settings
        // InsecureSkipVerify is set to true by default for SAP internal CAs
        <span class="cov9" title="31">transport := &amp;http.Transport{
                TLSClientConfig: &amp;tls.Config{
                        InsecureSkipVerify: cfg.JenkinsInsecureSkipVerify,
                },
        }

        return &amp;JenkinsService{
                cfg: cfg,
                httpClient: &amp;http.Client{
                        Timeout:   30 * time.Second,
                        Transport: transport,
                },
        }</span>
}

// getJenkinsCredentials retrieves Jenkins credentials from environment variables
// Expected env vars: JENKINS_{JAASNAME_UPPERCASE}_JAAS_TOKEN (instance-specific) and JENKINS_P_USER (global username)
func (s *JenkinsService) getJenkinsCredentials(ctx context.Context, jaasName string) (tokenName, token string, err error) <span class="cov10" title="45">{
        log := logger.WithContext(ctx)
        jaasNameUpper := strings.ToUpper(strings.ReplaceAll(jaasName, "-", "_"))

        tokenEnvVar := fmt.Sprintf("JENKINS_%s_JAAS_TOKEN", jaasNameUpper)
        userEnvVar := "JENKINS_P_USER"

        token = os.Getenv(tokenEnvVar)
        tokenName = os.Getenv(userEnvVar)

        if token == "" </span><span class="cov5" title="8">{
                log.Errorf("Jenkins token not found: missing %s environment variable", tokenEnvVar)
                return "", "", fmt.Errorf("%w: missing %s environment variable", errors.ErrJenkinsTokenNotFound, tokenEnvVar)
        }</span>

        <span class="cov9" title="37">if tokenName == "" </span><span class="cov1" title="1">{
                log.Errorf("Jenkins username not found: missing %s environment variable", userEnvVar)
                return "", "", fmt.Errorf("%w: missing %s environment variable", errors.ErrJenkinsUserNotFound, userEnvVar)
        }</span>

        <span class="cov9" title="36">return tokenName, token, nil</span>
}

// buildJenkinsURL constructs the Jenkins URL for a given JAAS instance and job
func (s *JenkinsService) buildJenkinsURL(jaasName, jobName string) string <span class="cov8" title="27">{
        // Replace {jaasName} placeholder in base URL
        baseURL := strings.Replace(s.cfg.JenkinsBaseURL, "{jaasName}", jaasName, -1)
        return fmt.Sprintf("%s/job/%s", baseURL, jobName)
}</span>

// GetJobParameters retrieves the parameters definition for a Jenkins job
func (s *JenkinsService) GetJobParameters(ctx context.Context, jaasName, jobName string) (interface{}, error) <span class="cov8" title="26">{
        log := logger.WithContext(ctx).WithFields(map[string]interface{}{
                "jaasName": jaasName,
                "jobName":  jobName,
        })

        log.Infof("Getting job parameters for Jenkins job")

        tokenName, token, err := s.getJenkinsCredentials(ctx, jaasName)
        if err != nil </span><span class="cov5" title="6">{
                log.Errorf("Failed to get Jenkins credentials: %v", err)
                return nil, err
        }</span>

        // Build the Jenkins API URL
        <span class="cov8" title="20">baseURL := s.buildJenkinsURL(jaasName, jobName)
        fullURL := fmt.Sprintf("%s/api/json?tree=property[parameterDefinitions[name,type,defaultParameterValue[value],choices,description]]", baseURL)

        log.Infof("Jenkins GET parameters request: url=%s", fullURL)

        req, err := http.NewRequest(http.MethodGet, fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set Basic Auth header using token name as username and token as password
        <span class="cov8" title="20">cred := base64.StdEncoding.EncodeToString([]byte(tokenName + ":" + token))
        req.Header.Set("Authorization", "Basic "+cred)
        req.Header.Set("Accept", "application/json")

        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Jenkins GET parameters request failed: %v", err)
                return nil, err
        }</span>
        <span class="cov8" title="20">defer resp.Body.Close()

        log.Infof("Jenkins GET parameters response: status=%d", resp.StatusCode)

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov2" title="2">{
                body, _ := io.ReadAll(resp.Body)
                log.Errorf("Jenkins GET parameters failed: status=%d, body=%s", resp.StatusCode, string(body))
                return nil, fmt.Errorf("jenkins request failed: status=%d body=%s", resp.StatusCode, string(body))
        }</span>

        // Decode the full JSON response
        <span class="cov7" title="18">var result map[string]interface{}
        dec := json.NewDecoder(resp.Body)
        if err := dec.Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to decode Jenkins response: %v", err)
                return nil, err
        }</span>

        // Filter to only return parameterDefinitions from hudson.model.ParametersDefinitionProperty
        <span class="cov7" title="18">filteredResult := s.filterParameterDefinitions(ctx, result)

        log.Info("Successfully retrieved job parameters")
        return filteredResult, nil</span>
}

// filterParameterDefinitions extracts parameterDefinitions from hudson.model.ParametersDefinitionProperty
func (s *JenkinsService) filterParameterDefinitions(ctx context.Context, response map[string]interface{}) interface{} <span class="cov7" title="18">{
        // Get the property array
        properties, ok := response["property"].([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return response
        }</span>

        // Find the ParametersDefinitionProperty
        <span class="cov7" title="18">for _, prop := range properties </span><span class="cov1" title="1">{
                propMap, ok := prop.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if this is the ParametersDefinitionProperty
                <span class="cov1" title="1">class, ok := propMap["_class"].(string)
                if !ok || class != "hudson.model.ParametersDefinitionProperty" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Extract parameterDefinitions
                <span class="cov1" title="1">paramDefs, ok := propMap["parameterDefinitions"]
                if !ok </span><span class="cov0" title="0">{
                        return map[string]interface{}{
                                "parameterDefinitions": []interface{}{},
                        }
                }</span>

                <span class="cov1" title="1">return map[string]interface{}{
                        "parameterDefinitions": paramDefs,
                }</span>
        }

        // If no ParametersDefinitionProperty found, return empty parameterDefinitions
        <span class="cov7" title="17">return map[string]interface{}{
                "parameterDefinitions": []interface{}{},
        }</span>
}

// TriggerJob triggers a Jenkins job with the provided parameters
func (s *JenkinsService) TriggerJob(ctx context.Context, jaasName, jobName string, parameters map[string]string) (*JenkinsTriggerResult, error) <span class="cov5" title="8">{
        log := logger.WithContext(ctx).WithFields(map[string]interface{}{
                "jaasName":   jaasName,
                "jobName":    jobName,
                "paramCount": len(parameters),
        })

        log.Info("Triggering Jenkins job")

        tokenName, token, err := s.getJenkinsCredentials(ctx, jaasName)
        if err != nil </span><span class="cov1" title="1">{
                log.Errorf("Failed to get Jenkins credentials: %v", err)
                return nil, err
        }</span>

        // Build the Jenkins trigger URL
        // Always use buildWithParameters endpoint - it works for both parameterized and non-parameterized jobs
        // Jenkins will use default values for any parameters not provided
        <span class="cov5" title="7">baseURL := s.buildJenkinsURL(jaasName, jobName)
        fullURL := fmt.Sprintf("%s/buildWithParameters", baseURL)

        if len(parameters) &gt; 0 </span><span class="cov5" title="6">{
                log.Infof("Jenkins trigger job with %d parameter(s): url=%s", len(parameters), fullURL)
        }</span> else<span class="cov1" title="1"> {
                log.Infof("Jenkins trigger job with default parameters: url=%s", fullURL)
        }</span>

        // Prepare form data (even if empty, Jenkins accepts empty form for defaults)
        <span class="cov5" title="7">formData := url.Values{}
        for key, value := range parameters </span><span class="cov6" title="11">{
                formData.Set(key, value)
        }</span>

        // Always POST with form-encoded body (empty form is valid)
        <span class="cov5" title="7">req, err := http.NewRequest(http.MethodPost, fullURL, strings.NewReader(formData.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="7">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

        // Set Basic Auth header using token name as username and token as password
        cred := base64.StdEncoding.EncodeToString([]byte(tokenName + ":" + token))
        req.Header.Set("Authorization", "Basic "+cred)

        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Jenkins trigger job request failed: %v", err)
                return nil, err
        }</span>
        <span class="cov5" title="7">defer resp.Body.Close()

        log.Infof("Jenkins trigger job response: status=%d", resp.StatusCode)

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                log.Errorf("Jenkins trigger job failed: status=%d, body=%s", resp.StatusCode, string(body))
                return nil, fmt.Errorf("jenkins trigger failed: status=%d body=%s", resp.StatusCode, string(body))
        }</span>

        // Extract queue URL from Location header
        <span class="cov5" title="7">queueURL := resp.Header.Get("Location")
        queueItemID := ""

        // Parse queue item ID from URL (e.g., https://jenkins/queue/item/12345/ -&gt; 12345)
        if queueURL != "" </span><span class="cov3" title="3">{
                parts := strings.Split(strings.TrimSuffix(queueURL, "/"), "/")
                if len(parts) &gt; 0 </span><span class="cov3" title="3">{
                        queueItemID = parts[len(parts)-1]
                }</span>
                <span class="cov3" title="3">log.Infof("Job queued with ID: %s, queue URL: %s", queueItemID, queueURL)</span>
        }

        // Build result
        <span class="cov5" title="7">result := &amp;JenkinsTriggerResult{
                Status:      "queued",
                Message:     "Job successfully queued in Jenkins",
                QueueURL:    queueURL,
                QueueItemID: queueItemID,
                BaseJobURL:  baseURL,
                JobName:     jobName,
                JaasName:    jaasName,
        }

        log.Info("Successfully triggered Jenkins job")
        return result, nil</span>
}

// GetQueueItemStatus retrieves the status of a queued Jenkins job
func (s *JenkinsService) GetQueueItemStatus(ctx context.Context, jaasName, queueItemID string) (*JenkinsQueueStatusResult, error) <span class="cov4" title="5">{
        log := logger.WithContext(ctx).WithFields(map[string]interface{}{
                "jaasName":    jaasName,
                "queueItemID": queueItemID,
        })

        log.Info("Getting Jenkins queue item status")

        // Get credentials
        tokenName, token, err := s.getJenkinsCredentials(ctx, jaasName)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Build queue item URL
        <span class="cov4" title="4">baseURL := strings.Replace(s.cfg.JenkinsBaseURL, "{jaasName}", jaasName, -1)
        queueURL := fmt.Sprintf("%s/queue/item/%s/api/json", baseURL, queueItemID)

        // Create request
        req, err := http.NewRequest(http.MethodGet, queueURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set Basic Auth header
        <span class="cov4" title="4">cred := base64.StdEncoding.EncodeToString([]byte(tokenName + ":" + token))
        req.Header.Set("Authorization", "Basic "+cred)

        // Execute request
        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Jenkins queue item request failed: %v", err)
                return nil, err
        }</span>
        <span class="cov4" title="4">defer resp.Body.Close()

        log.Infof("Jenkins queue item response: status=%d", resp.StatusCode)

        // Handle 404 - queue item not found
        if resp.StatusCode == http.StatusNotFound </span><span class="cov1" title="1">{
                log.Warnf("Queue item not found: %s", queueItemID)
                return nil, fmt.Errorf("%w: queue item %s", errors.ErrJenkinsQueueItemNotFound, queueItemID)
        }</span>

        <span class="cov3" title="3">if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                log.Errorf("Jenkins queue item request failed: status=%d, body=%s", resp.StatusCode, string(body))
                return nil, fmt.Errorf("jenkins queue item request failed: status=%d", resp.StatusCode)
        }</span>

        // Parse response
        <span class="cov3" title="3">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to read response body: %v", err)
                return nil, err
        }</span>

        <span class="cov3" title="3">var queueData struct {
                ID           int    `json:"id"`
                Why          string `json:"why"`
                InQueueSince int64  `json:"inQueueSince"`
                Cancelled    bool   `json:"cancelled"`
                Blocked      bool   `json:"blocked"`
                Buildable    bool   `json:"buildable"`
                Executable   *struct {
                        Number int    `json:"number"`
                        URL    string `json:"url"`
                } `json:"executable"`
        }

        if err := json.Unmarshal(body, &amp;queueData); err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to parse queue item response: %v", err)
                return nil, fmt.Errorf("failed to parse queue item response: %w", err)
        }</span>

        // Calculate wait time
        <span class="cov3" title="3">currentTime := time.Now().Unix() * 1000                        // Convert to milliseconds
        waitTime := int((currentTime - queueData.InQueueSince) / 1000) // Convert to seconds

        // Determine status
        status := "queued"
        var buildNumber *int
        buildURL := ""

        if queueData.Cancelled </span><span class="cov1" title="1">{
                status = "cancelled"
        }</span> else<span class="cov2" title="2"> if queueData.Executable != nil </span><span class="cov1" title="1">{
                // Job has started
                status = "running"
                buildNumber = &amp;queueData.Executable.Number
                buildURL = queueData.Executable.URL
                log.Infof("Queue item has started: build #%d", queueData.Executable.Number)
        }</span>

        <span class="cov3" title="3">result := &amp;JenkinsQueueStatusResult{
                Status:       status,
                BuildNumber:  buildNumber,
                BuildURL:     buildURL,
                QueuedReason: queueData.Why,
                WaitTime:     waitTime,
        }

        log.Info("Successfully retrieved queue item status")
        return result, nil</span>
}

// GetBuildStatus retrieves the status of a Jenkins build
func (s *JenkinsService) GetBuildStatus(ctx context.Context, jaasName, jobName string, buildNumber int) (*JenkinsBuildStatusResult, error) <span class="cov5" title="6">{
        log := logger.WithContext(ctx).WithFields(map[string]interface{}{
                "jaasName":    jaasName,
                "jobName":     jobName,
                "buildNumber": buildNumber,
        })

        log.Info("Getting Jenkins build status")

        // Get credentials
        tokenName, token, err := s.getJenkinsCredentials(ctx, jaasName)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Build URL
        <span class="cov4" title="5">baseURL := strings.Replace(s.cfg.JenkinsBaseURL, "{jaasName}", jaasName, -1)
        buildURL := fmt.Sprintf("%s/job/%s/%d/api/json", baseURL, jobName, buildNumber)

        // Create request
        req, err := http.NewRequest(http.MethodGet, buildURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set Basic Auth header
        <span class="cov4" title="5">cred := base64.StdEncoding.EncodeToString([]byte(tokenName + ":" + token))
        req.Header.Set("Authorization", "Basic "+cred)

        // Execute request
        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Jenkins build status request failed: %v", err)
                return nil, err
        }</span>
        <span class="cov4" title="5">defer resp.Body.Close()

        log.Infof("Jenkins build status response: status=%d", resp.StatusCode)

        // Handle 404 - build not found
        if resp.StatusCode == http.StatusNotFound </span><span class="cov1" title="1">{
                log.Warnf("Build not found: %s #%d", jobName, buildNumber)
                return nil, fmt.Errorf("%w: job %s build #%d", errors.ErrJenkinsBuildNotFound, jobName, buildNumber)
        }</span>

        <span class="cov4" title="4">if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                log.Errorf("Jenkins build status request failed: status=%d, body=%s", resp.StatusCode, string(body))
                return nil, fmt.Errorf("jenkins build status request failed: status=%d", resp.StatusCode)
        }</span>

        // Parse response
        <span class="cov4" title="4">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to read response body: %v", err)
                return nil, err
        }</span>

        <span class="cov4" title="4">var buildData struct {
                Number    int    `json:"number"`
                Result    string `json:"result"` // SUCCESS, FAILURE, UNSTABLE, ABORTED, or null
                Building  bool   `json:"building"`
                Duration  int64  `json:"duration"` // milliseconds
                URL       string `json:"url"`
                Timestamp int64  `json:"timestamp"`
        }

        if err := json.Unmarshal(body, &amp;buildData); err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to parse build status response: %v", err)
                return nil, fmt.Errorf("failed to parse build status response: %w", err)
        }</span>

        // Map Jenkins result to user-friendly status
        <span class="cov4" title="4">status := "running"
        if !buildData.Building </span><span class="cov3" title="3">{
                switch buildData.Result </span>{
                case "SUCCESS":<span class="cov1" title="1">
                        status = "success"</span>
                case "FAILURE":<span class="cov1" title="1">
                        status = "failure"</span>
                case "ABORTED":<span class="cov1" title="1">
                        status = "aborted"</span>
                case "UNSTABLE":<span class="cov0" title="0">
                        status = "unstable"</span>
                default:<span class="cov0" title="0">
                        status = "unknown"</span>
                }
        }

        <span class="cov4" title="4">result := &amp;JenkinsBuildStatusResult{
                Status:   status,
                Result:   buildData.Result,
                Building: buildData.Building,
                Duration: buildData.Duration,
                BuildURL: buildData.URL,
        }

        log.Infof("Build status: %s (result=%s, building=%v)", status, buildData.Result, buildData.Building)
        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package service

import (
        "bytes"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "net/url"
        "os"
        "strings"
        "sync"
        "time"

        "developer-portal-backend/internal/config"
        apperrors "developer-portal-backend/internal/errors"
)

// JiraService provides methods to interact with Jira
type JiraService struct {
        cfg        *config.Config
        httpClient *http.Client

        // Personal Access Token (PAT) management
        patToken  string
        patExpiry time.Time
        tokenMu   sync.Mutex

        // Fixed PAT name including machine identifier
        patName string
}

/**
 * NewJiraService creates a new Jira service
 */
func NewJiraService(cfg *config.Config) *JiraService <span class="cov8" title="54">{
        // PAT name is environment-scoped: "DeveloperPortal-&lt;env&gt;"
        envName := strings.TrimSpace(os.Getenv("DEPLOY_ENVIRONMENT"))
        if envName == "" </span><span class="cov8" title="54">{
                envName = strings.TrimSpace(os.Getenv("USER"))
        }</span>

        <span class="cov8" title="54">name := fmt.Sprintf("DeveloperPortal-%s", envName)
        // Print to console for visibility
        //log.Printf("Jira PAT name configured: %s", name)

        return &amp;JiraService{
                cfg:        cfg,
                httpClient: &amp;http.Client{Timeout: 15 * time.Second},
                patName:    name,
        }</span>
}

// patTokenResponse represents the response from Jira PAT creation endpoint
type patTokenResponse struct {
        ID         int    `json:"id"`
        Name       string `json:"name"`
        CreatedAt  string `json:"createdAt"`
        ExpiringAt string `json:"expiringAt"`
        RawToken   string `json:"rawToken"`
}

// InitializePATOnStartup deletes any existing PAT(s) with the fixed name and then creates a new one unconditionally.
// This should be called once on server startup to ensure a clean token lifecycle.
func (s *JiraService) InitializePATOnStartup() error <span class="cov4" title="6">{
        // Parse base URL from config (same handling as in searchIssues)
        base := s.cfg.JiraDomain
        if base == "" </span><span class="cov1" title="1">{
                return apperrors.ErrJiraConfigMissing
        }</span>
        <span class="cov4" title="5">baseURL, err := url.Parse(strings.TrimRight(base, "/"))
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid jira domain URL '%s': %w", base, err)
        }</span>
        <span class="cov3" title="4">if !strings.HasPrefix(base, "http://") &amp;&amp; !strings.HasPrefix(base, "https://") </span><span class="cov1" title="1">{
                base = "https://" + base
        }</span>

        // Cleanup any existing PAT(s) and always create a fresh one
        <span class="cov3" title="4">_, _, err = s.cleanupExistingPAT(baseURL)
        if err != nil </span><span class="cov3" title="4">{
                log.Printf("Jira PAT cleanup error for name=%s: %v", s.patName, err)
        }</span>

        <span class="cov3" title="4">return s.createPAT(baseURL)</span>
}

/*
cleanupExistingPAT finds PAT(s) by name and deletes all of them unconditionally.
Returns:
  - found:   whether a matching token with the fixed name exists
  - deleted: whether we deleted at least one matching token
*/
func (s *JiraService) cleanupExistingPAT(baseURL *url.URL) (bool, bool, error) <span class="cov4" title="7">{
        // GET all PATs
        listURL := baseURL.String() + "/rest/pat/latest/tokens"
        req, err := http.NewRequest(http.MethodGet, listURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return false, false, apperrors.NewJiraPATError("PAT list", fmt.Sprintf("failed to create PAT list request: %v", err))
        }</span>
        <span class="cov4" title="7">cred := base64.StdEncoding.EncodeToString([]byte(s.cfg.JiraUser + ":" + s.cfg.JiraPassword))
        req.Header.Set("Authorization", "Basic "+cred)
        req.Header.Set("Accept", "application/json")

        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov1" title="1">{
                return false, false, apperrors.NewJiraPATError("PAT list", fmt.Sprintf("request failed: %v", err))
        }</span>
        <span class="cov4" title="6">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov3" title="3">{
                body, _ := io.ReadAll(resp.Body)
                return false, false, apperrors.NewJiraPATError("PAT list", fmt.Sprintf("failed: status=%d body=%s", resp.StatusCode, string(body)))
        }</span>

        // Decode array of PATs
        <span class="cov3" title="3">var tokens []patTokenResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;tokens); err != nil </span><span class="cov0" title="0">{
                return false, false, apperrors.NewJiraPATError("PAT list", fmt.Sprintf("failed to decode PAT list: %v", err))
        }</span>

        <span class="cov3" title="3">found := false
        deletedAny := false
        for _, tok := range tokens </span><span class="cov3" title="3">{
                if tok.Name == s.patName </span><span class="cov3" title="3">{
                        found = true

                        // DELETE the token by id unconditionally
                        delURL := fmt.Sprintf("%s/rest/pat/latest/tokens/%d", baseURL.String(), tok.ID)
                        delReq, err := http.NewRequest(http.MethodDelete, delURL, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return found, deletedAny, apperrors.NewJiraPATError("PAT delete", fmt.Sprintf("failed to create PAT delete request: %v", err))
                        }</span>
                        <span class="cov3" title="3">delReq.Header.Set("Authorization", "Basic "+cred)
                        delReq.Header.Set("Accept", "application/json")

                        delResp, err := s.httpClient.Do(delReq)
                        if err != nil </span><span class="cov0" title="0">{
                                return found, deletedAny, apperrors.NewJiraPATError("PAT delete", fmt.Sprintf("PAT delete request failed: %v", err))
                        }</span>
                        <span class="cov3" title="3">defer delResp.Body.Close()

                        if delResp.StatusCode &lt; 200 || delResp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                                body, _ := io.ReadAll(delResp.Body)
                                return found, deletedAny, apperrors.NewJiraPATError("PAT delete", fmt.Sprintf("failed:status=%d body=%s", delResp.StatusCode, string(body)))
                        }</span> else<span class="cov3" title="3"> {
                                log.Printf("Jira PAT '%s' was found and deleted", s.patName)
                        }</span>
                        <span class="cov3" title="3">deletedAny = true</span>
                }
        }

        <span class="cov3" title="3">return found, deletedAny, nil</span>
}

// createPAT creates a new Personal Access Token via Jira PAT endpoint using Basic auth.
func (s *JiraService) createPAT(baseURL *url.URL) error <span class="cov5" title="10">{
        if s.cfg.JiraUser == "" || s.cfg.JiraPassword == "" </span><span class="cov1" title="1">{
                log.Printf("ERROR: Jira credentials missing - user=%s password_set=%v", s.cfg.JiraUser, s.cfg.JiraPassword != "")
                return apperrors.ErrJiraConfigMissing
        }</span>

        // Build PAT creation URL
        <span class="cov5" title="9">patURL := baseURL.String() + "/rest/pat/latest/tokens"

        // Prepare request body
        type patCreateRequest struct {
                Name               string `json:"name"`
                ExpirationDuration int    `json:"expirationDuration"`
        }
        reqBody := patCreateRequest{
                Name:               s.patName,
                ExpirationDuration: 90, // 90 days as requested (number, not string)
        }
        bodyBytes, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return apperrors.NewJiraPATError("PAT create", fmt.Sprintf("failed to encode PAT create body: %v", err))
        }</span>

        // Create HTTP request
        <span class="cov5" title="9">req, err := http.NewRequest(http.MethodPost, patURL, bytes.NewBuffer(bodyBytes))
        if err != nil </span><span class="cov0" title="0">{
                return apperrors.NewJiraPATError("PAT create", fmt.Sprintf("failed to create PAT HTTP request: %v", err))
        }</span>
        // Basic auth with configured Jira credentials
        <span class="cov5" title="9">cred := base64.StdEncoding.EncodeToString([]byte(s.cfg.JiraUser + ":" + s.cfg.JiraPassword))
        req.Header.Set("Authorization", "Basic "+cred)
        req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept", "application/json")

        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov1" title="1">{
                log.Printf("ERROR: Jira PAT HTTP request failed: %v", err)
                return apperrors.NewJiraPATError("PAT create", fmt.Sprintf("PAT request failed: %v", err))
        }</span>
        <span class="cov5" title="8">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov3" title="3">{
                body, _ := io.ReadAll(resp.Body)
                log.Printf("ERROR: Jira PAT creation failed: status=%d body=%s", resp.StatusCode, string(body))
                return apperrors.NewJiraPATError("PAT create", fmt.Sprintf("PAT creation failed: status=%d body=%s", resp.StatusCode, string(body)))
        }</span>

        <span class="cov4" title="5">var patResp patTokenResponse
        dec := json.NewDecoder(resp.Body)
        if err := dec.Decode(&amp;patResp); err != nil </span><span class="cov1" title="1">{
                return apperrors.NewJiraPATError("PAT create", fmt.Sprintf("failed to decode PAT response: %v", err))
        }</span>

        <span class="cov3" title="4">if patResp.RawToken == "" || patResp.ExpiringAt == "" </span><span class="cov2" title="2">{
                return apperrors.NewJiraPATError("PAT create", "PAT response missing token or expiry")
        }</span>

        // Parse expiry time (RFC3339 with fractional seconds)
        <span class="cov2" title="2">expiry, err := time.Parse(time.RFC3339Nano, patResp.ExpiringAt)
        if err != nil </span><span class="cov1" title="1">{
                return apperrors.NewJiraPATError("PAT create", fmt.Sprintf("failed to parse PAT expiringAt: %v", err))
        }</span>

        <span class="cov1" title="1">s.patToken = patResp.RawToken
        s.patExpiry = expiry
        log.Printf("Jira PAT '%s' was created successfully. Expiration: %s", patResp.Name, patResp.ExpiringAt)

        return nil</span>
}

type jiraSearchResponse struct {
        Total  int         `json:"total"`
        Issues []JiraIssue `json:"issues"`
}

// JiraIssue represents a Jira issue in search results
type JiraIssue struct {
        ID      string          `json:"id"`
        Key     string          `json:"key"`
        Fields  JiraIssueFields `json:"fields"`
        Project string          `json:"project,omitempty"`
        Link    string          `json:"link,omitempty"`
}

// JiraIssueFields represents the fields of a Jira issue
type JiraIssueFields struct {
        Summary     string          `json:"summary"`
        Status      JiraStatus      `json:"status"`
        IssueType   JiraIssueType   `json:"issuetype"`
        Priority    JiraPriority    `json:"priority,omitempty"`
        Assignee    *JiraUser       `json:"assignee,omitempty"`
        Reporter    *JiraUser       `json:"reporter,omitempty"`
        Created     string          `json:"created"`
        Updated     string          `json:"updated"`
        Description string          `json:"description,omitempty"`
        Labels      []string        `json:"labels,omitempty"`
        Components  []JiraComponent `json:"components,omitempty"`
        Parent      *JiraParent     `json:"parent,omitempty"`
        Subtasks    []JiraSubtask   `json:"subtasks,omitempty"`
}

// JiraParent represents the parent issue of a subtask
type JiraParent struct {
        ID     string           `json:"id"`
        Key    string           `json:"key"`
        Fields JiraParentFields `json:"fields"`
}

// JiraParentFields represents basic fields of a parent issue
type JiraParentFields struct {
        Summary   string        `json:"summary"`
        Status    JiraStatus    `json:"status"`
        IssueType JiraIssueType `json:"issuetype"`
        Priority  JiraPriority  `json:"priority"`
}

// JiraSubtask represents a subtask of an issue
type JiraSubtask struct {
        ID     string            `json:"id"`
        Key    string            `json:"key"`
        Fields JiraSubtaskFields `json:"fields"`
}

// JiraSubtaskFields represents basic fields of a subtask
type JiraSubtaskFields struct {
        Summary   string        `json:"summary"`
        Status    JiraStatus    `json:"status"`
        IssueType JiraIssueType `json:"issuetype"`
        Priority  JiraPriority  `json:"priority"`
}

// JiraStatus represents the status of a Jira issue
type JiraStatus struct {
        ID   string `json:"id"`
        Name string `json:"name"`
}

// JiraIssueType represents the type of a Jira issue
type JiraIssueType struct {
        ID   string `json:"id"`
        Name string `json:"name"`
}

// JiraPriority represents the priority of a Jira issue
type JiraPriority struct {
        ID   string `json:"id"`
        Name string `json:"name"`
}

// JiraUser represents a Jira user
type JiraUser struct {
        AccountID    string `json:"accountId"`
        DisplayName  string `json:"displayName"`
        EmailAddress string `json:"emailAddress,omitempty"`
}

// JiraComponent represents a Jira component
type JiraComponent struct {
        ID   string `json:"id"`
        Name string `json:"name"`
}

// JiraIssuesResponse represents the response for issue search endpoints
type JiraIssuesResponse struct {
        Issues []JiraIssue `json:"issues"`
        Total  int         `json:"total"`
        Page   int         `json:"page,omitempty"`
        Limit  int         `json:"limit,omitempty"`
}

// JiraIssueFilters represents the filters for Jira issue search
type JiraIssueFilters struct {
        Project  string // Real Jira project key (e.g., "SAPBTPCFS")
        Status   string // Real Jira status values (e.g., "Open,In Progress,Re Opened")
        Team     string // Team name for filtering
        User     string // Username (for user-specific searches)
        Date     string // Date for date-based filtering (yyyy-MM-dd format)
        Assignee string // Assignee username for filtering
        Type     string // Issue type (e.g., "Bug,Task,Story")
        Summary  string // Free text search in summary
        Key      string // Specific issue key (e.g., "BUG-1234")
        Page     int    // Page number for pagination (1-based)
        Limit    int    // Number of items per page (max 100)
}

// GetIssues returns Jira issues based on the provided filters.
func (s *JiraService) GetIssues(filters JiraIssueFilters) (*JiraIssuesResponse, error) <span class="cov7" title="36">{
        if s.cfg.JiraDomain == "" || s.cfg.JiraUser == "" || s.cfg.JiraPassword == "" </span><span class="cov3" title="4">{
                return nil, apperrors.ErrJiraConfigMissing
        }</span>

        <span class="cov7" title="32">jql, err := s.buildJQL(filters)
        if err != nil </span><span class="cov5" title="9">{
                return nil, fmt.Errorf("failed to build JQL query: %w", err)
        }</span>

        <span class="cov7" title="23">return s.searchIssues(jql, filters, false)</span>
}

// GetIssuesCount returns the count of Jira issues based on the provided filters.
func (s *JiraService) GetIssuesCount(filters JiraIssueFilters) (int, error) <span class="cov4" title="6">{
        if s.cfg.JiraDomain == "" || s.cfg.JiraUser == "" || s.cfg.JiraPassword == "" </span><span class="cov3" title="3">{
                return 0, apperrors.ErrJiraConfigMissing
        }</span>

        <span class="cov3" title="3">jql, err := s.buildJQL(filters)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to build JQL query: %w", err)
        }</span>

        <span class="cov3" title="3">response, err := s.searchIssues(jql, filters, true)
        if err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>
        <span class="cov2" title="2">return response.Total, nil</span>
}

// buildJQL constructs the JQL query based on the provided filters with validation
func (s *JiraService) buildJQL(filters JiraIssueFilters) (string, error) <span class="cov7" title="35">{
        var conditions []string

        // Project filter - use real Jira project key with validation
        if filters.Project != "" </span><span class="cov6" title="16">{
                if err := s.validateJQLValue(filters.Project); err != nil </span><span class="cov1" title="1">{
                        return "", fmt.Errorf("invalid project value: %w", err)
                }</span>
                <span class="cov6" title="15">conditions = append(conditions, fmt.Sprintf(`project = "%s"`, s.escapeJQLValue(filters.Project)))</span>
        }

        // Status filter - use real Jira status values with validation
        <span class="cov7" title="34">if filters.Status != "" </span><span class="cov6" title="20">{
                // Handle comma-separated status values
                statusValues := strings.Split(filters.Status, ",")
                var validatedStatuses []string
                for _, status := range statusValues </span><span class="cov7" title="34">{
                        status = strings.TrimSpace(status)
                        if err := s.validateJQLValue(status); err != nil </span><span class="cov1" title="1">{
                                return "", fmt.Errorf("invalid status value '%s': %w", status, err)
                        }</span>
                        <span class="cov7" title="33">validatedStatuses = append(validatedStatuses, fmt.Sprintf(`"%s"`, s.escapeJQLValue(status)))</span>
                }
                <span class="cov6" title="19">if len(validatedStatuses) == 1 </span><span class="cov5" title="11">{
                        conditions = append(conditions, fmt.Sprintf(`status = %s`, validatedStatuses[0]))
                }</span> else<span class="cov5" title="8"> {
                        conditions = append(conditions, fmt.Sprintf(`status IN (%s)`, strings.Join(validatedStatuses, ", ")))
                }</span>
        }

        // Team filter with validation
        <span class="cov7" title="33">if filters.Team != "" </span><span class="cov3" title="4">{
                if err := s.validateJQLValue(filters.Team); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("invalid team value: %w", err)
                }</span>
                <span class="cov3" title="4">conditions = append(conditions, fmt.Sprintf(`"Team(s)" = "%s"`, s.escapeJQLValue(filters.Team)))</span>
        }

        // User filter with validation
        <span class="cov7" title="33">if filters.User != "" </span><span class="cov4" title="7">{
                if err := s.validateJQLValue(filters.User); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("invalid user value: %w", err)
                }</span>
                <span class="cov4" title="7">conditions = append(conditions, fmt.Sprintf(`assignee = "%s"`, s.escapeJQLValue(filters.User)))</span>
        }

        // Assignee filter with validation (separate from User filter)
        <span class="cov7" title="33">if filters.Assignee != "" </span><span class="cov4" title="5">{
                if err := s.validateJQLValue(filters.Assignee); err != nil </span><span class="cov2" title="2">{
                        return "", fmt.Errorf("invalid assignee value: %w", err)
                }</span>
                <span class="cov3" title="3">conditions = append(conditions, fmt.Sprintf(`assignee = "%s"`, s.escapeJQLValue(filters.Assignee)))</span>
        }

        // Type filter with validation (issue type)
        <span class="cov7" title="31">if filters.Type != "" </span><span class="cov4" title="5">{
                // Handle comma-separated type values
                typeValues := strings.Split(filters.Type, ",")
                var validatedTypes []string
                for _, issueType := range typeValues </span><span class="cov5" title="8">{
                        issueType = strings.TrimSpace(issueType)
                        if err := s.validateJQLValue(issueType); err != nil </span><span class="cov1" title="1">{
                                return "", fmt.Errorf("invalid type value '%s': %w", issueType, err)
                        }</span>
                        <span class="cov4" title="7">validatedTypes = append(validatedTypes, fmt.Sprintf(`"%s"`, s.escapeJQLValue(issueType)))</span>
                }
                <span class="cov3" title="4">if len(validatedTypes) == 1 </span><span class="cov2" title="2">{
                        conditions = append(conditions, fmt.Sprintf(`issuetype = %s`, validatedTypes[0]))
                }</span> else<span class="cov2" title="2"> {
                        conditions = append(conditions, fmt.Sprintf(`issuetype IN (%s)`, strings.Join(validatedTypes, ", ")))
                }</span>
        }

        // Summary filter with validation (text search)
        <span class="cov7" title="30">if filters.Summary != "" </span><span class="cov3" title="4">{
                if err := s.validateJQLValue(filters.Summary); err != nil </span><span class="cov1" title="1">{
                        return "", fmt.Errorf("invalid summary value: %w", err)
                }</span>
                // Use ~ for text search in summary field
                <span class="cov3" title="3">conditions = append(conditions, fmt.Sprintf(`summary ~ "%s"`, s.escapeJQLValue(filters.Summary)))</span>
        }

        // Key filter with validation (specific issue key)
        <span class="cov7" title="29">if filters.Key != "" </span><span class="cov3" title="3">{
                if err := s.validateJQLValue(filters.Key); err != nil </span><span class="cov1" title="1">{
                        return "", fmt.Errorf("invalid key value: %w", err)
                }</span>
                <span class="cov2" title="2">conditions = append(conditions, fmt.Sprintf(`key = "%s"`, s.escapeJQLValue(filters.Key)))</span>
        }

        // Date filter for resolved issues with validation
        <span class="cov7" title="28">if filters.Date != "" &amp;&amp; filters.User != "" &amp;&amp; strings.Contains(strings.ToLower(filters.Status), "resolved") </span><span class="cov3" title="4">{
                if err := s.validateDateFormat(filters.Date); err != nil </span><span class="cov1" title="1">{
                        return "", fmt.Errorf("invalid date format: %w", err)
                }</span>
                <span class="cov3" title="3">conditions = append(conditions, fmt.Sprintf(`status CHANGED TO "resolved" BY "%s" AFTER %s`, s.escapeJQLValue(filters.User), filters.Date))</span>
        }

        // Check if we have any search criteria at all
        <span class="cov7" title="27">if filters.Project == "" &amp;&amp; filters.Status == "" &amp;&amp; filters.Team == "" &amp;&amp; filters.User == "" &amp;&amp;
                filters.Assignee == "" &amp;&amp; filters.Type == "" &amp;&amp; filters.Summary == "" &amp;&amp; filters.Key == "" </span><span class="cov1" title="1">{
                return "", fmt.Errorf("at least one search criterion must be provided (project, status, team, user, assignee, type, summary, or key)")
        }</span>

        <span class="cov7" title="26">if len(conditions) == 0 </span><span class="cov0" title="0">{
                // This should not happen if validation above is correct, but keeping as safety check
                return "", fmt.Errorf("no valid search conditions generated")
        }</span>

        <span class="cov7" title="26">jql := strings.Join(conditions, " AND ")

        // Add ordering for consistent pagination (part of JQL, not URL parameter)
        jql += " ORDER BY created DESC"

        // Validate final JQL length
        if len(jql) &gt; 8000 </span><span class="cov0" title="0">{ // Jira has a practical limit on JQL length
                return "", fmt.Errorf("generated JQL query is too long (%d characters, max 8000)", len(jql))
        }</span>

        <span class="cov7" title="26">log.Printf("Generated JQL: %s", jql)
        return jql, nil</span>
}

// validateJQLValue validates a value to be used in JQL queries
func (s *JiraService) validateJQLValue(value string) error <span class="cov9" title="81">{
        if value == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("value cannot be empty")
        }</span>

        // Check for potentially dangerous characters
        <span class="cov9" title="81">if strings.ContainsAny(value, "\n\r\t") </span><span class="cov4" title="6">{
                return fmt.Errorf("value contains invalid characters (newlines or tabs)")
        }</span>

        // Check for excessively long values
        <span class="cov9" title="75">if len(value) &gt; 255 </span><span class="cov1" title="1">{
                return fmt.Errorf("value is too long (max 255 characters)")
        }</span>

        <span class="cov9" title="74">return nil</span>
}

// escapeJQLValue escapes special characters in JQL values
func (s *JiraService) escapeJQLValue(value string) string <span class="cov9" title="77">{
        // Escape double quotes by doubling them
        return strings.ReplaceAll(value, `"`, `""`)
}</span>

// validateDateFormat validates date format for JQL queries
func (s *JiraService) validateDateFormat(date string) error <span class="cov3" title="4">{
        if _, err := time.Parse("2006-01-02", date); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("date must be in yyyy-MM-dd format")
        }</span>
        <span class="cov3" title="3">return nil</span>
}

// searchIssues is a helper method to perform Jira issue searches with pagination support
func (s *JiraService) searchIssues(jql string, filters JiraIssueFilters, countOnly bool) (*JiraIssuesResponse, error) <span class="cov7" title="26">{
        // Validate and parse base URL
        base := s.cfg.JiraDomain
        if base == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("jira domain is not configured")
        }</span>

        // Ensure proper URL scheme
        <span class="cov7" title="26">if !strings.HasPrefix(base, "http://") &amp;&amp; !strings.HasPrefix(base, "https://") </span><span class="cov2" title="2">{
                base = "https://" + base
        }</span>

        // Parse and validate the base URL
        <span class="cov7" title="26">baseURL, err := url.Parse(strings.TrimRight(base, "/"))
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid jira domain URL '%s': %w", base, err)
        }</span>

        // Build request URL with proper URL encoding
        <span class="cov7" title="25">values := url.Values{}
        values.Set("jql", jql)

        if countOnly </span><span class="cov3" title="3">{
                values.Set("maxResults", "0") // Only get count
        }</span> else<span class="cov7" title="22"> {
                // Set pagination parameters
                limit := filters.Limit
                if limit &lt;= 0 </span><span class="cov6" title="21">{
                        limit = 50 // Default limit
                }</span>
                <span class="cov7" title="22">if limit &gt; 100 </span><span class="cov0" title="0">{
                        limit = 100 // Max limit
                }</span>

                <span class="cov7" title="22">page := filters.Page
                if page &lt;= 0 </span><span class="cov6" title="21">{
                        page = 1 // Default page
                }</span>

                // Calculate startAt for Jira API (0-based)
                <span class="cov7" title="22">startAt := (page - 1) * limit

                values.Set("maxResults", fmt.Sprintf("%d", limit))
                values.Set("startAt", fmt.Sprintf("%d", startAt))

                // Optimize field selection for better performance
                values.Set("fields", "key,summary,status,issuetype,priority,assignee,created,updated,parent,subtasks")</span>
        }

        // Construct the full URL safely
        <span class="cov7" title="25">searchPath := "/rest/api/2/search"
        fullURL := baseURL.String() + searchPath + "?" + values.Encode()

        // Validate final URL length (browsers and servers have limits)
        if len(fullURL) &gt; 2048 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("constructed URL is too long (%d characters, max 2048)", len(fullURL))
        }</span>

        <span class="cov7" title="25">log.Printf("Jira search URL: %s", fullURL)

        req, err := http.NewRequest(http.MethodGet, fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create HTTP request: %w", err)
        }</span>

        // Use startup-created PAT if present; otherwise use Basic auth (no on-demand PAT creation)
        <span class="cov7" title="25">if s.patToken != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+s.patToken)
        }</span> else<span class="cov7" title="25"> {
                cred := base64.StdEncoding.EncodeToString([]byte(s.cfg.JiraUser + ":" + s.cfg.JiraPassword))
                req.Header.Set("Authorization", "Basic "+cred)
        }</span>
        <span class="cov7" title="25">req.Header.Set("Accept", "application/json")

        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR: Jira HTTP request failed: %v", err)
                return nil, err
        }</span>
        <span class="cov7" title="25">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov5" title="11">{
                body, _ := io.ReadAll(resp.Body)
                log.Printf("ERROR: Jira API request failed: status=%d url=%s body=%s", resp.StatusCode, fullURL, string(body))
                return nil, fmt.Errorf("jira search failed: status=%d body=%s", resp.StatusCode, string(body))
        }</span>

        <span class="cov6" title="14">var parsed jiraSearchResponse
        dec := json.NewDecoder(resp.Body)
        if err := dec.Decode(&amp;parsed); err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR: Failed to decode Jira response: %v", err)
                return nil, err
        }</span>

        // Enhance issues with project and link information
        <span class="cov6" title="14">enhancedIssues := make([]JiraIssue, len(parsed.Issues))
        for i, issue := range parsed.Issues </span><span class="cov10" title="102">{
                enhancedIssues[i] = issue

                // Extract project key from issue key (e.g., "SAPBTPCFS-123" -&gt; "SAPBTPCFS")
                if issue.Key != "" </span><span class="cov4" title="6">{
                        parts := strings.Split(issue.Key, "-")
                        if len(parts) &gt; 0 </span><span class="cov4" title="6">{
                                enhancedIssues[i].Project = parts[0]
                        }</span>
                }

                // Generate issue link
                <span class="cov10" title="102">if issue.Key != "" </span><span class="cov4" title="6">{
                        enhancedIssues[i].Link = fmt.Sprintf("%s/browse/%s", baseURL.String(), issue.Key)
                }</span>
        }

        <span class="cov6" title="14">response := &amp;JiraIssuesResponse{
                Issues: enhancedIssues,
                Total:  parsed.Total,
        }

        // Add pagination metadata for non-count queries
        if !countOnly </span><span class="cov5" title="12">{
                limit := filters.Limit
                if limit &lt;= 0 </span><span class="cov5" title="11">{
                        limit = 50
                }</span>
                <span class="cov5" title="12">if limit &gt; 100 </span><span class="cov0" title="0">{
                        limit = 100
                }</span>

                <span class="cov5" title="12">page := filters.Page
                if page &lt;= 0 </span><span class="cov5" title="11">{
                        page = 1
                }</span>

                <span class="cov5" title="12">response.Page = page
                response.Limit = limit</span>
        }

        <span class="cov6" title="14">return response, nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package service

import (
        "developer-portal-backend/internal/cache"
        "developer-portal-backend/internal/database/models"
        apperrors "developer-portal-backend/internal/errors"
        "developer-portal-backend/internal/repository"
        "encoding/json"
        "errors"
        "fmt"

        "github.com/go-playground/validator/v10"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

// LandscapeService handles business logic for landscapes
type LandscapeService struct {
        repo             repository.LandscapeRepositoryInterface
        organizationRepo repository.OrganizationRepositoryInterface
        projectRepo      repository.ProjectRepositoryInterface
        validator        *validator.Validate
        cache            cache.CacheService
        ttlConfig        cache.TTLConfig
}

// NewLandscapeService creates a new landscape service
func NewLandscapeService(repo repository.LandscapeRepositoryInterface, orgRepo repository.OrganizationRepositoryInterface, projectRepo repository.ProjectRepositoryInterface, validator *validator.Validate) *LandscapeService <span class="cov0" title="0">{
        return &amp;LandscapeService{
                repo:             repo,
                organizationRepo: orgRepo,
                projectRepo:      projectRepo,
                validator:        validator,
                cache:            cache.NewNoOpCache(), // Default to no-op cache
                ttlConfig:        cache.DefaultTTLConfig(),
        }
}</span>

// NewLandscapeServiceWithCache creates a new landscape service with caching support
func NewLandscapeServiceWithCache(
        repo repository.LandscapeRepositoryInterface,
        orgRepo repository.OrganizationRepositoryInterface,
        projectRepo repository.ProjectRepositoryInterface,
        validator *validator.Validate,
        cacheService cache.CacheService,
        ttlConfig cache.TTLConfig,
) *LandscapeService <span class="cov10" title="70">{
        return &amp;LandscapeService{
                repo:             repo,
                organizationRepo: orgRepo,
                projectRepo:      projectRepo,
                validator:        validator,
                cache:            cacheService,
                ttlConfig:        ttlConfig,
        }
}</span>

// SetCache sets the cache service (useful for testing or late initialization)
func (s *LandscapeService) SetCache(cacheService cache.CacheService) <span class="cov0" title="0">{
        s.cache = cacheService
}</span>

// SetTTLConfig sets the TTL configuration
func (s *LandscapeService) SetTTLConfig(config cache.TTLConfig) <span class="cov0" title="0">{
        s.ttlConfig = config
}</span>

// CreateLandscapeRequest represents the request to create a landscape (new model)
type CreateLandscapeRequest struct {
        Name        string          `json:"name" validate:"required,min=1,max=40"`
        Title       string          `json:"title" validate:"required,min=1,max=100"`
        Description string          `json:"description,omitempty" validate:"max=200"`
        ProjectID   uuid.UUID       `json:"project_id" validate:"required"`
        Domain      string          `json:"domain" validate:"required,max=200"`
        Environment string          `json:"environment" validate:"required,max=20"`
        Metadata    json.RawMessage `json:"metadata,omitempty" swaggertype:"object"`
}

// UpdateLandscapeRequest represents the request to update a landscape (new model)
type UpdateLandscapeRequest struct {
        Title       string          `json:"title" validate:"required,min=1,max=100"`
        Description string          `json:"description,omitempty" validate:"max=200"`
        ProjectID   *uuid.UUID      `json:"project_id,omitempty"`
        Domain      string          `json:"domain,omitempty" validate:"max=200"`
        Environment string          `json:"environment,omitempty" validate:"max=20"`
        Metadata    json.RawMessage `json:"metadata,omitempty" swaggertype:"object"`
}

// LandscapeResponse represents the response for landscape operations (new model)
type LandscapeResponse struct {
        ID          uuid.UUID       `json:"id"`
        Name        string          `json:"name"`
        Title       string          `json:"title"`
        Description string          `json:"description"`
        ProjectID   uuid.UUID       `json:"project_id"`
        Domain      string          `json:"domain"`
        Environment string          `json:"environment"`
        Metadata    json.RawMessage `json:"metadata,omitempty" swaggertype:"object"`
        CreatedAt   string          `json:"created_at"`
        UpdatedAt   string          `json:"updated_at"`
}

// LandscapeMinimalResponse represents a trimmed landscape projection for list endpoints
type LandscapeMinimalResponse struct {
        ID          uuid.UUID `json:"id"`
        Name        string    `json:"name"`
        Title       string    `json:"title"`
        Description string    `json:"description"`

        Auditlog         string `json:"auditlog,omitempty"`
        Cam              string `json:"cam,omitempty"`
        Cockpit          string `json:"cockpit,omitempty"`
        Concourse        string `json:"concourse,omitempty"`
        ControlCenter    string `json:"control-center,omitempty"`
        Domain           string `json:"domain"`
        Dynatrace        string `json:"dynatrace,omitempty"`
        Environment      string `json:"environment"`
        Extension        bool   `json:"extension,omitempty"`
        Gardener         string `json:"gardener,omitempty"`
        Git              string `json:"git,omitempty"`
        Grafana          string `json:"grafana,omitempty"`
        Health           string `json:"health,omitempty"`
        IaasConsole      string `json:"iaas-console,omitempty"`
        IsCentralRegion  bool   `json:"is-central-region,omitempty"`
        Kibana           string `json:"kibana,omitempty"`
        Monitoring       string `json:"monitoring,omitempty"`
        OperationConsole string `json:"operation-console,omitempty"`
        Plutono          string `json:"plutono,omitempty"`
        Prometheus       string `json:"prometheus,omitempty"`
        Type             string `json:"type,omitempty"`
}

// LandscapeListResponse represents a paginated list of landscapes
type LandscapeListResponse struct {
        Landscapes []LandscapeResponse `json:"landscapes"`
        Total      int64               `json:"total"`
        Page       int                 `json:"page"`
        PageSize   int                 `json:"page_size"`
}

// CreateLandscape creates a new landscape
func (s *LandscapeService) CreateLandscape(req *CreateLandscapeRequest) (*LandscapeResponse, error) <span class="cov3" title="3">{
        // Validate request
        if err := s.validator.Struct(req); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        // Check if landscape with same name exists (global scope in new model)
        <span class="cov3" title="3">existingByName, err := s.repo.GetByName(req.Name)
        if err != nil &amp;&amp; !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check existing landscape by name: %w", err)
        }</span>
        <span class="cov3" title="3">if existingByName != nil </span><span class="cov1" title="1">{
                return nil, apperrors.ErrLandscapeExists
        }</span>

        // Create landscape (new model)
        <span class="cov2" title="2">landscape := &amp;models.Landscape{
                BaseModel: models.BaseModel{
                        Name:        req.Name,
                        Title:       req.Title,
                        Description: req.Description,
                        Metadata:    req.Metadata,
                },
                ProjectID:   req.ProjectID,
                Domain:      req.Domain,
                Environment: req.Environment,
        }

        if err := s.repo.Create(landscape); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to create landscape: %w", err)
        }</span>

        // Invalidate relevant caches after creation
        <span class="cov1" title="1">s.invalidateLandscapeCaches(landscape)

        return s.toResponse(landscape), nil</span>
}

// GetLandscapeByID retrieves a landscape by ID with caching
func (s *LandscapeService) GetLandscapeByID(id uuid.UUID) (*LandscapeResponse, error) <span class="cov3" title="3">{
        cacheKey := cache.BuildKey(cache.KeyPrefixLandscapeByID, id.String())

        // Create a cache wrapper for this operation
        wrapper := cache.NewCacheWrapper[*LandscapeResponse](s.cache)

        return wrapper.GetOrFetch(cacheKey, s.ttlConfig.LandscapeByID, func() (*LandscapeResponse, error) </span><span class="cov3" title="3">{
                landscape, err := s.repo.GetByID(id)
                if err != nil </span><span class="cov2" title="2">{
                        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                                return nil, apperrors.ErrLandscapeNotFound
                        }</span>
                        <span class="cov1" title="1">return nil, fmt.Errorf("failed to get landscape: %w", err)</span>
                }
                <span class="cov1" title="1">return s.toResponse(landscape), nil</span>
        })
}

// GetByName retrieves a landscape by name with caching (organization scope not applicable in new model)
func (s *LandscapeService) GetByName(_ uuid.UUID, name string) (*LandscapeResponse, error) <span class="cov3" title="3">{
        cacheKey := cache.BuildKey(cache.KeyPrefixLandscapeByName, name)

        wrapper := cache.NewCacheWrapper[*LandscapeResponse](s.cache)

        return wrapper.GetOrFetch(cacheKey, s.ttlConfig.LandscapeByName, func() (*LandscapeResponse, error) </span><span class="cov3" title="3">{
                landscape, err := s.repo.GetByName(name)
                if err != nil </span><span class="cov2" title="2">{
                        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                                return nil, apperrors.ErrLandscapeNotFound
                        }</span>
                        <span class="cov1" title="1">return nil, fmt.Errorf("failed to get landscape: %w", err)</span>
                }
                <span class="cov1" title="1">return s.toResponse(landscape), nil</span>
        })
}

// GetLandscapesByOrganization retrieves landscapes for an organization with pagination and caching
// Note: organization scope is not present in the new model; returns all landscapes paginated.
func (s *LandscapeService) GetLandscapesByOrganization(_ uuid.UUID, limit, offset int) ([]LandscapeResponse, int64, error) <span class="cov5" title="10">{
        if limit &lt; 1 || limit &gt; 100 </span><span class="cov3" title="4">{
                limit = 20
        }</span>

        <span class="cov5" title="10">cacheKey := cache.BuildKey(cache.KeyPrefixLandscapeList, fmt.Sprintf("limit:%d:offset:%d", limit, offset))

        type cachedResult struct {
                Responses []LandscapeResponse `json:"responses"`
                Total     int64               `json:"total"`
        }

        wrapper := cache.NewCacheWrapper[cachedResult](s.cache)

        result, err := wrapper.GetOrFetch(cacheKey, s.ttlConfig.LandscapeList, func() (cachedResult, error) </span><span class="cov5" title="10">{
                landscapes, total, repoErr := s.repo.GetActiveLandscapes(limit, offset)
                if repoErr != nil </span><span class="cov1" title="1">{
                        return cachedResult{}, fmt.Errorf("failed to get landscapes: %w", repoErr)
                }</span>

                <span class="cov5" title="9">responses := make([]LandscapeResponse, len(landscapes))
                for i, landscape := range landscapes </span><span class="cov2" title="2">{
                        responses[i] = *s.toResponse(&amp;landscape)
                }</span>

                <span class="cov5" title="9">return cachedResult{Responses: responses, Total: total}, nil</span>
        })

        <span class="cov5" title="10">if err != nil </span><span class="cov1" title="1">{
                return nil, 0, err
        }</span>

        <span class="cov5" title="9">return result.Responses, result.Total, nil</span>
}

// GetByProjectName retrieves landscapes by project name with pagination and caching
func (s *LandscapeService) GetByProjectName(projectName string) (*LandscapeListResponse, error) <span class="cov4" title="6">{
        cacheKey := cache.BuildKey(cache.KeyPrefixLandscapeByProject, projectName)

        wrapper := cache.NewCacheWrapper[*LandscapeListResponse](s.cache)

        return wrapper.GetOrFetch(cacheKey, s.ttlConfig.LandscapeByProject, func() (*LandscapeListResponse, error) </span><span class="cov4" title="6">{
                // Get project by name
                project, err := s.projectRepo.GetByName(projectName)
                if err != nil </span><span class="cov3" title="3">{
                        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov2" title="2">{
                                return nil, apperrors.ErrProjectNotFound
                        }</span>
                        <span class="cov1" title="1">return nil, fmt.Errorf("failed to find project: %w", err)</span>
                }

                // Check if project is nil
                <span class="cov3" title="3">if project == nil </span><span class="cov1" title="1">{
                        return nil, apperrors.ErrProjectNotFound
                }</span>

                // Get landscapes by project ID (using active landscapes query with project filter)
                <span class="cov2" title="2">landscapes, total, err := s.repo.GetLandscapesByProjectID(project.ID, 100, 0)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to get landscapes by project: %w", err)
                }</span>

                <span class="cov1" title="1">responses := make([]LandscapeResponse, len(landscapes))
                for i, landscape := range landscapes </span><span class="cov1" title="1">{
                        responses[i] = *s.toResponse(&amp;landscape)
                }</span>

                <span class="cov1" title="1">return &amp;LandscapeListResponse{
                        Landscapes: responses,
                        Total:      total,
                        Page:       1,
                        PageSize:   100,
                }, nil</span>
        })
}

// GetByProjectNameAll retrieves all landscapes by project name (minimal response) with caching
func (s *LandscapeService) GetByProjectNameAll(projectName string) ([]LandscapeMinimalResponse, error) <span class="cov4" title="6">{
        cacheKey := cache.BuildKey(cache.KeyPrefixLandscapeByProject, projectName, "all")

        wrapper := cache.NewCacheWrapper[[]LandscapeMinimalResponse](s.cache)

        return wrapper.GetOrFetch(cacheKey, s.ttlConfig.LandscapeByProject, func() ([]LandscapeMinimalResponse, error) </span><span class="cov4" title="5">{
                // Get project by name
                project, err := s.projectRepo.GetByName(projectName)
                if err != nil </span><span class="cov2" title="2">{
                        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                                return nil, apperrors.ErrProjectNotFound
                        }</span>
                        <span class="cov1" title="1">return nil, fmt.Errorf("failed to find project: %w", err)</span>
                }

                // Get all landscapes by project ID
                <span class="cov3" title="3">landscapes, _, err := s.repo.GetLandscapesByProjectID(project.ID, 1000, 0)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to get landscapes by project: %w", err)
                }</span>

                <span class="cov2" title="2">responses := make([]LandscapeMinimalResponse, len(landscapes))
                for i, landscape := range landscapes </span><span class="cov2" title="2">{
                        responses[i] = s.toMinimalResponse(&amp;landscape)
                }</span>

                <span class="cov2" title="2">return responses, nil</span>
        })
}

// ListByQuery searches landscapes with filters and caching
func (s *LandscapeService) ListByQuery(q string, domains []string, environments []string, limit int, offset int) (*LandscapeListResponse, error) <span class="cov6" title="14">{
        // Validate limit to prevent divide by zero
        if limit &lt; 1 </span><span class="cov2" title="2">{
                limit = 20
        }</span>

        // Convert limit/offset to page/pageSize
        <span class="cov6" title="14">page := (offset / limit) + 1
        pageSize := limit

        // For now, use basic search (filters can be enhanced later)
        return s.Search(uuid.Nil, q, page, pageSize)</span>
}

// Search searches landscapes by name, title, or description with caching (org ignored)
func (s *LandscapeService) Search(_ uuid.UUID, query string, page, pageSize int) (*LandscapeListResponse, error) <span class="cov8" title="28">{
        if page &lt; 1 </span><span class="cov2" title="2">{
                page = 1
        }</span>
        <span class="cov8" title="28">if pageSize &lt; 1 || pageSize &gt; 100 </span><span class="cov3" title="4">{
                pageSize = 20
        }</span>

        <span class="cov8" title="28">offset := (page - 1) * pageSize
        cacheKey := cache.BuildKey(cache.KeyPrefixLandscapeSearch, fmt.Sprintf("q:%s:page:%d:size:%d", query, page, pageSize))

        wrapper := cache.NewCacheWrapper[*LandscapeListResponse](s.cache)

        return wrapper.GetOrFetch(cacheKey, s.ttlConfig.LandscapeSearch, func() (*LandscapeListResponse, error) </span><span class="cov7" title="26">{
                landscapes, total, err := s.repo.Search(uuid.Nil, query, pageSize, offset)
                if err != nil </span><span class="cov2" title="2">{
                        return nil, fmt.Errorf("failed to search landscapes: %w", err)
                }</span>

                <span class="cov7" title="24">responses := make([]LandscapeResponse, len(landscapes))
                for i, landscape := range landscapes </span><span class="cov5" title="7">{
                        responses[i] = *s.toResponse(&amp;landscape)
                }</span>

                <span class="cov7" title="24">return &amp;LandscapeListResponse{
                        Landscapes: responses,
                        Total:      total,
                        Page:       page,
                        PageSize:   pageSize,
                }, nil</span>
        })
}

// UpdateLandscape updates a landscape
func (s *LandscapeService) UpdateLandscape(id uuid.UUID, req *UpdateLandscapeRequest) (*LandscapeResponse, error) <span class="cov5" title="7">{
        // Validate request
        if err := s.validator.Struct(req); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        // Get existing landscape
        <span class="cov4" title="6">landscape, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        return nil, apperrors.ErrLandscapeNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get landscape: %w", err)</span>
        }

        // Update fields aligned with new model
        <span class="cov4" title="5">landscape.Title = req.Title
        landscape.Description = req.Description
        if req.ProjectID != nil </span><span class="cov2" title="2">{
                landscape.ProjectID = *req.ProjectID
        }</span>
        <span class="cov4" title="5">if req.Domain != "" </span><span class="cov2" title="2">{
                landscape.Domain = req.Domain
        }</span>
        <span class="cov4" title="5">if req.Environment != "" </span><span class="cov2" title="2">{
                landscape.Environment = req.Environment
        }</span>
        <span class="cov4" title="5">if req.Metadata != nil </span><span class="cov1" title="1">{
                landscape.Metadata = req.Metadata
        }</span>

        <span class="cov4" title="5">if err := s.repo.Update(landscape); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to update landscape: %w", err)
        }</span>

        // Invalidate caches after update
        <span class="cov3" title="4">s.invalidateLandscapeCaches(landscape)

        return s.toResponse(landscape), nil</span>
}

// DeleteLandscape deletes a landscape
func (s *LandscapeService) DeleteLandscape(id uuid.UUID) error <span class="cov3" title="4">{
        // Check if landscape exists and get it for cache invalidation
        landscape, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov2" title="2">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        return apperrors.ErrLandscapeNotFound
                }</span>
                <span class="cov1" title="1">return fmt.Errorf("failed to get landscape: %w", err)</span>
        }

        <span class="cov2" title="2">if err := s.repo.Delete(id); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to delete landscape: %w", err)
        }</span>

        // Invalidate caches after deletion
        <span class="cov1" title="1">s.invalidateLandscapeCaches(landscape)

        return nil</span>
}

// SetStatus sets the status of a landscape (no-op in new model; kept for API compatibility)
func (s *LandscapeService) SetStatus(id uuid.UUID, status string) error <span class="cov3" title="4">{
        // Check if landscape exists
        landscape, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov2" title="2">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        return apperrors.ErrLandscapeNotFound
                }</span>
                <span class="cov1" title="1">return fmt.Errorf("failed to get landscape: %w", err)</span>
        }

        <span class="cov2" title="2">if err := s.repo.SetStatus(id, status); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to set landscape status: %w", err)
        }</span>

        // Invalidate caches after status change
        <span class="cov1" title="1">s.invalidateLandscapeCaches(landscape)

        return nil</span>
}

// GetWithOrganization retrieves a landscape with organization details (no org relation in new model)
func (s *LandscapeService) GetWithOrganization(id uuid.UUID) (*models.Landscape, error) <span class="cov3" title="3">{
        landscape, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov2" title="2">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        return nil, apperrors.ErrLandscapeNotFound
                }</span>
                <span class="cov1" title="1">return nil, fmt.Errorf("failed to get landscape: %w", err)</span>
        }

        <span class="cov1" title="1">return landscape, nil</span>
}

// invalidateLandscapeCaches invalidates all cache entries related to a landscape
func (s *LandscapeService) invalidateLandscapeCaches(landscape *models.Landscape) <span class="cov5" title="7">{
        // Invalidate by ID
        _ = s.cache.Delete(cache.BuildKey(cache.KeyPrefixLandscapeByID, landscape.ID.String()))

        // Invalidate by name
        _ = s.cache.Delete(cache.BuildKey(cache.KeyPrefixLandscapeByName, landscape.Name))

        // Clear list caches (they will be rebuilt on next request)
        // Note: For a more sophisticated implementation, you might want to track all
        // cache keys and invalidate them selectively
        s.cache.Clear()
}</span>

// InvalidateAllCaches clears all landscape-related caches
func (s *LandscapeService) InvalidateAllCaches() <span class="cov0" title="0">{
        s.cache.Clear()
}</span>

// toResponse converts a landscape model to response
func (s *LandscapeService) toResponse(landscape *models.Landscape) *LandscapeResponse <span class="cov7" title="17">{
        return &amp;LandscapeResponse{
                ID:          landscape.ID,
                Name:        landscape.Name,
                Title:       landscape.Title,
                Description: landscape.Description,
                ProjectID:   landscape.ProjectID,
                Domain:      landscape.Domain,
                Environment: landscape.Environment,
                Metadata:    landscape.Metadata,
                CreatedAt:   landscape.CreatedAt.Format("2006-01-02T15:04:05Z"),
                UpdatedAt:   landscape.UpdatedAt.Format("2006-01-02T15:04:05Z"),
        }
}</span>

// toMinimalResponse converts a landscape model to minimal response with metadata enrichment
func (s *LandscapeService) toMinimalResponse(landscape *models.Landscape) LandscapeMinimalResponse <span class="cov2" title="2">{
        resp := LandscapeMinimalResponse{
                ID:          landscape.ID,
                Name:        landscape.Name,
                Title:       landscape.Title,
                Description: landscape.Description,
                Domain:      landscape.Domain,
                Environment: landscape.Environment,
        }

        // Enrich from metadata if present
        if len(landscape.Metadata) &gt; 0 </span><span class="cov2" title="2">{
                var m map[string]interface{}
                if err := json.Unmarshal(landscape.Metadata, &amp;m); err == nil </span><span class="cov2" title="2">{
                        resp = s.enrichMinimalResponse(resp, m)
                }</span>
        }

        <span class="cov2" title="2">return resp</span>
}

// enrichMinimalResponse enriches minimal response with metadata fields
func (s *LandscapeService) enrichMinimalResponse(enr LandscapeMinimalResponse, m map[string]interface{}) LandscapeMinimalResponse <span class="cov2" title="2">{
        if auditlog, ok := m["auditlog"].(string); ok &amp;&amp; auditlog != "" </span><span class="cov0" title="0">{
                enr.Auditlog = auditlog
        }</span>
        <span class="cov2" title="2">if cam, ok := m["cam"].(string); ok &amp;&amp; cam != "" </span><span class="cov0" title="0">{
                enr.Cam = cam
        }</span>
        <span class="cov2" title="2">if cockpit, ok := m["cockpit"].(string); ok &amp;&amp; cockpit != "" </span><span class="cov0" title="0">{
                enr.Cockpit = cockpit
        }</span>
        <span class="cov2" title="2">if concourse, ok := m["concourse"].(string); ok &amp;&amp; concourse != "" </span><span class="cov0" title="0">{
                enr.Concourse = concourse
        }</span>
        <span class="cov2" title="2">if controlCenter, ok := m["control-center"].(string); ok &amp;&amp; controlCenter != "" </span><span class="cov0" title="0">{
                enr.ControlCenter = controlCenter
        }</span>
        <span class="cov2" title="2">if dynatrace, ok := m["dynatrace"].(string); ok &amp;&amp; dynatrace != "" </span><span class="cov0" title="0">{
                enr.Dynatrace = dynatrace
        }</span>
        <span class="cov2" title="2">if extension, ok := m["extension"].(bool); ok </span><span class="cov0" title="0">{
                enr.Extension = extension
        }</span>
        <span class="cov2" title="2">if gardener, ok := m["gardener"].(string); ok &amp;&amp; gardener != "" </span><span class="cov0" title="0">{
                enr.Gardener = gardener
        }</span>
        <span class="cov2" title="2">if git, ok := m["git"].(string); ok &amp;&amp; git != "" </span><span class="cov0" title="0">{
                enr.Git = git
        }</span>
        <span class="cov2" title="2">if grafana, ok := m["grafana"].(string); ok &amp;&amp; grafana != "" </span><span class="cov2" title="2">{
                enr.Grafana = grafana
        }</span>
        <span class="cov2" title="2">if health, ok := m["health"].(string); ok &amp;&amp; health != "" </span><span class="cov1" title="1">{
                enr.Health = health
        }</span>
        <span class="cov2" title="2">if iaasConsole, ok := m["iaas-console"].(string); ok &amp;&amp; iaasConsole != "" </span><span class="cov0" title="0">{
                enr.IaasConsole = iaasConsole
        }</span>
        <span class="cov2" title="2">if isCentralRegion, ok := m["is-central-region"].(bool); ok </span><span class="cov0" title="0">{
                enr.IsCentralRegion = isCentralRegion
        }</span>
        <span class="cov2" title="2">if kibana, ok := m["kibana"].(string); ok &amp;&amp; kibana != "" </span><span class="cov0" title="0">{
                enr.Kibana = kibana
        }</span>
        <span class="cov2" title="2">if monitoring, ok := m["monitoring"].(string); ok &amp;&amp; monitoring != "" </span><span class="cov0" title="0">{
                enr.Monitoring = monitoring
        }</span>
        <span class="cov2" title="2">if operationConsole, ok := m["operation-console"].(string); ok &amp;&amp; operationConsole != "" </span><span class="cov0" title="0">{
                enr.OperationConsole = operationConsole
        }</span>
        <span class="cov2" title="2">if plutono, ok := m["plutono"].(string); ok &amp;&amp; plutono != "" </span><span class="cov0" title="0">{
                enr.Plutono = plutono
        }</span>
        <span class="cov2" title="2">if prometheus, ok := m["prometheus"].(string); ok &amp;&amp; prometheus != "" </span><span class="cov1" title="1">{
                enr.Prometheus = prometheus
        }</span>
        <span class="cov2" title="2">if landscapeType, ok := m["type"].(string); ok &amp;&amp; landscapeType != "" </span><span class="cov0" title="0">{
                enr.Type = landscapeType
        }</span>

        <span class="cov2" title="2">return enr</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package service

import (
        "crypto/tls"
        "strings"
        "time"

        "developer-portal-backend/internal/config"

        "github.com/go-ldap/ldap/v3"
)

 // Test hook and client abstraction for LDAP dialing; default uses ldap.DialTLS
type ldapClient interface {
        Bind(username, password string) error
        Search(searchRequest *ldap.SearchRequest) (*ldap.SearchResult, error)
        Close() error
        SetTimeout(time.Duration)
}

var dialLDAP = func(network, addr string, config *tls.Config) (ldapClient, error) <span class="cov0" title="0">{
        return ldap.DialTLS(network, addr, config)
}</span>

// LDAPUser represents a subset of LDAP user attributes returned by the search
type LDAPUser struct {
        DN          string `json:"dn"`
        DisplayName string `json:"displayName"`
        Mobile      string `json:"mobile"`
        SN          string `json:"sn"`
        Name        string `json:"name"`
        Mail        string `json:"mail"`
        GivenName   string `json:"givenName"`
}

// LDAPService provides methods to interact with LDAP
type LDAPService struct {
        cfg *config.Config
}

// NewLDAPService creates a new LDAP service
func NewLDAPService(cfg *config.Config) *LDAPService <span class="cov6" title="8">{
        return &amp;LDAPService{cfg: cfg}
}</span>

// SearchUsersByCN searches users by common name (cn prefix match)
func (s *LDAPService) SearchUsersByCN(cn string) ([]LDAPUser, error) <span class="cov6" title="8">{
        addr := s.cfg.LDAPHost + ":" + s.cfg.LDAPPort

        // Establish TLS connection to LDAP server
        l, err := dialLDAP("tcp", addr, &amp;tls.Config{InsecureSkipVerify: s.cfg.LDAPInsecureSkipVerify})
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov6" title="7">defer l.Close()

        // Set timeout
        if s.cfg.LDAPTimeoutSec &gt; 0 </span><span class="cov6" title="6">{
                l.SetTimeout(time.Duration(s.cfg.LDAPTimeoutSec) * time.Second)
        }</span>

        // Bind with configured credentials
        <span class="cov6" title="7">if err := l.Bind(s.cfg.LDAPBindDN, s.cfg.LDAPBindPW); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Build search request
        <span class="cov6" title="6">filter := "(cn=" + ldap.EscapeFilter(cn) + "*)"
        attrs := []string{"displayName", "mobile", "sn", "name", "mail", "givenName"}
        // Adjust base DN prefix based on first letter of search string (case-insensitive)
        baseDN := s.cfg.LDAPBaseDN
        if len(cn) &gt; 0 </span><span class="cov6" title="6">{
                switch strings.ToLower(string(cn[0])) </span>{
                case "i":<span class="cov1" title="1">
                        baseDN = "OU=I," + baseDN</span>
                case "d":<span class="cov1" title="1">
                        baseDN = "OU=D," + baseDN</span>
                case "c":<span class="cov1" title="1">
                        baseDN = "OU=C," + baseDN</span>
                }
        }

        <span class="cov6" title="6">req := ldap.NewSearchRequest(
                baseDN,
                ldap.ScopeWholeSubtree,
                ldap.NeverDerefAliases,
                0,
                s.cfg.LDAPTimeoutSec,
                false,
                filter,
                attrs,
                nil,
        )

        // Execute search
        res, err := l.Search(req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Map results
        <span class="cov5" title="5">out := make([]LDAPUser, 0, len(res.Entries))
        for _, e := range res.Entries </span><span class="cov4" title="4">{
                get := func(a string) string </span><span class="cov10" title="24">{ return e.GetAttributeValue(a) }</span>
                <span class="cov4" title="4">out = append(out, LDAPUser{
                        DN:          e.DN,
                        DisplayName: get("displayName"),
                        Mobile:      get("mobile"),
                        SN:          get("sn"),
                        Name:        get("name"),
                        Mail:        get("mail"),
                        GivenName:   get("givenName"),
                })</span>
        }

        <span class="cov5" title="5">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package service

import (
        "encoding/json"
        "fmt"
        "strings"

        "developer-portal-backend/internal/database/models"
        apperrors "developer-portal-backend/internal/errors"
        "developer-portal-backend/internal/logger"
        "developer-portal-backend/internal/repository"

        "github.com/go-playground/validator/v10"
        "github.com/google/uuid"
)

// LinkService provides link-related business logic
type LinkService struct {
        linkRepo     repository.LinkRepositoryInterface
        userRepo     repository.UserRepositoryInterface
        teamRepo     repository.TeamRepositoryInterface
        categoryRepo repository.CategoryRepositoryInterface
        validator    *validator.Validate
}

// Ensure LinkService implements LinkServiceInterface
var _ LinkServiceInterface = (*LinkService)(nil)

// NewLinkService creates a new LinkService
func NewLinkService(linkRepo repository.LinkRepositoryInterface, userRepo repository.UserRepositoryInterface, teamRepo repository.TeamRepositoryInterface, categoryRepo repository.CategoryRepositoryInterface, validator *validator.Validate) *LinkService <span class="cov9" title="32">{
        return &amp;LinkService{
                linkRepo:     linkRepo,
                userRepo:     userRepo,
                teamRepo:     teamRepo,
                categoryRepo: categoryRepo,
                validator:    validator,
        }
}</span>

// LinkResponse represents a link in API responses (omits audit and owner fields)
type LinkResponse struct {
        ID          string   `json:"id"`
        Name        string   `json:"name"`
        Title       string   `json:"title"`
        Description string   `json:"description"`
        URL         string   `json:"url"`
        CategoryID  string   `json:"category_id"`
        Tags        []string `json:"tags"`
        Favorite    bool     `json:"favorite,omitempty"`
}

// CreateLinkRequest represents the payload for creating a link
type CreateLinkRequest struct {
        Name        string `json:"name" validate:"required,min=1,max=40"`
        Description string `json:"description" validate:"max=200"`
        Owner       string `json:"owner" validate:"required,uuid4"`
        URL         string `json:"url" validate:"required,url,max=2000"`
        CategoryID  string `json:"category_id" validate:"required,uuid4"`
        Tags        string `json:"tags" validate:"max=200"` // optional CSV string
        CreatedBy   string `json:"-"`                       // derived from bearer token 'username'
}

// UpdateLinkRequest represents the payload for updating a link
type UpdateLinkRequest struct {
        Name        string `json:"name" validate:"required,min=1,max=40"`
        Description string `json:"description" validate:"max=200"`
        URL         string `json:"url" validate:"required,url,max=2000"`
        CategoryID  string `json:"category_id" validate:"required,uuid4"`
        Tags        string `json:"tags" validate:"max=200"` // optional CSV string
        UpdatedBy   string `json:"-"`                       // derived from bearer token 'username'
}

// CreateLink validates and creates a new link
func (s *LinkService) CreateLink(req *CreateLinkRequest) (*LinkResponse, error) <span class="cov6" title="10">{
        if err := s.validator.Struct(req); err != nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>
        <span class="cov6" title="7">if strings.TrimSpace(req.CreatedBy) == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("created_by is required")
        }</span>
        // Validate created_by is an existing users.user_id OR a team's name
        <span class="cov5" title="6">if _, err := s.userRepo.GetByUserID(req.CreatedBy); err != nil </span><span class="cov1" title="1">{
                if _, errTeam := s.teamRepo.GetByNameGlobal(req.CreatedBy); errTeam != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("created_by user or team not found")
                }</span>
        }

        <span class="cov5" title="5">ownerUUID, err := uuid.Parse(req.Owner)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid owner UUID: %w", err)
        }</span>
        <span class="cov5" title="5">categoryUUID, err := uuid.Parse(req.CategoryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid category_id UUID: %w", err)
        }</span>

        // Validate owner exists (either a user or a team)
        <span class="cov5" title="5">ownerValid := false
        if _, err := s.userRepo.GetByID(ownerUUID); err == nil </span><span class="cov4" title="4">{
                ownerValid = true
        }</span> else<span class="cov1" title="1"> if _, err := s.teamRepo.GetByID(ownerUUID); err == nil </span><span class="cov0" title="0">{
                ownerValid = true
        }</span>
        <span class="cov5" title="5">if !ownerValid </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("owner not found as user or team")
        }</span>

        // Validate category exists
        <span class="cov4" title="4">if _, err := s.categoryRepo.GetByID(categoryUUID); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("category not found")
        }</span>

        <span class="cov3" title="3">link := &amp;models.Link{
                BaseModel: models.BaseModel{
                        Name:        req.Name,
                        Title:       req.Name, // Title mirrors name per requirement
                        Description: req.Description,
                        CreatedBy:   req.CreatedBy,
                },
                Owner:      ownerUUID,
                URL:        req.URL,
                CategoryID: categoryUUID,
                Tags:       req.Tags,
        }

        if err := s.linkRepo.Create(link); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to create link: %w", err)
        }</span>

        <span class="cov2" title="2">res := toLinkResponse(link)
        return &amp;res, nil</span>
}

// UpdateLink validates and updates an existing link
func (s *LinkService) UpdateLink(id uuid.UUID, req *UpdateLinkRequest) (*LinkResponse, error) <span class="cov8" title="17">{
        log := logger.New().WithFields(map[string]interface{}{
                "operation":  "UpdateLink",
                "link_id":    id.String(),
                "updated_by": req.UpdatedBy,
                "link_name":  req.Name,
        })

        // Validate request structure
        if err := s.validator.Struct(req); err != nil </span><span class="cov6" title="8">{
                log.WithField("error", err.Error()).Warn("Link validation failed")
                return nil, apperrors.NewValidationError("", err.Error())
        }</span>

        <span class="cov6" title="9">if strings.TrimSpace(req.UpdatedBy) == "" </span><span class="cov2" title="2">{
                log.Warn("updated_by is missing")
                return nil, apperrors.NewValidationError("updated_by", "updated_by is required")
        }</span>

        // Validate updated_by is an existing users.user_id OR a team's name
        <span class="cov6" title="7">if _, err := s.userRepo.GetByUserID(req.UpdatedBy); err != nil </span><span class="cov2" title="2">{
                if _, errTeam := s.teamRepo.GetByNameGlobal(req.UpdatedBy); errTeam != nil </span><span class="cov1" title="1">{
                        log.WithField("updated_by", req.UpdatedBy).Warn("updated_by user or team not found")
                        return nil, apperrors.ErrUserOrTeamNotFound
                }</span>
        }

        // Get existing link
        <span class="cov5" title="6">link, err := s.linkRepo.GetByID(id)
        if err != nil </span><span class="cov1" title="1">{
                log.WithField("error", err.Error()).Warn("Link not found in database")
                return nil, apperrors.ErrLinkNotFound
        }</span>

        // Log the original state for audit trail
        <span class="cov5" title="5">log.WithFields(map[string]interface{}{
                "original_name":        link.Name,
                "original_url":         link.URL,
                "original_category_id": link.CategoryID.String(),
                "original_owner":       link.Owner.String(), // Log owner to verify it's not changed
        }).Debug("Retrieved link for update")

        categoryUUID, err := uuid.Parse(req.CategoryID)
        if err != nil </span><span class="cov0" title="0">{
                log.WithField("category_id", req.CategoryID).Warn("Invalid category_id UUID")
                return nil, apperrors.NewValidationError("category_id", "invalid UUID format")
        }</span>

        // Validate category exists
        <span class="cov5" title="5">if _, err := s.categoryRepo.GetByID(categoryUUID); err != nil </span><span class="cov1" title="1">{
                log.WithField("category_id", req.CategoryID).Warn("Category not found")
                return nil, apperrors.ErrCategoryNotFound
        }</span>

        // Update ONLY the allowed fields
        // SECURITY: Owner is intentionally NOT updated here to prevent ownership changes
        <span class="cov4" title="4">link.Name = req.Name
        link.Title = req.Name // Title mirrors name per requirement
        link.Description = req.Description
        link.URL = req.URL
        link.CategoryID = categoryUUID
        link.Tags = req.Tags
        link.UpdatedBy = req.UpdatedBy
        // link.Owner is NOT modified - ownership cannot be changed

        if err := s.linkRepo.Update(link); err != nil </span><span class="cov1" title="1">{
                log.WithField("error", err.Error()).Error("Failed to update link in database")
                return nil, fmt.Errorf("failed to update link: %w", err)
        }</span>

        <span class="cov3" title="3">log.WithFields(map[string]interface{}{
                "link_id":     link.ID.String(),
                "link_name":   link.Name,
                "url":         link.URL,
                "category_id": link.CategoryID.String(),
                "owner":       link.Owner.String(), // Verify owner unchanged
        }).Info("Link updated successfully in database")

        res := toLinkResponse(link)
        return &amp;res, nil</span>
}

// GetByOwnerUserID returns all links owned by the user with the given user_id
func (s *LinkService) GetByOwnerUserID(ownerUserID string) ([]LinkResponse, error) <span class="cov5" title="6">{
        if strings.TrimSpace(ownerUserID) == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("owner user_id is required")
        }</span>

        // Find user by user_id
        <span class="cov5" title="5">user, err := s.userRepo.GetByUserID(ownerUserID)
        if err != nil || user == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("owner user with user_id %q not found", ownerUserID)
        }</span>

        // Fetch links by owner UUID
        <span class="cov4" title="4">links, err := s.linkRepo.GetByOwner(user.ID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get links by owner: %w", err)
        }</span>

        // Map to response type, omitting audit and owner fields
        <span class="cov3" title="3">res := make([]LinkResponse, 0, len(links))
        for i := range links </span><span class="cov2" title="2">{
                res = append(res, toLinkResponse(&amp;links[i]))
        }</span>
        <span class="cov3" title="3">return res, nil</span>
}

// GetByOwnerUserIDWithViewer returns links owned by the given user and marks favorites based on viewer's favorites
func (s *LinkService) GetByOwnerUserIDWithViewer(ownerUserID string, viewerName string) ([]LinkResponse, error) <span class="cov4" title="4">{
        if strings.TrimSpace(ownerUserID) == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("owner user_id is required")
        }</span>
        <span class="cov4" title="4">if strings.TrimSpace(viewerName) == "" </span><span class="cov1" title="1">{
                // Fallback to non-favorite response if viewer missing
                return s.GetByOwnerUserID(ownerUserID)
        }</span>

        // Find owner by user_id
        <span class="cov3" title="3">owner, err := s.userRepo.GetByUserID(ownerUserID)
        if err != nil || owner == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("owner user with user_id %q not found", ownerUserID)
        }</span>

        // Find viewer by name (mapped from bearer token 'username')
        <span class="cov2" title="2">viewer, err := s.userRepo.GetByName(viewerName)
        if err != nil || viewer == nil </span><span class="cov1" title="1">{
                // Fallback to non-favorite response if viewer not found
                return s.GetByOwnerUserID(ownerUserID)
        }</span>

        // Parse favorites from viewer.Metadata
        <span class="cov1" title="1">favSet := make(map[uuid.UUID]struct{})
        if len(viewer.Metadata) &gt; 0 </span><span class="cov1" title="1">{
                var meta map[string]interface{}
                if err := json.Unmarshal(viewer.Metadata, &amp;meta); err == nil &amp;&amp; meta != nil </span><span class="cov1" title="1">{
                        if v, ok := meta["favorites"]; ok &amp;&amp; v != nil </span><span class="cov1" title="1">{
                                switch arr := v.(type) </span>{
                                case []interface{}:<span class="cov1" title="1">
                                        for _, it := range arr </span><span class="cov1" title="1">{
                                                if str, ok := it.(string); ok &amp;&amp; str != "" </span><span class="cov1" title="1">{
                                                        if id, err := uuid.Parse(strings.TrimSpace(str)); err == nil </span><span class="cov1" title="1">{
                                                                favSet[id] = struct{}{}
                                                        }</span>
                                                }
                                        }
                                case []string:<span class="cov0" title="0">
                                        for _, s2 := range arr </span><span class="cov0" title="0">{
                                                if id, err := uuid.Parse(strings.TrimSpace(s2)); err == nil </span><span class="cov0" title="0">{
                                                        favSet[id] = struct{}{}
                                                }</span>
                                        }
                                }
                        }
                }
        }

        // Fetch links by owner UUID
        <span class="cov1" title="1">links, err := s.linkRepo.GetByOwner(owner.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get links by owner: %w", err)
        }</span>

        // Map to response type, omitting audit and owner fields; mark favorites
        <span class="cov1" title="1">res := make([]LinkResponse, 0, len(links))
        for i := range links </span><span class="cov2" title="2">{
                lr := toLinkResponse(&amp;links[i])
                if _, ok := favSet[links[i].ID]; ok </span><span class="cov1" title="1">{
                        lr.Favorite = true
                }</span>
                <span class="cov2" title="2">res = append(res, lr)</span>
        }
        <span class="cov1" title="1">return res, nil</span>
}

func toLinkResponse(l *models.Link) LinkResponse <span class="cov10" title="33">{
        tags := make([]string, 0) // Initialize to empty slice instead of nil
        if strings.TrimSpace(l.Tags) != "" </span><span class="cov4" title="4">{
                parts := strings.Split(l.Tags, ",")
                for _, p := range parts </span><span class="cov6" title="8">{
                        if t := strings.TrimSpace(p); t != "" </span><span class="cov6" title="8">{
                                tags = append(tags, t)
                        }</span>
                }
        }

        <span class="cov10" title="33">return LinkResponse{
                ID:          l.ID.String(),
                Name:        l.Name,
                Title:       l.Title,
                Description: l.Description,
                URL:         l.URL,
                CategoryID:  l.CategoryID.String(),
                Tags:        tags,
        }</span>
}

// DeleteLink deletes a link by UUID
func (s *LinkService) DeleteLink(id uuid.UUID) error <span class="cov2" title="2">{
        // Delegate to repository; repository Delete is idempotent
        if err := s.linkRepo.Delete(id); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to delete link: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package service

import (
        "context"
        "encoding/json"
        "fmt"
        "net/url"
        "regexp"
        "strings"

        "developer-portal-backend/internal/database/models"
        "developer-portal-backend/internal/repository"

        "github.com/go-playground/validator/v10"
        "github.com/google/uuid"
)

// PluginService handles business logic for plugins
type PluginService struct {
        pluginRepo repository.PluginRepositoryInterface
        userRepo   repository.UserRepositoryInterface
        validator  *validator.Validate
}

// NewPluginService creates a new plugin service
func NewPluginService(pluginRepo repository.PluginRepositoryInterface, userRepo repository.UserRepositoryInterface, validator *validator.Validate) *PluginService <span class="cov10" title="33">{
        return &amp;PluginService{
                pluginRepo: pluginRepo,
                userRepo:   userRepo,
                validator:  validator,
        }
}</span>

// PluginResponse represents the response structure for a plugin
type PluginResponse struct {
        ID                 uuid.UUID `json:"id"`
        Name               string    `json:"name"`
        Title              string    `json:"title"`
        Description        string    `json:"description"`
        Icon               string    `json:"icon"`
        ReactComponentPath string    `json:"react_component_path"`
        BackendServerURL   string    `json:"backend_server_url"`
        Owner              string    `json:"owner"`
        Subscribed         bool      `json:"subscribed,omitempty"`
}

// PluginListResponse represents the response structure for plugin list
type PluginListResponse struct {
        Plugins []PluginResponse `json:"plugins"`
        Total   int64            `json:"total"`
        Limit   int              `json:"limit"`
        Offset  int              `json:"offset"`
}

// CreatePluginRequest represents the request structure for creating a plugin
type CreatePluginRequest struct {
        Name               string `json:"name" validate:"required,min=1,max=40"`
        Title              string `json:"title" validate:"required,min=1,max=100"`
        Description        string `json:"description" validate:"max=200"`
        Icon               string `json:"icon" validate:"required,min=3,max=50"`
        ReactComponentPath string `json:"react_component_path" validate:"required,max=500"`
        BackendServerURL   string `json:"backend_server_url" validate:"required,max=500"`
        Owner              string `json:"owner" validate:"max=100"`
}

// UpdatePluginRequest represents the request structure for updating a plugin
type UpdatePluginRequest struct {
        Name               *string `json:"name,omitempty" validate:"omitempty,min=1,max=40"`
        Title              *string `json:"title,omitempty" validate:"omitempty,min=1,max=100"`
        Description        *string `json:"description,omitempty" validate:"omitempty,max=200"`
        Icon               *string `json:"icon,omitempty" validate:"omitempty,min=3,max=50"`
        ReactComponentPath *string `json:"react_component_path,omitempty" validate:"omitempty,max=500"`
        BackendServerURL   *string `json:"backend_server_url,omitempty" validate:"omitempty,max=500"`
        Owner              *string `json:"owner,omitempty" validate:"omitempty,max=100"`
}

// GetAllPlugins retrieves all plugins with pagination
func (s *PluginService) GetAllPlugins(limit, offset int) (*PluginListResponse, error) <span class="cov6" title="8">{
        // Set default pagination values
        if limit &lt;= 0 </span><span class="cov2" title="2">{
                limit = 20
        }</span>
        <span class="cov6" title="8">if offset &lt; 0 </span><span class="cov1" title="1">{
                offset = 0
        }</span>

        <span class="cov6" title="8">plugins, total, err := s.pluginRepo.GetAll(limit, offset)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov6" title="7">pluginResponses := make([]PluginResponse, len(plugins))
        for i, plugin := range plugins </span><span class="cov1" title="1">{
                pluginResponses[i] = s.toPluginResponse(&amp;plugin)
        }</span>

        <span class="cov6" title="7">return &amp;PluginListResponse{
                Plugins: pluginResponses,
                Total:   total,
                Limit:   limit,
                Offset:  offset,
        }, nil</span>
}

// GetAllPluginsWithViewer retrieves all plugins with pagination and marks subscribed plugins based on viewer's subscriptions
func (s *PluginService) GetAllPluginsWithViewer(limit, offset int, viewerName string) (*PluginListResponse, error) <span class="cov5" title="6">{
        // Set default pagination values
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>
        <span class="cov5" title="6">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov5" title="6">if strings.TrimSpace(viewerName) == "" </span><span class="cov2" title="2">{
                // Fallback to non-subscribed response if viewer missing
                return s.GetAllPlugins(limit, offset)
        }</span>

        // Find viewer by name (mapped from bearer token 'username')
        <span class="cov4" title="4">viewer, err := s.userRepo.GetByName(viewerName)
        if err != nil || viewer == nil </span><span class="cov1" title="1">{
                // Fallback to non-subscribed response if viewer not found
                return s.GetAllPlugins(limit, offset)
        }</span>

        // Parse subscribed plugins from viewer.Metadata
        <span class="cov3" title="3">subscribedSet := make(map[uuid.UUID]struct{})
        if len(viewer.Metadata) &gt; 0 </span><span class="cov2" title="2">{
                var meta map[string]interface{}
                if err := json.Unmarshal(viewer.Metadata, &amp;meta); err == nil &amp;&amp; meta != nil </span><span class="cov1" title="1">{
                        if v, ok := meta["subscribed"]; ok &amp;&amp; v != nil </span><span class="cov1" title="1">{
                                switch arr := v.(type) </span>{
                                case []interface{}:<span class="cov1" title="1">
                                        for _, it := range arr </span><span class="cov1" title="1">{
                                                if str, ok := it.(string); ok &amp;&amp; str != "" </span><span class="cov1" title="1">{
                                                        if id, err := uuid.Parse(strings.TrimSpace(str)); err == nil </span><span class="cov1" title="1">{
                                                                subscribedSet[id] = struct{}{}
                                                        }</span>
                                                }
                                        }
                                case []string:<span class="cov0" title="0">
                                        for _, s2 := range arr </span><span class="cov0" title="0">{
                                                if id, err := uuid.Parse(strings.TrimSpace(s2)); err == nil </span><span class="cov0" title="0">{
                                                        subscribedSet[id] = struct{}{}
                                                }</span>
                                        }
                                }
                        }
                }
        }

        // Fetch plugins
        <span class="cov3" title="3">plugins, total, err := s.pluginRepo.GetAll(limit, offset)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Map to response type and mark subscribed plugins
        <span class="cov2" title="2">pluginResponses := make([]PluginResponse, len(plugins))
        for i, plugin := range plugins </span><span class="cov3" title="3">{
                pr := s.toPluginResponse(&amp;plugin)
                if _, ok := subscribedSet[plugin.ID]; ok </span><span class="cov1" title="1">{
                        pr.Subscribed = true
                }</span>
                <span class="cov3" title="3">pluginResponses[i] = pr</span>
        }

        <span class="cov2" title="2">return &amp;PluginListResponse{
                Plugins: pluginResponses,
                Total:   total,
                Limit:   limit,
                Offset:  offset,
        }, nil</span>
}

// GetPluginByID retrieves a plugin by ID
func (s *PluginService) GetPluginByID(id uuid.UUID) (*PluginResponse, error) <span class="cov3" title="3">{
        plugin, err := s.pluginRepo.GetByID(id)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">response := s.toPluginResponse(plugin)
        return &amp;response, nil</span>
}

// CreatePlugin creates a new plugin
func (s *PluginService) CreatePlugin(req *CreatePluginRequest) (*PluginResponse, error) <span class="cov4" title="4">{
        // Validate the request
        if err := s.validator.Struct(req); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Check if plugin with same name already exists
        <span class="cov3" title="3">existingPlugin, err := s.pluginRepo.GetByName(req.Name)
        if err == nil &amp;&amp; existingPlugin != nil </span><span class="cov1" title="1">{
                return nil, &amp;ValidationError{Message: "Plugin with this name already exists"}
        }</span>

        // Create the plugin model
        <span class="cov2" title="2">plugin := &amp;models.Plugin{
                BaseModel: models.BaseModel{
                        Name:        req.Name,
                        Title:       req.Title,
                        Description: req.Description,
                },
                Icon:               req.Icon,
                ReactComponentPath: req.ReactComponentPath,
                BackendServerURL:   req.BackendServerURL,
                Owner:              req.Owner,
        }

        // Save to database
        if err := s.pluginRepo.Create(plugin); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Return the response
        <span class="cov1" title="1">response := s.toPluginResponse(plugin)
        return &amp;response, nil</span>
}

// UpdatePlugin updates an existing plugin
func (s *PluginService) UpdatePlugin(id uuid.UUID, req *UpdatePluginRequest) (*PluginResponse, error) <span class="cov5" title="5">{
        // Validate the request
        if err := s.validator.Struct(req); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get the existing plugin
        <span class="cov5" title="5">plugin, err := s.pluginRepo.GetByID(id)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Update fields if provided
        <span class="cov4" title="4">if req.Name != nil </span><span class="cov2" title="2">{
                // Check if another plugin with same name already exists
                if *req.Name != plugin.Name </span><span class="cov2" title="2">{
                        existingPlugin, err := s.pluginRepo.GetByName(*req.Name)
                        if err == nil &amp;&amp; existingPlugin != nil </span><span class="cov1" title="1">{
                                return nil, &amp;ValidationError{Message: "Plugin with this name already exists"}
                        }</span>
                }
                <span class="cov1" title="1">plugin.Name = *req.Name</span>
        }
        <span class="cov3" title="3">if req.Title != nil </span><span class="cov2" title="2">{
                plugin.Title = *req.Title
        }</span>
        <span class="cov3" title="3">if req.Description != nil </span><span class="cov1" title="1">{
                plugin.Description = *req.Description
        }</span>
        <span class="cov3" title="3">if req.Icon != nil </span><span class="cov0" title="0">{
                plugin.Icon = *req.Icon
        }</span>
        <span class="cov3" title="3">if req.ReactComponentPath != nil </span><span class="cov0" title="0">{
                plugin.ReactComponentPath = *req.ReactComponentPath
        }</span>
        <span class="cov3" title="3">if req.BackendServerURL != nil </span><span class="cov0" title="0">{
                plugin.BackendServerURL = *req.BackendServerURL
        }</span>
        <span class="cov3" title="3">if req.Owner != nil </span><span class="cov0" title="0">{
                plugin.Owner = *req.Owner
        }</span>

        // Save to database
        <span class="cov3" title="3">if err := s.pluginRepo.Update(plugin); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Return the response
        <span class="cov2" title="2">response := s.toPluginResponse(plugin)
        return &amp;response, nil</span>
}

// DeletePlugin deletes a plugin by ID
func (s *PluginService) DeletePlugin(id uuid.UUID) error <span class="cov3" title="3">{
        // Check if plugin exists
        _, err := s.pluginRepo.GetByID(id)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Delete the plugin
        <span class="cov2" title="2">return s.pluginRepo.Delete(id)</span>
}

// toPluginResponse converts a plugin model to response format
func (s *PluginService) toPluginResponse(plugin *models.Plugin) PluginResponse <span class="cov6" title="8">{
        return PluginResponse{
                ID:                 plugin.ID,
                Name:               plugin.Name,
                Title:              plugin.Title,
                Description:        plugin.Description,
                Icon:               plugin.Icon,
                ReactComponentPath: plugin.ReactComponentPath,
                BackendServerURL:   plugin.BackendServerURL,
                Owner:              plugin.Owner,
        }
}</span>

// ValidationError represents a validation error
type ValidationError struct {
        Message string
}

func (e *ValidationError) Error() string <span class="cov1" title="1">{
        return e.Message
}</span>

// PluginUIResponse represents the response structure for plugin UI content
type PluginUIResponse struct {
        Content     string `json:"content"`
        ContentType string `json:"content_type"`
}

// GetPluginUIContent fetches the TSX React component content from GitHub
func (s *PluginService) GetPluginUIContent(ctx context.Context, pluginID uuid.UUID, githubService GitHubServiceInterface, userUUID, provider string) (*PluginUIResponse, error) <span class="cov5" title="6">{
        // Get the plugin by ID
        plugin, err := s.pluginRepo.GetByID(pluginID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Parse the GitHub URL from react_component_path
        <span class="cov5" title="5">githubURL := plugin.ReactComponentPath
        if githubURL == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("plugin does not have a react_component_path configured")
        }</span>

        // Parse GitHub URL to extract owner, repo, and file path
        <span class="cov4" title="4">owner, repo, filePath, ref, err := parsePluginGitHubURL(githubURL)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid GitHub URL in react_component_path: %w", err)
        }</span>

        // Use default provider if not provided
        <span class="cov3" title="3">if provider == "" </span><span class="cov0" title="0">{
                provider = "github"
        }</span>

        // Fetch the file content from GitHub
        <span class="cov3" title="3">content, err := githubService.GetRepositoryContent(ctx, userUUID, provider, owner, repo, filePath, ref)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to fetch content from GitHub: %w", err)
        }</span>

        // Extract content from the GitHub API response
        <span class="cov2" title="2">var fileContent string

        if contentMap, ok := content.(map[string]interface{}); ok </span><span class="cov2" title="2">{
                if contentStr, exists := contentMap["content"]; exists </span><span class="cov2" title="2">{
                        fileContent = contentStr.(string)
                }</span>
        }

        <span class="cov2" title="2">if fileContent == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no content found in GitHub response")
        }</span>

        <span class="cov1" title="1">return &amp;PluginUIResponse{
                Content:     fileContent,
                ContentType: "text/typescript",
        }, nil</span>
}

// parsePluginGitHubURL parses a GitHub URL and extracts owner, repo, file path, and ref
// Supports URLs like:
// - https://github.com/owner/repo/blob/main/path/to/file.tsx
// - https://github.tools.sap/owner/repo/blob/main/path/to/file.tsx
func parsePluginGitHubURL(githubURL string) (owner, repo, filePath, ref string, err error) <span class="cov6" title="10">{
        // Parse the URL
        parsedURL, err := url.Parse(githubURL)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", "", "", fmt.Errorf("invalid URL: %w", err)
        }</span>

        // Check if it's a GitHub URL
        <span class="cov6" title="10">if !strings.Contains(parsedURL.Host, "github") </span><span class="cov3" title="3">{
                return "", "", "", "", fmt.Errorf("not a GitHub URL")
        }</span>

        // Use regex to parse GitHub blob URL pattern
        // Pattern: /owner/repo/blob/ref/path/to/file
        <span class="cov6" title="7">pattern := regexp.MustCompile(`^/([^/]+)/([^/]+)/blob/([^/]+)/(.+)$`)
        matches := pattern.FindStringSubmatch(parsedURL.Path)

        if len(matches) != 5 </span><span class="cov2" title="2">{
                return "", "", "", "", fmt.Errorf("invalid GitHub blob URL format")
        }</span>

        <span class="cov5" title="5">owner = matches[1]
        repo = matches[2]
        ref = matches[3]
        filePath = matches[4]

        return owner, repo, filePath, ref, nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package service

import (
        "developer-portal-backend/internal/database/models"
        "developer-portal-backend/internal/repository"

        "github.com/go-playground/validator/v10"
        "github.com/google/uuid"
)

// ProjectService handles business logic for project operations
type ProjectService struct {
        projectRepo *repository.ProjectRepository
        validator   *validator.Validate
}

// NewProjectService creates a new project service
func NewProjectService(projectRepo *repository.ProjectRepository, validator *validator.Validate) *ProjectService <span class="cov0" title="0">{
        return &amp;ProjectService{
                projectRepo: projectRepo,
                validator:   validator,
        }
}</span>

// GetAllProjects retrieves all projects from the database
func (s *ProjectService) GetAllProjects() ([]models.Project, error) <span class="cov0" title="0">{
        return s.projectRepo.GetAllProjects()
}</span>

// GetHealthMetadata retrieves the health URL template and success regex for a given project ID
func (s *ProjectService) GetHealthMetadata(projectID uuid.UUID) (string, string, error) <span class="cov0" title="0">{
        return s.projectRepo.GetHealthMetadata(projectID)
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package service

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strings"
        "sync"
        "time"

        "developer-portal-backend/internal/config"
        "developer-portal-backend/internal/logger"
)

// SonarService provides methods to interact with SonarQube APIs
type SonarService struct {
        cfg        *config.Config
        httpClient *http.Client
}

// NewSonarService creates a new Sonar service
func NewSonarService(cfg *config.Config) *SonarService <span class="cov9" title="7">{
        return &amp;SonarService{
                cfg:        cfg,
                httpClient: &amp;http.Client{Timeout: 15 * time.Second},
        }
}</span>

// SonarMeasure represents a single measure entry from Sonar response
type SonarMeasure struct {
        Metric    string `json:"metric"`
        Value     string `json:"value,omitempty"`
        BestValue bool   `json:"bestValue"`
}

// sonarMeasuresAPIResponse represents Sonar's measures/component API response
// Sonar returns measures under the "component" object.
type sonarMeasuresAPIResponse struct {
        Component struct {
                Measures []SonarMeasure `json:"measures"`
        } `json:"component"`
}

// sonarQualityGateAPIResponse represents Sonar's qualitygates/project_status API response
type sonarQualityGateAPIResponse struct {
        ProjectStatus struct {
                Status string `json:"status"`
        } `json:"projectStatus"`
}

// SonarCombinedResponse represents the merged response returned to the client
type SonarCombinedResponse struct {
        Measures []SonarMeasure `json:"measures"`
        Status   string         `json:"status"`
}

// GetComponentMeasures returns measures and quality gate status for a given Sonar project key.
func (s *SonarService) GetComponentMeasures(projectKey string) (*SonarCombinedResponse, error) <span class="cov9" title="7">{
        if s.cfg.SonarHost == "" || s.cfg.SonarToken == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("sonar configuration missing (SONAR_HOST or SONAR_TOKEN)")
        }</span>
        <span class="cov8" title="6">if projectKey == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("project key (component) is required")
        }</span>

        // Normalize base SONAR host URL
        <span class="cov7" title="5">base := s.cfg.SonarHost
        if !strings.HasPrefix(base, "http://") &amp;&amp; !strings.HasPrefix(base, "https://") </span><span class="cov7" title="5">{
                base = "https://" + base
        }</span>
        <span class="cov7" title="5">baseURL, err := url.Parse(strings.TrimRight(base, "/"))
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid sonar host URL '%s': %w", base, err)
        }</span>

        // 1) Prepare URLs for measures and quality gate
        <span class="cov7" title="4">mv := url.Values{}
        mv.Set("component", projectKey)
        mv.Set("metricKeys", "coverage,vulnerabilities,code_smells")
        measuresURL := baseURL.String() + "/api/measures/component?" + mv.Encode()

        qv := url.Values{}
        qv.Set("projectKey", projectKey)
        qgURL := baseURL.String() + "/api/qualitygates/project_status?" + qv.Encode()

        // 2) Invoke both Sonar APIs in parallel
        var measuresResp sonarMeasuresAPIResponse
        var qgResp sonarQualityGateAPIResponse
        var wg sync.WaitGroup
        var firstErr error
        var mu sync.Mutex

        wg.Add(2)
        go func() </span><span class="cov7" title="4">{
                defer wg.Done()
                if err := s.getJSON(measuresURL, &amp;measuresResp); err != nil </span><span class="cov4" title="2">{
                        mu.Lock()
                        if firstErr == nil </span><span class="cov4" title="2">{
                                firstErr = fmt.Errorf("failed to fetch sonar measures: %w", err)
                        }</span>
                        <span class="cov4" title="2">mu.Unlock()</span>
                }
        }()
        <span class="cov7" title="4">go func() </span><span class="cov7" title="4">{
                defer wg.Done()
                if err := s.getJSON(qgURL, &amp;qgResp); err != nil </span><span class="cov1" title="1">{
                        mu.Lock()
                        if firstErr == nil </span><span class="cov1" title="1">{
                                firstErr = fmt.Errorf("failed to fetch sonar quality gate status: %w", err)
                        }</span>
                        <span class="cov1" title="1">mu.Unlock()</span>
                }
        }()

        <span class="cov7" title="4">wg.Wait()
        if firstErr != nil </span><span class="cov5" title="3">{
                return nil, firstErr
        }</span>

        <span class="cov1" title="1">combined := &amp;SonarCombinedResponse{
                Measures: measuresResp.Component.Measures,
                Status:   qgResp.ProjectStatus.Status,
        }
        return combined, nil</span>
}

// getJSON performs an authenticated GET request and decodes JSON into out.
func (s *SonarService) getJSON(fullURL string, out interface{}) error <span class="cov10" title="8">{
        logger.New().Infof("Invoking Sonar API GET %s", fullURL)
        req, err := http.NewRequest(http.MethodGet, fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create HTTP request: %w", err)
        }</span>
        <span class="cov10" title="8">req.Header.Set("Authorization", "Bearer "+s.cfg.SonarToken)
        req.Header.Set("Accept", "application/json")

        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov9" title="7">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov1" title="1">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("sonar request failed: status=%d body=%s", resp.StatusCode, string(body))
        }</span>

        <span class="cov8" title="6">dec := json.NewDecoder(resp.Body)
        if err := dec.Decode(out); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to decode sonar response: %w", err)
        }</span>
        <span class="cov7" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package service

import (
        "encoding/json"
        "errors"
        "fmt"

        "developer-portal-backend/internal/database/models"
        apperrors "developer-portal-backend/internal/errors"
        "developer-portal-backend/internal/logger"
        "developer-portal-backend/internal/repository"

        "github.com/go-playground/validator/v10"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

// TeamService handles business logic for teams
type TeamService struct {
        repo             repository.TeamRepositoryInterface
        groupRepo        repository.GroupRepositoryInterface
        organizationRepo repository.OrganizationRepositoryInterface
        userRepo         repository.UserRepositoryInterface
        linkRepo         repository.LinkRepositoryInterface
        componentRepo    repository.ComponentRepositoryInterface
        validator        *validator.Validate
}

// NewTeamService creates a new team service
func NewTeamService(repo repository.TeamRepositoryInterface, groupRepo repository.GroupRepositoryInterface, orgRepo repository.OrganizationRepositoryInterface, userRepo repository.UserRepositoryInterface, linkRepo repository.LinkRepositoryInterface, compRepo repository.ComponentRepositoryInterface, validator *validator.Validate) *TeamService <span class="cov10" title="68">{
        return &amp;TeamService{
                repo:             repo,
                groupRepo:        groupRepo,
                organizationRepo: orgRepo,
                userRepo:         userRepo,
                linkRepo:         linkRepo,
                componentRepo:    compRepo,
                validator:        validator,
        }
}</span>

// CreateTeamRequest represents the request to create a team
type CreateTeamRequest struct {
        GroupID     uuid.UUID       `json:"group_id" validate:"required"`
        Name        string          `json:"name" validate:"required,min=1,max=40"`
        Title       string          `json:"title" validate:"required,min=1,max=100"`
        Description string          `json:"description" validate:"max=200"`
        Owner       string          `json:"owner" validate:"required,min=5,max=20"`
        Email       string          `json:"email" validate:"required,min=5,max=50"`
        PictureURL  string          `json:"picture_url" validate:"required,min=5,max=200"`
        Metadata    json.RawMessage `json:"metadata" swaggertype:"object"`
}

// UpdateTeamRequest represents the request to update a team
type UpdateTeamRequest struct {
        Title       string          `json:"title" validate:"omitempty,min=1,max=100"`
        Description string          `json:"description" validate:"omitempty,max=200"`
        Owner       string          `json:"owner" validate:"omitempty,min=5,max=20"`
        Email       string          `json:"email" validate:"omitempty,min=5,max=50"`
        PictureURL  string          `json:"picture_url" validate:"omitempty,min=5,max=200"`
        Metadata    json.RawMessage `json:"metadata" swaggertype:"object"`
}

// TeamResponse represents the response for team operations
type TeamResponse struct {
        ID             uuid.UUID       `json:"id"`
        GroupID        uuid.UUID       `json:"group_id"`
        OrganizationID uuid.UUID       `json:"organization_id"` // Include org ID for backwards compatibility
        Name           string          `json:"name"`
        Title          string          `json:"title"`
        Description    string          `json:"description"`
        Owner          string          `json:"owner"`
        Email          string          `json:"email"`
        PictureURL     string          `json:"picture_url"`
        Metadata       json.RawMessage `json:"metadata" swaggertype:"object"`
        CreatedAt      string          `json:"created_at"`
        UpdatedAt      string          `json:"updated_at"`
}

// TeamListResponse represents a paginated list of teams
type TeamListResponse struct {
        Teams    []TeamResponse `json:"teams"`
        Total    int64          `json:"total"`
        Page     int            `json:"page"`
        PageSize int            `json:"page_size"`
}

// TeamWithMembersResponse represents a team with its members
type TeamWithMembersResponse struct {
        TeamResponse
        Members []UserResponse `json:"members"`
        Links   []LinkResponse `json:"links"`
}

// GetByID retrieves a team by ID
func (s *TeamService) GetByID(id uuid.UUID) (*TeamResponse, error) <span class="cov3" title="4">{
        team, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov2" title="2">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        return nil, apperrors.ErrTeamNotFound
                }</span>
                <span class="cov1" title="1">return nil, fmt.Errorf("failed to get team: %w", err)</span>
        }

        <span class="cov2" title="2">return s.toResponse(team)</span>
}

// GetAllTeams retrieves teams for a specific organization or all teams if organizationID is nil
func (s *TeamService) GetAllTeams(organizationID *uuid.UUID, page, pageSize int) (*TeamListResponse, error) <span class="cov6" title="12">{
        if organizationID != nil </span><span class="cov5" title="8">{
                // Validate organization exists
                _, err := s.organizationRepo.GetByID(*organizationID)
                if err != nil </span><span class="cov2" title="2">{
                        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                                return nil, apperrors.ErrOrganizationNotFound
                        }</span>
                        <span class="cov1" title="1">return nil, fmt.Errorf("failed to verify organization: %w", err)</span>
                }

                <span class="cov4" title="6">if page &lt; 1 </span><span class="cov1" title="1">{
                        page = 1
                }</span>
                <span class="cov4" title="6">if pageSize &lt; 1 || pageSize &gt; 100 </span><span class="cov2" title="2">{
                        pageSize = 20
                }</span>

                <span class="cov4" title="6">offset := (page - 1) * pageSize
                teams, total, err := s.repo.GetByOrganizationID(*organizationID, pageSize, offset)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to get teams: %w", err)
                }</span>

                // Filter out the technical team
                <span class="cov4" title="5">filteredTeams := make([]models.Team, 0, len(teams))
                for _, team := range teams </span><span class="cov4" title="6">{
                        if team.Name != "team-developer-portal-technical" </span><span class="cov4" title="5">{
                                filteredTeams = append(filteredTeams, team)
                        }</span>
                }

                <span class="cov4" title="5">responses := make([]TeamResponse, len(filteredTeams))
                for i := range filteredTeams </span><span class="cov4" title="5">{
                        resp, err := s.toResponse(&amp;filteredTeams[i])
                        if err != nil </span><span class="cov1" title="1">{
                                return nil, fmt.Errorf("failed to convert team to response: %w", err)
                        }</span>
                        <span class="cov3" title="4">responses[i] = *resp</span>
                }

                // Adjust total count to exclude filtered teams
                <span class="cov3" title="4">adjustedTotal := total
                if len(teams) &gt; len(filteredTeams) </span><span class="cov1" title="1">{
                        adjustedTotal = total - int64(len(teams)-len(filteredTeams))
                }</span>

                <span class="cov3" title="4">return &amp;TeamListResponse{
                        Teams:    responses,
                        Total:    adjustedTotal,
                        Page:     page,
                        PageSize: pageSize,
                }, nil</span>
        }

        // Get all teams across all organizations (no pagination since user mentioned &lt;100 teams)
        <span class="cov3" title="4">teams, err := s.repo.GetAll()
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get all teams: %w", err)
        }</span>

        // Filter out the technical team
        <span class="cov3" title="3">filteredTeams := make([]models.Team, 0, len(teams))
        for _, team := range teams </span><span class="cov4" title="5">{
                if team.Name != "team-developer-portal-technical" </span><span class="cov3" title="4">{
                        filteredTeams = append(filteredTeams, team)
                }</span>
        }

        <span class="cov3" title="3">responses := make([]TeamResponse, len(filteredTeams))
        for i := range filteredTeams </span><span class="cov3" title="4">{
                resp, err := s.toResponse(&amp;filteredTeams[i])
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to convert team to response: %w", err)
                }</span>
                <span class="cov3" title="3">responses[i] = *resp</span>
        }

        <span class="cov2" title="2">return &amp;TeamListResponse{
                Teams:    responses,
                Total:    int64(len(filteredTeams)),
                Page:     1,
                PageSize: len(filteredTeams),
        }, nil</span>
}

// GetTeamComponentsByID retrieves components owned by a team by team ID
func (s *TeamService) GetTeamComponentsByID(id uuid.UUID, page, pageSize int) ([]models.Component, int64, error) <span class="cov5" title="7">{
        // Verify team exists
        if _, err := s.repo.GetByID(id); err != nil </span><span class="cov2" title="2">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        return nil, 0, apperrors.ErrTeamNotFound
                }</span>
                <span class="cov1" title="1">return nil, 0, fmt.Errorf("failed to get team: %w", err)</span>
        }

        // Set pagination defaults
        <span class="cov4" title="5">if page &lt; 1 </span><span class="cov1" title="1">{
                page = 1
        }</span>
        <span class="cov4" title="5">if pageSize &lt; 1 || pageSize &gt; 100 </span><span class="cov2" title="2">{
                pageSize = 100
        }</span>
        <span class="cov4" title="5">offset := (page - 1) * pageSize

        components, total, err := s.componentRepo.GetComponentsByTeamID(id, pageSize, offset)
        if err != nil </span><span class="cov1" title="1">{
                return nil, 0, fmt.Errorf("failed to get components by team: %w", err)
        }</span>
        <span class="cov3" title="4">return components, total, nil</span>
}

// GetBySimpleName retrieves a team by name across all organizations and includes its members
func (s *TeamService) GetBySimpleName(teamName string) (*TeamWithMembersResponse, error) <span class="cov7" title="22">{
        if teamName == "" </span><span class="cov1" title="1">{
                return nil, apperrors.NewMissingQueryParam("team_name")
        }</span>

        <span class="cov7" title="21">team, err := s.repo.GetByNameGlobal(teamName)
        if err != nil </span><span class="cov3" title="4">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov2" title="2">{
                        return nil, apperrors.ErrTeamNotFound
                }</span>
                <span class="cov2" title="2">return nil, fmt.Errorf("failed to get team by name: %w", err)</span>
        }

        // Get all members of the team (no pagination)
        <span class="cov7" title="17">members, _, err := s.userRepo.GetByTeamID(team.ID, 1000, 0)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get team members: %w", err)
        }</span>

        // Convert team to response
        <span class="cov6" title="16">teamResp, err := s.toResponse(team)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to convert team to response: %w", err)
        }</span>

        // Convert members to UserResponse including metadata fallback
        <span class="cov6" title="15">memberResponses := make([]UserResponse, len(members))
        for i, m := range members </span><span class="cov3" title="4">{
                memberResponses[i] = UserResponse{
                        ID:         m.UserID,
                        UUID:       m.BaseModel.ID.String(),
                        TeamID:     m.TeamID,
                        FirstName:  m.FirstName,
                        LastName:   m.LastName,
                        Email:      m.Email,
                        Mobile:     m.Mobile,
                        TeamDomain: string(m.TeamDomain),
                        TeamRole:   string(m.TeamRole),
                }
        }</span>

        // Fetch links owned by team
        <span class="cov6" title="15">var linkResponses []LinkResponse
        if s.linkRepo != nil </span><span class="cov6" title="15">{
                teamLinks, err := s.linkRepo.GetByOwner(team.ID)
                if err != nil </span><span class="cov1" title="1">{
                        // Log the error but don't fail the request - links are non-critical
                        logger.New().WithFields(map[string]interface{}{
                                "team_id":   team.ID,
                                "team_name": team.Name,
                                "error":     err.Error(),
                        }).Warn("Failed to fetch links for team")
                }</span> else<span class="cov6" title="14"> {
                        linkResponses = make([]LinkResponse, 0, len(teamLinks))
                        for i := range teamLinks </span><span class="cov6" title="15">{
                                linkResponses = append(linkResponses, toLinkResponse(&amp;teamLinks[i]))
                        }</span>
                }
        }

        <span class="cov6" title="15">return &amp;TeamWithMembersResponse{
                TeamResponse: *teamResp,
                Members:      memberResponses,
                Links:        linkResponses,
        }, nil</span>
}

// GetBySimpleNameWithViewer retrieves a team by name across all organizations (with members and links)
// and marks each link's Favorite=true if the logged-in viewer has the link UUID in their metadata.favorites.
func (s *TeamService) GetBySimpleNameWithViewer(teamName string, viewerName string) (*TeamWithMembersResponse, error) <span class="cov6" title="12">{
        // Reuse the base implementation
        resp, err := s.GetBySimpleName(teamName)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>
        <span class="cov5" title="10">if viewerName == "" </span><span class="cov1" title="1">{
                // No viewer information available; return as-is
                return resp, nil
        }</span>

        // Load viewer by name and parse favorites
        <span class="cov5" title="9">viewer, err := s.userRepo.GetByName(viewerName)
        if err != nil || viewer == nil </span><span class="cov1" title="1">{
                // Viewer not found; return unmodified
                return resp, nil
        }</span>

        // Build a set of favorite link UUIDs as strings
        <span class="cov5" title="8">favSet := make(map[string]struct{})
        if len(viewer.Metadata) &gt; 0 </span><span class="cov5" title="7">{
                var meta map[string]interface{}
                if unmarshalErr := json.Unmarshal(viewer.Metadata, &amp;meta); unmarshalErr != nil </span><span class="cov1" title="1">{
                        // Log the error but don't fail the request - favorites are non-critical
                        logger.New().WithFields(map[string]interface{}{
                                "viewer_name": viewerName,
                                "user_id":     viewer.ID,
                                "error":       unmarshalErr.Error(),
                        }).Warn("Failed to parse viewer metadata for favorites")
                }</span> else<span class="cov4" title="6"> if meta != nil </span><span class="cov4" title="6">{
                        if v, ok := meta["favorites"]; ok &amp;&amp; v != nil </span><span class="cov4" title="6">{
                                switch arr := v.(type) </span>{
                                case []interface{}:<span class="cov4" title="5">
                                        for _, it := range arr </span><span class="cov5" title="7">{
                                                if s, ok := it.(string); ok &amp;&amp; s != "" </span><span class="cov5" title="7">{
                                                        if _, parseErr := uuid.Parse(s); parseErr == nil </span><span class="cov4" title="5">{
                                                                favSet[s] = struct{}{}
                                                        }</span>
                                                }
                                        }
                                case []string:<span class="cov0" title="0">
                                        for _, s2 := range arr </span><span class="cov0" title="0">{
                                                if _, parseErr := uuid.Parse(s2); parseErr == nil </span><span class="cov0" title="0">{
                                                        favSet[s2] = struct{}{}
                                                }</span>
                                        }
                                }
                        }
                }
        }

        // Mark favorites in-place
        <span class="cov5" title="8">if len(favSet) &gt; 0 </span><span class="cov3" title="4">{
                for i := range resp.Links </span><span class="cov4" title="6">{
                        if _, ok := favSet[resp.Links[i].ID]; ok </span><span class="cov3" title="4">{
                                resp.Links[i].Favorite = true
                        }</span>
                }
        }

        <span class="cov5" title="8">return resp, nil</span>
}

// toResponse converts a team model to response
func (s *TeamService) toResponse(team *models.Team) (*TeamResponse, error) <span class="cov8" title="34">{
        // Get organization ID through group (for backwards compatibility)
        group, err := s.groupRepo.GetByID(team.GroupID)
        if err != nil </span><span class="cov4" title="5">{
                return nil, fmt.Errorf("failed to get group for team: %w", err)
        }</span>

        <span class="cov8" title="29">return &amp;TeamResponse{
                ID:             team.ID,
                GroupID:        team.GroupID,
                OrganizationID: group.OrgID,
                Name:           team.Name,
                Title:          team.Title,
                Description:    team.Description,
                Owner:          team.Owner,
                Email:          team.Email,
                PictureURL:     team.PictureURL,
                Metadata:       team.Metadata,
        }, nil</span>
}

// UpdateTeamMetadata updates only specific fields in the team's metadata (merge, not replace)
func (s *TeamService) UpdateTeamMetadata(id uuid.UUID, newMetadata json.RawMessage) (*TeamResponse, error) <span class="cov6" title="12">{
        // Get the team first to ensure it exists
        team, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov2" title="2">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        return nil, apperrors.ErrTeamNotFound
                }</span>
                <span class="cov1" title="1">return nil, fmt.Errorf("failed to get team: %w", err)</span>
        }

        // Parse existing metadata
        <span class="cov5" title="10">var existingMeta map[string]interface{}
        if len(team.Metadata) &gt; 0 </span><span class="cov5" title="9">{
                if err := json.Unmarshal(team.Metadata, &amp;existingMeta); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to parse existing metadata: %w", err)
                }</span>
        } else<span class="cov1" title="1"> {
                existingMeta = make(map[string]interface{})
        }</span>

        // Parse new metadata to merge
        <span class="cov5" title="9">var newMeta map[string]interface{}
        if err := json.Unmarshal(newMetadata, &amp;newMeta); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse new metadata: %w", err)
        }</span>

        // Merge: update existing fields, add new fields, preserve unmentioned fields
        <span class="cov5" title="8">for key, value := range newMeta </span><span class="cov6" title="12">{
                existingMeta[key] = value
        }</span>

        // Marshal back to JSON
        <span class="cov5" title="8">mergedMetadata, err := json.Marshal(existingMeta)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal merged metadata: %w", err)
        }</span>

        // Update the metadata field
        <span class="cov5" title="8">team.Metadata = mergedMetadata

        // Save the updated team
        if err := s.repo.Update(team); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to update team metadata: %w", err)
        }</span>

        <span class="cov5" title="7">return s.toResponse(team)</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package service

import (
        "developer-portal-backend/internal/database/models"
        apperrors "developer-portal-backend/internal/errors"
        "developer-portal-backend/internal/logger"
        "developer-portal-backend/internal/repository"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/go-playground/validator/v10"
        "github.com/google/uuid"
)

// UserService handles business logic for members
type UserService struct {
        repo       repository.UserRepositoryInterface
        linkRepo   repository.LinkRepositoryInterface
        pluginRepo repository.PluginRepositoryInterface
        validator  *validator.Validate
}

// NewUserService creates a new member service
func NewUserService(repo repository.UserRepositoryInterface, linkRepo repository.LinkRepositoryInterface, pluginRepo repository.PluginRepositoryInterface, validator *validator.Validate) *UserService <span class="cov10" title="129">{
        return &amp;UserService{
                repo:       repo,
                linkRepo:   linkRepo,
                pluginRepo: pluginRepo,
                validator:  validator,
        }
}</span>

// CreateUserRequest represents the data needed to create a member
// Note: Aligned with models.Member (BaseModel + string ID for IUser)
type CreateUserRequest struct {
        TeamID    *uuid.UUID `json:"team_id"`
        FirstName string     `json:"first_name" validate:"required,max=100"`
        LastName  string     `json:"last_name" validate:"required,max=100"`
        Email     string     `json:"email" validate:"required,email,max=255"`
        Mobile    string     `json:"mobile" validate:"max=20"`
        IUser     string     `json:"iuser" validate:"required,min=5,max=20"`
        Role      *string    `json:"role" example:"developer" default:"developer"` // maps to TeamDomain
        TeamRole  *string    `json:"team_role" example:"member" default:"member"`
        CreatedBy string     `json:"-"` // derived from bearer token 'username'
}

// UpdateUserRequest represents the data needed to update a member
type UpdateUserRequest struct {
        TeamID     *uuid.UUID `json:"team_id"`
        FirstName  *string    `json:"first_name" validate:"omitempty,max=100"`
        LastName   *string    `json:"last_name" validate:"omitempty,max=100"`
        Email      *string    `json:"email" validate:"omitempty,email,max=255"`
        Mobile     *string    `json:"mobile" validate:"omitempty,max=20"`
        TeamDomain *string    `json:"team_domain"` // models.TeamDomain value
        TeamRole   *string    `json:"team_role"`   // maps to models.TeamRole
}

// UserResponse represents the response data for a member
type UserResponse struct {
        ID         string     `json:"id"`
        UUID       string     `json:"uuid"`
        TeamID     *uuid.UUID `json:"team_id,omitempty"`
        FirstName  string     `json:"first_name"`
        LastName   string     `json:"last_name"`
        Email      string     `json:"email"`
        Mobile     string     `json:"mobile"`
        TeamDomain string     `json:"team_domain"` // models.TeamDomain value
        TeamRole   string     `json:"team_role"`   // models.TeamRole value
}

type UserWithLinksAndPluginsResponse struct {
        ID          string           `json:"id"`
        UUID        string           `json:"uuid"`
        TeamID      *uuid.UUID       `json:"team_id,omitempty"`
        FirstName   string           `json:"first_name"`
        LastName    string           `json:"last_name"`
        Email       string           `json:"email"`
        Mobile      string           `json:"mobile"`
        TeamDomain  string           `json:"team_domain"`
        TeamRole    string           `json:"team_role"`
        PortalAdmin bool             `json:"portal_admin,omitempty"`
        Links       []LinkResponse   `json:"link"`
        Plugins     []PluginResponse `json:"plugins"` // subscribed plugins
}

// UsersListResponse is the swagger schema for GET /users
type UsersListResponse struct {
        Users  []UserResponse `json:"users"`
        Total  int64          `json:"total"`
        Limit  int            `json:"limit"`
        Offset int            `json:"offset"`
}

// LDAPUserSearchItem represents a single LDAP user search result item for Swagger
type LDAPUserSearchItem struct {
        ID        string `json:"id"`
        FirstName string `json:"first_name"`
        LastName  string `json:"last_name"`
        Email     string `json:"email"`
        Mobile    string `json:"mobile"`
        New       bool   `json:"new"`
}

/* LDAPUserSearchResponse is the swagger schema for GET /users/search/new */
type LDAPUserSearchResponse struct {
        Result []LDAPUserSearchItem `json:"result"`
}

// CreateUser creates a new member
func (s *UserService) CreateUser(req *CreateUserRequest) (*UserResponse, error) <span class="cov3" title="5">{
        // Validate request
        if err := s.validator.Struct(req); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>
        // Require created_by from token
        <span class="cov3" title="4">if strings.TrimSpace(req.CreatedBy) == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("created_by is required")
        }</span>

        // Check if email already exists (unique within system)
        <span class="cov3" title="4">if existingUser, err := s.repo.GetByEmail(req.Email); err == nil &amp;&amp; existingUser != nil </span><span class="cov1" title="1">{
                logger.New().WithField("error", err).Error("Error getting user by email")
                return nil, apperrors.ErrUserExists
        }</span>

        // Determine team domain (role) default
        <span class="cov3" title="3">teamDomain := models.TeamDomainDeveloper
        if req.Role != nil </span><span class="cov2" title="2">{
                teamDomain = models.TeamDomain(*req.Role)
        }</span>

        // Determine team role default
        <span class="cov3" title="3">teamRole := models.TeamRoleMember
        if req.TeamRole != nil </span><span class="cov2" title="2">{
                teamRole = models.TeamRole(*req.TeamRole)
        }</span>

        <span class="cov3" title="3">user := &amp;models.User{
                BaseModel: models.BaseModel{
                        Name:      strings.TrimSpace(req.FirstName + " " + req.LastName),
                        Title:     strings.TrimSpace(req.FirstName + " " + req.LastName),
                        CreatedBy: req.CreatedBy,
                },
                TeamID:     req.TeamID,
                UserID:     req.IUser, // IUser short id on the user model
                FirstName:  req.FirstName,
                LastName:   req.LastName,
                Email:      req.Email,
                Mobile:     req.Mobile,
                TeamDomain: teamDomain,
                TeamRole:   teamRole,
        }

        if err := s.repo.Create(user); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov3" title="3">return s.convertToResponse(user), nil</span>
}

// AddFavoriteLinkByUserID adds link_id to user's metadata.favorites identified by user_id
func (s *UserService) AddFavoriteLinkByUserID(userID string, linkID uuid.UUID) (*UserResponse, error) <span class="cov5" title="12">{
        if userID == "" </span><span class="cov1" title="1">{
                return nil, apperrors.NewValidationError("user_id", "user_id is required")
        }</span>
        <span class="cov5" title="11">if linkID == uuid.Nil </span><span class="cov1" title="1">{
                return nil, apperrors.NewValidationError("link_id", "link_id is required")
        }</span>

        // Load user by string user_id
        <span class="cov5" title="10">user, err := s.repo.GetByUserID(userID)
        if err != nil || user == nil </span><span class="cov2" title="2">{
                logger.New().WithField("error", err).Error("Error getting user by userID")
                return nil, apperrors.ErrUserNotFound
        }</span>

        // Parse or initialize metadata as a JSON object
        <span class="cov4" title="8">var meta map[string]interface{}
        if len(user.Metadata) == 0 </span><span class="cov3" title="3">{
                meta = map[string]interface{}{}
        }</span> else<span class="cov3" title="5"> {
                if err := json.Unmarshal(user.Metadata, &amp;meta); err != nil || meta == nil </span><span class="cov1" title="1">{
                        // If metadata is invalid/not an object, reset to empty object
                        meta = map[string]interface{}{}
                }</span>
        }

        // Ensure favorites array exists
        <span class="cov4" title="8">var favorites []string
        if v, ok := meta["favorites"]; ok &amp;&amp; v != nil </span><span class="cov3" title="3">{
                switch arr := v.(type) </span>{
                case []interface{}:<span class="cov3" title="3">
                        for _, it := range arr </span><span class="cov3" title="3">{
                                if str, ok := it.(string); ok &amp;&amp; str != "" </span><span class="cov3" title="3">{
                                        favorites = append(favorites, str)
                                }</span>
                        }
                case []string:<span class="cov0" title="0">
                        favorites = append(favorites, arr...)</span>
                }
        }

        // Deduplicate: add linkID if not already present
        <span class="cov4" title="8">linkStr := linkID.String()
        exists := false
        for _, id := range favorites </span><span class="cov3" title="3">{
                if id == linkStr </span><span class="cov1" title="1">{
                        exists = true
                        break</span>
                }
        }
        <span class="cov4" title="8">if !exists </span><span class="cov4" title="7">{
                favorites = append(favorites, linkStr)
        }</span>

        // Save back to metadata
        <span class="cov4" title="8">meta["favorites"] = favorites
        bytes, err := json.Marshal(meta)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal metadata: %w", err)
        }</span>
        <span class="cov4" title="8">user.Metadata = json.RawMessage(bytes)

        // Persist update
        if err := s.repo.Update(user); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov4" title="7">return s.convertToResponse(user), nil</span>
}

// RemoveFavoriteLinkByUserID removes link_id from user's metadata.favorites identified by user_id
func (s *UserService) RemoveFavoriteLinkByUserID(userID string, linkID uuid.UUID) (*UserResponse, error) <span class="cov5" title="13">{
        if userID == "" </span><span class="cov1" title="1">{
                return nil, apperrors.NewValidationError("user_id", "user_id is required")
        }</span>
        <span class="cov5" title="12">if linkID == uuid.Nil </span><span class="cov1" title="1">{
                return nil, apperrors.NewValidationError("link_id", "link_id is required")
        }</span>

        // Load user by string user_id
        <span class="cov5" title="11">user, err := s.repo.GetByUserID(userID)
        if err != nil || user == nil </span><span class="cov1" title="1">{
                logger.New().WithField("error", err).Error("Error getting user by userID")
                return nil, apperrors.ErrUserNotFound
        }</span>

        // Parse or initialize metadata as a JSON object
        <span class="cov5" title="10">var meta map[string]interface{}
        if len(user.Metadata) == 0 </span><span class="cov1" title="1">{
                meta = map[string]interface{}{}
        }</span> else<span class="cov5" title="9"> {
                if err := json.Unmarshal(user.Metadata, &amp;meta); err != nil || meta == nil </span><span class="cov1" title="1">{
                        // If metadata is invalid/not an object, reset to empty object
                        meta = map[string]interface{}{}
                }</span>
        }

        // Extract favorites array if exists
        <span class="cov5" title="10">var favorites []string
        if v, ok := meta["favorites"]; ok &amp;&amp; v != nil </span><span class="cov4" title="7">{
                switch arr := v.(type) </span>{
                case []interface{}:<span class="cov4" title="7">
                        for _, it := range arr </span><span class="cov5" title="9">{
                                if str, ok := it.(string); ok &amp;&amp; str != "" </span><span class="cov5" title="9">{
                                        favorites = append(favorites, str)
                                }</span>
                        }
                case []string:<span class="cov0" title="0">
                        favorites = append(favorites, arr...)</span>
                }
        }

        // Filter out the linkID (idempotent if not present)
        <span class="cov5" title="10">linkStr := linkID.String()
        filtered := make([]string, 0, len(favorites))
        for _, id := range favorites </span><span class="cov5" title="9">{
                if id != linkStr </span><span class="cov3" title="3">{
                        filtered = append(filtered, id)
                }</span>
        }

        // Save back to metadata
        <span class="cov5" title="10">meta["favorites"] = filtered
        bytes, err := json.Marshal(meta)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal metadata: %w", err)
        }</span>
        <span class="cov5" title="10">user.Metadata = json.RawMessage(bytes)

        // Persist update
        if err := s.repo.Update(user); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov5" title="9">return s.convertToResponse(user), nil</span>
}

// AddSubscribedPluginByUserID adds plugin_id to user's metadata.subscribed identified by user_id
func (s *UserService) AddSubscribedPluginByUserID(userID string, pluginID uuid.UUID) (*UserResponse, error) <span class="cov5" title="9">{
        if userID == "" </span><span class="cov1" title="1">{
                return nil, apperrors.NewValidationError("user_id", "user_id is required")
        }</span>
        <span class="cov4" title="8">if pluginID == uuid.Nil </span><span class="cov1" title="1">{
                return nil, apperrors.NewValidationError("plugin_id", "plugin_id is required")
        }</span>

        // Load user by string user_id
        <span class="cov4" title="7">user, err := s.repo.GetByUserID(userID)
        if err != nil || user == nil </span><span class="cov1" title="1">{
                logger.New().WithField("error", err).Error("Error getting user by userID")
                return nil, apperrors.ErrUserNotFound
        }</span>

        // Parse or initialize metadata as a JSON object
        <span class="cov4" title="6">var meta map[string]interface{}
        if len(user.Metadata) == 0 </span><span class="cov2" title="2">{
                meta = map[string]interface{}{}
        }</span> else<span class="cov3" title="4"> {
                if err := json.Unmarshal(user.Metadata, &amp;meta); err != nil || meta == nil </span><span class="cov1" title="1">{
                        // If metadata is invalid/not an object, reset to empty object
                        meta = map[string]interface{}{}
                }</span>
        }

        // Ensure subscribed array exists
        <span class="cov4" title="6">var subscribed []string
        if v, ok := meta["subscribed"]; ok &amp;&amp; v != nil </span><span class="cov2" title="2">{
                switch arr := v.(type) </span>{
                case []interface{}:<span class="cov2" title="2">
                        for _, it := range arr </span><span class="cov2" title="2">{
                                if str, ok := it.(string); ok &amp;&amp; str != "" </span><span class="cov2" title="2">{
                                        subscribed = append(subscribed, str)
                                }</span>
                        }
                case []string:<span class="cov0" title="0">
                        subscribed = append(subscribed, arr...)</span>
                }
        }

        // Deduplicate: add pluginID if not already present
        <span class="cov4" title="6">pluginStr := pluginID.String()
        exists := false
        for _, id := range subscribed </span><span class="cov2" title="2">{
                if id == pluginStr </span><span class="cov1" title="1">{
                        exists = true
                        break</span>
                }
        }
        <span class="cov4" title="6">if !exists </span><span class="cov3" title="5">{
                subscribed = append(subscribed, pluginStr)
        }</span>

        // Save back to metadata
        <span class="cov4" title="6">meta["subscribed"] = subscribed
        bytes, err := json.Marshal(meta)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal metadata: %w", err)
        }</span>
        <span class="cov4" title="6">user.Metadata = json.RawMessage(bytes)

        // Persist update
        if err := s.repo.Update(user); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov3" title="5">return s.convertToResponseWithPlugins(user), nil</span>
}

// RemoveSubscribedPluginByUserID removes plugin_id from user's metadata.subscribed identified by user_id
func (s *UserService) RemoveSubscribedPluginByUserID(userID string, pluginID uuid.UUID) (*UserResponse, error) <span class="cov5" title="12">{
        if userID == "" </span><span class="cov1" title="1">{
                return nil, apperrors.NewValidationError("user_id", "user_id is required")
        }</span>
        <span class="cov5" title="11">if pluginID == uuid.Nil </span><span class="cov1" title="1">{
                return nil, apperrors.NewValidationError("plugin_id", "plugin_id is required")
        }</span>

        // Load user by string user_id
        <span class="cov5" title="10">user, err := s.repo.GetByUserID(userID)
        if err != nil || user == nil </span><span class="cov1" title="1">{
                logger.New().WithField("error", err).Error("Error getting user by userID")
                return nil, apperrors.ErrUserNotFound
        }</span>

        // Parse or initialize metadata as a JSON object
        <span class="cov5" title="9">var meta map[string]interface{}
        if len(user.Metadata) == 0 </span><span class="cov1" title="1">{
                meta = map[string]interface{}{}
        }</span> else<span class="cov4" title="8"> {
                if err := json.Unmarshal(user.Metadata, &amp;meta); err != nil || meta == nil </span><span class="cov1" title="1">{
                        // If metadata is invalid/not an object, reset to empty object
                        meta = map[string]interface{}{}
                }</span>
        }

        // Extract subscribed array if exists
        <span class="cov5" title="9">var subscribed []string
        if v, ok := meta["subscribed"]; ok &amp;&amp; v != nil </span><span class="cov4" title="6">{
                switch arr := v.(type) </span>{
                case []interface{}:<span class="cov4" title="6">
                        for _, it := range arr </span><span class="cov4" title="8">{
                                if str, ok := it.(string); ok &amp;&amp; str != "" </span><span class="cov4" title="8">{
                                        subscribed = append(subscribed, str)
                                }</span>
                        }
                case []string:<span class="cov0" title="0">
                        subscribed = append(subscribed, arr...)</span>
                }
        }

        // Filter out the pluginID (idempotent if not present)
        <span class="cov5" title="9">pluginStr := pluginID.String()
        filtered := make([]string, 0, len(subscribed))
        for _, id := range subscribed </span><span class="cov4" title="8">{
                if id != pluginStr </span><span class="cov3" title="3">{
                        filtered = append(filtered, id)
                }</span>
        }

        // Save back to metadata
        <span class="cov5" title="9">meta["subscribed"] = filtered
        bytes, err := json.Marshal(meta)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal metadata: %w", err)
        }</span>
        <span class="cov5" title="9">user.Metadata = json.RawMessage(bytes)

        // Persist update
        if err := s.repo.Update(user); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov4" title="8">return s.convertToResponse(user), nil</span>
}

// GetMemberByID retrieves a member by ID (UUID)
func (s *UserService) GetUserByID(id uuid.UUID) (*UserResponse, error) <span class="cov2" title="2">{
        user, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov1" title="1">{
                logger.New().WithField("error", err).Error("Error getting user by ID")
                return nil, apperrors.ErrUserNotFound
        }</span>

        <span class="cov1" title="1">return s.convertToResponse(user), nil</span>
}

// GetUserByUserID retrieves a member by their string UserID (e.g., I123456)
func (s *UserService) GetUserByUserID(userID string) (*UserResponse, error) <span class="cov3" title="3">{
        if userID == "" </span><span class="cov1" title="1">{
                return nil, apperrors.NewValidationError("user_id", "user_id is required")
        }</span>

        <span class="cov2" title="2">user, err := s.repo.GetByUserID(userID)
        if err != nil </span><span class="cov1" title="1">{
                logger.New().WithField("error", err).Error("Error getting user by UserID")
                return nil, apperrors.ErrUserNotFound
        }</span>

        <span class="cov1" title="1">return s.convertToResponse(user), nil</span>
}

// GetUserByName retrieves a user by BaseModel.Name (used to store username)
func (s *UserService) GetUserByName(name string) (*UserResponse, error) <span class="cov3" title="4">{
        name = strings.TrimSpace(name)
        if name == "" </span><span class="cov1" title="1">{
                return nil, apperrors.NewValidationError("name", "name is required")
        }</span>

        <span class="cov3" title="3">user, err := s.repo.GetByName(name)
        if err != nil || user == nil </span><span class="cov1" title="1">{
                logger.New().WithField("error", err).Error("Error getting user by name")
                return nil, apperrors.ErrUserNotFound
        }</span>

        <span class="cov2" title="2">return s.convertToResponse(user), nil</span>
}

// GetUserByNameWithLinks retrieves a user by BaseModel.Name and returns links-enriched response
func (s *UserService) GetUserByNameWithLinks(name string) (*UserWithLinksAndPluginsResponse, error) <span class="cov4" title="8">{
        name = strings.TrimSpace(name)
        if name == "" </span><span class="cov1" title="1">{
                return nil, apperrors.NewValidationError("name", "name is required")
        }</span>

        <span class="cov4" title="7">user, err := s.repo.GetByName(name)
        if err != nil || user == nil </span><span class="cov1" title="1">{
                return nil, apperrors.ErrUserNotFound
        }</span>

        // Reuse existing logic by delegating to the user_id-based implementation
        <span class="cov4" title="6">return s.GetUserByUserIDWithLinks(user.UserID)</span>
}

// GetUserByUserIDWithPlugins retrieves subscribed plugins for a user by their UserID
func (s *UserService) GetUserByUserIDWithPlugins(userID string) ([]PluginResponse, error) <span class="cov3" title="3">{
        if userID == "" </span><span class="cov1" title="1">{
                return nil, apperrors.NewValidationError("user_id", "user_id is required")
        }</span>

        <span class="cov2" title="2">user, err := s.repo.GetByUserID(userID)
        if err != nil || user == nil </span><span class="cov1" title="1">{
                logger.New().WithField("error", err).Error("Error getting user by UserID")
                return nil, apperrors.ErrUserNotFound
        }</span>

        <span class="cov1" title="1">return s.GetSubscribedPluginsFromUser(user), nil</span>
}

// GetSubscribedPluginsFromUser extracts and fetches subscribed plugins from user metadata
func (s *UserService) GetSubscribedPluginsFromUser(user *models.User) []PluginResponse <span class="cov5" title="11">{
        subscribedPlugins := make([]PluginResponse, 0)
        if len(user.Metadata) &gt; 0 </span><span class="cov5" title="9">{
                var meta map[string]interface{}
                if err := json.Unmarshal(user.Metadata, &amp;meta); err == nil &amp;&amp; meta != nil </span><span class="cov4" title="8">{
                        if v, ok := meta["subscribed"]; ok &amp;&amp; v != nil </span><span class="cov4" title="6">{
                                var pluginIDs []uuid.UUID
                                switch arr := v.(type) </span>{
                                case []interface{}:<span class="cov4" title="6">
                                        for _, it := range arr </span><span class="cov5" title="10">{
                                                if s, ok := it.(string); ok &amp;&amp; s != "" </span><span class="cov5" title="10">{
                                                        if id, err := uuid.Parse(strings.TrimSpace(s)); err == nil </span><span class="cov5" title="10">{
                                                                pluginIDs = append(pluginIDs, id)
                                                        }</span>
                                                }
                                        }
                                case []string:<span class="cov0" title="0">
                                        for _, s2 := range arr </span><span class="cov0" title="0">{
                                                if id, err := uuid.Parse(strings.TrimSpace(s2)); err == nil </span><span class="cov0" title="0">{
                                                        pluginIDs = append(pluginIDs, id)
                                                }</span>
                                        }
                                }

                                // Fetch plugin details for each subscribed plugin
                                <span class="cov4" title="6">for _, pluginID := range pluginIDs </span><span class="cov5" title="10">{
                                        if plugin, err := s.pluginRepo.GetByID(pluginID); err == nil </span><span class="cov5" title="9">{
                                                subscribedPlugins = append(subscribedPlugins, PluginResponse{
                                                        ID:                 plugin.ID,
                                                        Name:               plugin.Name,
                                                        Title:              plugin.Title,
                                                        Description:        plugin.Description,
                                                        Icon:               plugin.Icon,
                                                        ReactComponentPath: plugin.ReactComponentPath,
                                                        BackendServerURL:   plugin.BackendServerURL,
                                                        Owner:              plugin.Owner,
                                                })
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov5" title="11">return subscribedPlugins</span>
}

// GetUserByNameWithLinksAndPlugins retrieves a user by BaseModel.Name and returns both links and plugins
func (s *UserService) GetUserByNameWithLinksAndPlugins(name string) (*UserWithLinksAndPluginsResponse, error) <span class="cov3" title="5">{
        name = strings.TrimSpace(name)
        if name == "" </span><span class="cov1" title="1">{
                return nil, apperrors.NewValidationError("name", "name is required")
        }</span>

        <span class="cov3" title="4">user, err := s.repo.GetByName(name)
        if err != nil || user == nil </span><span class="cov1" title="1">{
                logger.New().WithField("error", err).Error("Error getting user by name")
                return nil, apperrors.ErrUserNotFound
        }</span>

        // Get the user with links first
        <span class="cov3" title="3">userWithLinks, err := s.GetUserByUserIDWithLinks(user.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get the subscribed plugins using the extracted method
        <span class="cov3" title="3">userWithLinks.Plugins = s.GetSubscribedPluginsFromUser(user)

        return userWithLinks, nil</span>
}

// GetUserByUserIDWithLinks returns a user with links by their UserID
func (s *UserService) GetUserByUserIDWithLinks(userID string) (*UserWithLinksAndPluginsResponse, error) <span class="cov5" title="11">{
        if userID == "" </span><span class="cov0" title="0">{
                return nil, apperrors.NewValidationError("user_id", "user_id is required")
        }</span>

        <span class="cov5" title="11">user, err := s.repo.GetByUserID(userID)
        if err != nil || user == nil </span><span class="cov1" title="1">{
                logger.New().WithField("error", err).Error("Error getting user by userID")
                return nil, apperrors.ErrUserNotFound
        }</span>

        // Portal admin flag computed from metadata
        <span class="cov5" title="10">portalAdmin := false

        // Parse favorites from metadata
        favSet := make(map[uuid.UUID]struct{})
        if len(user.Metadata) &gt; 0 </span><span class="cov4" title="6">{
                var meta map[string]interface{}
                if err := json.Unmarshal(user.Metadata, &amp;meta); err == nil &amp;&amp; meta != nil </span><span class="cov4" title="6">{
                        if v, ok := meta["favorites"]; ok &amp;&amp; v != nil </span><span class="cov3" title="5">{
                                switch arr := v.(type) </span>{
                                case []interface{}:<span class="cov3" title="5">
                                        for _, it := range arr </span><span class="cov4" title="7">{
                                                if s, ok := it.(string); ok &amp;&amp; s != "" </span><span class="cov4" title="7">{
                                                        if id, err := uuid.Parse(strings.TrimSpace(s)); err == nil </span><span class="cov4" title="7">{
                                                                favSet[id] = struct{}{}
                                                        }</span>
                                                }
                                        }
                                case []string:<span class="cov0" title="0">
                                        for _, s2 := range arr </span><span class="cov0" title="0">{
                                                if id, err := uuid.Parse(strings.TrimSpace(s2)); err == nil </span><span class="cov0" title="0">{
                                                        favSet[id] = struct{}{}
                                                }</span>
                                        }
                                }
                        }
                        // Compute portal_admin flag (supports bool, string, numeric)
                        <span class="cov4" title="6">if v, ok := meta["portal_admin"]; ok &amp;&amp; v != nil </span><span class="cov3" title="3">{
                                switch val := v.(type) </span>{
                                case bool:<span class="cov1" title="1">
                                        portalAdmin = val</span>
                                case string:<span class="cov1" title="1">
                                        trim := strings.TrimSpace(val)
                                        portalAdmin = strings.EqualFold(trim, "true") || trim == "1" || strings.EqualFold(trim, "yes")</span>
                                case float64:<span class="cov1" title="1">
                                        portalAdmin = val != 0</span>
                                }
                        }
                }
        }

        // Collect favorite IDs
        <span class="cov5" title="10">favIDs := make([]uuid.UUID, 0, len(favSet))
        for id := range favSet </span><span class="cov4" title="7">{
                favIDs = append(favIDs, id)
        }</span>

        // Fetch links (favorites + owned)
        <span class="cov5" title="10">favorites, _ := s.linkRepo.GetByIDs(favIDs)
        owned, _ := s.linkRepo.GetByOwner(user.ID)

        // Merge unique by ID
        combined := make(map[uuid.UUID]models.Link)
        for _, l := range owned </span><span class="cov2" title="2">{
                combined[l.ID] = l
        }</span>
        <span class="cov5" title="10">for _, l := range favorites </span><span class="cov4" title="7">{
                combined[l.ID] = l
        }</span>

        // Build link responses and mark favorites
        <span class="cov5" title="10">links := make([]LinkResponse, 0, len(combined))
        for _, l := range combined </span><span class="cov5" title="9">{
                lr := toLinkResponse(&amp;l)
                if _, ok := favSet[l.ID]; ok </span><span class="cov4" title="7">{
                        lr.Favorite = true
                }</span>
                <span class="cov5" title="9">links = append(links, lr)</span>
        }

        <span class="cov5" title="10">resp := &amp;UserWithLinksAndPluginsResponse{
                ID:          user.UserID,
                UUID:        user.ID.String(),
                TeamID:      user.TeamID,
                FirstName:   user.FirstName,
                LastName:    user.LastName,
                Email:       user.Email,
                Mobile:      user.Mobile,
                TeamDomain:  string(user.TeamDomain),
                TeamRole:    string(user.TeamRole),
                PortalAdmin: portalAdmin,
                Links:       links,
                Plugins:     []PluginResponse{}, // Empty array, plugins should be fetched separately if needed
        }
        return resp, nil</span>
}

func (s *UserService) GetAllUsers(limit, offset int) ([]UserResponse, int64, error) <span class="cov3" title="4">{
        users, total, err := s.repo.GetAll(limit, offset)
        if err != nil </span><span class="cov1" title="1">{
                return nil, 0, fmt.Errorf("failed to get users: %w", err)
        }</span>

        <span class="cov3" title="3">responses := make([]UserResponse, len(users))
        for i, user := range users </span><span class="cov3" title="3">{
                responses[i] = *s.convertToResponse(&amp;user)
        }</span>

        <span class="cov3" title="3">return responses, total, nil</span>
}

// SearchUsersGlobal performs case-insensitive search across BaseModel.Name and BaseModel.Title
func (s *UserService) SearchUsersGlobal(query string, limit, offset int) ([]UserResponse, int64, error) <span class="cov3" title="4">{
        users, total, err := s.repo.SearchByNameOrTitleGlobal(query, limit, offset)
        if err != nil </span><span class="cov1" title="1">{
                return nil, 0, fmt.Errorf("failed to search users: %w", err)
        }</span>

        <span class="cov3" title="3">responses := make([]UserResponse, len(users))
        for i, user := range users </span><span class="cov3" title="4">{
                responses[i] = *s.convertToResponse(&amp;user)
        }</span>

        <span class="cov3" title="3">return responses, total, nil</span>
}

// GetMembersByOrganization retrieves members for an organization
func (s *UserService) GetUsersByOrganization(organizationID uuid.UUID, limit, offset int) ([]UserResponse, int64, error) <span class="cov1" title="1">{
        users, total, err := s.repo.GetByOrganizationID(organizationID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get users: %w", err)
        }</span>

        <span class="cov1" title="1">responses := make([]UserResponse, len(users))
        for i, user := range users </span><span class="cov2" title="2">{
                responses[i] = *s.convertToResponse(&amp;user)
        }</span>

        <span class="cov1" title="1">return responses, total, nil</span>
}

// UpdateMember updates an existing member
func (s *UserService) UpdateUser(id uuid.UUID, req *UpdateUserRequest) (*UserResponse, error) <span class="cov3" title="3">{
        // Validate request
        if err := s.validator.Struct(req); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov3" title="3">user, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov1" title="1">{
                logger.New().WithField("error", err).Error("Error getting user by id")
                return nil, apperrors.ErrUserNotFound
        }</span>

        // Check email uniqueness if email is being updated
        <span class="cov2" title="2">if req.Email != nil &amp;&amp; *req.Email != user.Email </span><span class="cov2" title="2">{
                if existingUser, err := s.repo.GetByEmail(*req.Email); err == nil &amp;&amp; existingUser != nil </span><span class="cov1" title="1">{
                        logger.New().WithField("error", err).Error("Error getting user by email")
                        return nil, apperrors.ErrUserExists
                }</span>
        }

        // Update fields
        <span class="cov1" title="1">if req.TeamID != nil </span><span class="cov0" title="0">{
                user.TeamID = req.TeamID
        }</span>
        <span class="cov1" title="1">if req.FirstName != nil </span><span class="cov1" title="1">{
                user.FirstName = *req.FirstName
        }</span>
        <span class="cov1" title="1">if req.LastName != nil </span><span class="cov1" title="1">{
                user.LastName = *req.LastName
        }</span>
        <span class="cov1" title="1">if req.Email != nil </span><span class="cov1" title="1">{
                user.Email = *req.Email
        }</span>
        <span class="cov1" title="1">if req.Mobile != nil </span><span class="cov0" title="0">{
                user.Mobile = *req.Mobile
        }</span>
        <span class="cov1" title="1">if req.TeamDomain != nil </span><span class="cov0" title="0">{
                user.TeamDomain = models.TeamDomain(*req.TeamDomain)
        }</span>
        <span class="cov1" title="1">if req.TeamRole != nil </span><span class="cov0" title="0">{
                user.TeamRole = models.TeamRole(*req.TeamRole)
        }</span>

        <span class="cov1" title="1">if err := s.repo.Update(user); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov1" title="1">return s.convertToResponse(user), nil</span>
}

// UpdateUserTeam sets a user's team and audit fields
func (s *UserService) UpdateUserTeam(userID uuid.UUID, teamID uuid.UUID, updatedBy string) (*UserResponse, error) <span class="cov4" title="7">{
        if strings.TrimSpace(updatedBy) == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("updated_by is required")
        }</span>
        <span class="cov4" title="6">user, err := s.repo.GetByID(userID)
        if err != nil || user == nil </span><span class="cov2" title="2">{
                logger.New().WithField("error", err).Error("Error getting user by userID")
                return nil, apperrors.ErrUserNotFound
        }</span>
        <span class="cov3" title="4">user.TeamID = &amp;teamID
        user.UpdatedBy = updatedBy
        if err := s.repo.Update(user); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to update user team: %w", err)
        }</span>
        <span class="cov3" title="3">return s.convertToResponse(user), nil</span>
}

// DeleteMember deletes a
func (s *UserService) DeleteUser(id uuid.UUID) error <span class="cov2" title="2">{
        _, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov1" title="1">{
                logger.New().WithField("error", err).Error("Error getting user by id")
                return apperrors.ErrUserNotFound
        }</span>

        <span class="cov1" title="1">if err := s.repo.Delete(id); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete member: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// SearchMembers searches for members by first/last name or email
func (s *UserService) SearchUsers(organizationID uuid.UUID, query string, limit, offset int) ([]UserResponse, int64, error) <span class="cov2" title="2">{
        users, total, err := s.repo.SearchByOrganization(organizationID, query, limit, offset)
        if err != nil </span><span class="cov1" title="1">{
                return nil, 0, fmt.Errorf("failed to search users: %w", err)
        }</span>

        <span class="cov1" title="1">responses := make([]UserResponse, len(users))
        for i, user := range users </span><span class="cov2" title="2">{
                responses[i] = *s.convertToResponse(&amp;user)
        }</span>

        <span class="cov1" title="1">return responses, total, nil</span>
}

// GetActiveMembers returns all members for an organization (is_active removed from model)
func (s *UserService) GetActiveUsers(organizationID uuid.UUID, limit, offset int) ([]UserResponse, int64, error) <span class="cov2" title="2">{
        users, total, err := s.repo.GetActiveByOrganization(organizationID, limit, offset)
        if err != nil </span><span class="cov1" title="1">{
                return nil, 0, fmt.Errorf("failed to get active users: %w", err)
        }</span>

        <span class="cov1" title="1">responses := make([]UserResponse, len(users))
        for i, user := range users </span><span class="cov2" title="2">{
                responses[i] = *s.convertToResponse(&amp;user)
        }</span>

        <span class="cov1" title="1">return responses, total, nil</span>
}

// convertToResponse converts a member model to response
func (s *UserService) convertToResponse(user *models.User) *UserResponse <span class="cov8" title="51">{
        return &amp;UserResponse{
                ID:         user.UserID,
                UUID:       user.ID.String(),
                TeamID:     user.TeamID,
                FirstName:  user.FirstName,
                LastName:   user.LastName,
                Email:      user.Email,
                Mobile:     user.Mobile,
                TeamDomain: string(user.TeamDomain),
                TeamRole:   string(user.TeamRole),
        }
}</span>

// convertToResponseWithPlugins converts a member model to response with subscribed plugins fetched
func (s *UserService) convertToResponseWithPlugins(user *models.User) *UserResponse <span class="cov3" title="5">{
        return &amp;UserResponse{
                ID:         user.UserID,
                UUID:       user.ID.String(),
                TeamID:     user.TeamID,
                FirstName:  user.FirstName,
                LastName:   user.LastName,
                Email:      user.Email,
                Mobile:     user.Mobile,
                TeamDomain: string(user.TeamDomain),
                TeamRole:   string(user.TeamRole),
        }
}</span>

// ===== Quick Links compatibility stubs (model no longer stores metadata) =====

// AddQuickLinkRequest represents the request to add a quick link to a member
type AddQuickLinkRequest struct {
        URL      string `json:"url" validate:"required,url"`
        Title    string `json:"title" validate:"required"`
        Icon     string `json:"icon,omitempty"`
        Category string `json:"category,omitempty"`
}

// QuickLink represents a quick link in the response
type QuickLink struct {
        URL      string `json:"url"`
        Title    string `json:"title"`
        Icon     string `json:"icon,omitempty"`
        Category string `json:"category,omitempty"`
}

// QuickLinksResponse represents the response for getting quick links
type QuickLinksResponse struct {
        QuickLinks []QuickLink `json:"quick_links"`
}

// GetQuickLinks retrieves quick links from a member (returns empty since metadata removed)
func (s *UserService) GetQuickLinks(id uuid.UUID) (*QuickLinksResponse, error) <span class="cov2" title="2">{
        // Validate member exists
        if _, err := s.repo.GetByID(id); err != nil </span><span class="cov1" title="1">{
                logger.New().WithField("error", err).Error("Error getting user by name")
                return nil, apperrors.ErrUserNotFound
        }</span>
        <span class="cov1" title="1">return &amp;QuickLinksResponse{QuickLinks: []QuickLink{}}, nil</span>
}

// AddQuickLink adds a quick link (no-op; returns member unchanged)
func (s *UserService) AddQuickLink(id uuid.UUID, req *AddQuickLinkRequest) (*UserResponse, error) <span class="cov4" title="6">{
        // Validate request
        if err := s.validator.Struct(req); err != nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>
        <span class="cov3" title="3">user, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov1" title="1">{
                logger.New().WithField("error", err).Error("Error getting user by id")
                return nil, apperrors.ErrUserNotFound
        }</span>
        <span class="cov2" title="2">return s.convertToResponse(user), nil</span>
}

// RemoveQuickLink removes a quick link (no-op; returns member unchanged)
func (s *UserService) RemoveQuickLink(id uuid.UUID, linkURL string) (*UserResponse, error) <span class="cov3" title="3">{
        if linkURL == "" </span><span class="cov1" title="1">{
                return nil, apperrors.NewValidationError("url", "link URL is required")
        }</span>
        <span class="cov2" title="2">user, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov1" title="1">{
                logger.New().WithField("error", err).Error("Error getting user by id")
                return nil, apperrors.ErrUserNotFound
        }</span>
        <span class="cov1" title="1">return s.convertToResponse(user), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
